<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_DA16200.svd -->
<!--
  Copyright (C) 2019 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Generated by cmsis-svd (version 0.2), d.d. April 22, 2019 - 08:52:10
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA16200</name>                                          <!-- name of part-->
  <series>DA16200</series>                                         <!-- device series the device belongs to -->
  <version>1.0</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>200</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
Copyright (C) 2019 Dialog Semiconductor. All rights reserved.\n
\n
Redistribution and use in source and binary forms, with or without\n
modification, are permitted provided that the following conditions are met:\n
- Redistributions of source code must retain the above copyright\n
  notice, this list of conditions and the following disclaimer.\n
- Redistributions in binary form must reproduce the above copyright\n
  notice, this list of conditions and the following disclaimer in the\n
  documentation and/or other materials provided with the distribution.\n
- Neither the name of Dialog Semiconductor nor the names of its contributors\n
  may be used to endorse or promote products derived from this software\n
  without specific prior written permission.\n
\n
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n
ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE\n
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n
POSSIBILITY OF SUCH DAMAGE.
</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM4</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		<vtorPresent>true</vtorPresent><sauNumRegions>0</sauNumRegions><dspPresent>true</dspPresent>
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>
	<name>AES_HASH</name>
	<version>1.0</version>
	<description>AES_HASH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30040000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>260</size>
	<usage>registers</usage>
</addressBlock>
	<interrupt>
	<name>SNC</name>
	<description>Sensor Node Controller interrupt request.</description>
	<value>0</value>
</interrupt><interrupt>
	<name>DMA</name>
	<description>General Purpose DMA interrupt request.</description>
	<value>1</value>
</interrupt><interrupt>
	<name>CHARGER_STATE</name>
	<description>Charger State interrupt request.</description>
	<value>2</value>
</interrupt><interrupt>
	<name>CHARGER_ERROR</name>
	<description>Charger Error interrupt request.</description>
	<value>3</value>
</interrupt><interrupt>
	<name>CMAC2SYS</name>
	<description>CMAC and mailbox interrupt request.</description>
	<value>4</value>
</interrupt><interrupt>
	<name>UART</name>
	<description>UART interrupt request.</description>
	<value>5</value>
</interrupt><interrupt>
	<name>UART2</name>
	<description>UART2 interrupt request.</description>
	<value>6</value>
</interrupt><interrupt>
	<name>UART3</name>
	<description>UART3 interrupt request.</description>
	<value>7</value>
</interrupt><interrupt>
	<name>I2C</name>
	<description>I2C interrupt request.</description>
	<value>8</value>
</interrupt><interrupt>
	<name>I2C2</name>
	<description>I2C2 interrupt request.</description>
	<value>9</value>
</interrupt><interrupt>
	<name>SPI</name>
	<description>SPI interrupt request.</description>
	<value>10</value>
</interrupt><interrupt>
	<name>SPI2</name>
	<description>SPI2 interrupt request.</description>
	<value>11</value>
</interrupt><interrupt>
	<name>PCM</name>
	<description>PCM interrupt request.</description>
	<value>12</value>
</interrupt><interrupt>
	<name>SRC_IN</name>
	<description>SRC input interrupt request.</description>
	<value>13</value>
</interrupt><interrupt>
	<name>SRC_OUT</name>
	<description>SRC output interrupt request.</description>
	<value>14</value>
</interrupt><interrupt>
	<name>USB</name>
	<description>USB interrupt request.</description>
	<value>15</value>
</interrupt><interrupt>
	<name>TIMER</name>
	<description>TIMER interrupt request.</description>
	<value>16</value>
</interrupt><interrupt>
	<name>TIMER2</name>
	<description>TIMER2 interrupt request.</description>
	<value>17</value>
</interrupt><interrupt>
	<name>RTC</name>
	<description>RTC interrupt request.</description>
	<value>18</value>
</interrupt><interrupt>
	<name>KEY_WKUP_GPIO</name>
	<description>Debounced button press interrupt request.</description>
	<value>19</value>
</interrupt><interrupt>
	<name>PDC</name>
	<description>Wakeup IRQ from PDC to CM33</description>
	<value>20</value>
</interrupt><interrupt>
	<name>VBUS</name>
	<description>VBUS presence interrupt request.</description>
	<value>21</value>
</interrupt><interrupt>
	<name>MRM</name>
	<description>Cache Miss Rate Monitor interrupt request.</description>
	<value>22</value>
</interrupt><interrupt>
	<name>MOTOR_CONTROLLER</name>
	<description>MOTOR and mailbox interrupt request.</description>
	<value>23</value>
</interrupt><interrupt>
	<name>TRNG</name>
	<description>True Random Number Generation interrupt request.</description>
	<value>24</value>
</interrupt><interrupt>
	<name>DCDC</name>
	<description>DCDC interrupt request.</description>
	<value>25</value>
</interrupt><interrupt>
	<name>XTAL32M_RDY</name>
	<description>XTAL32M trimmed and ready interrupt request.</description>
	<value>26</value>
</interrupt><interrupt>
	<name>GPADC</name>
	<description>General Purpose Analog-Digital Converter interrupt request.</description>
	<value>27</value>
</interrupt><interrupt>
	<name>SDADC</name>
	<description>Sigma Delta Analog-Digital Converter interrupt request.</description>
	<value>28</value>
</interrupt><interrupt>
	<name>CRYPTO</name>
	<description>Crypto interrupt request.</description>
	<value>29</value>
</interrupt><interrupt>
	<name>CAPTIMER</name>
	<description>GPIO triggered Timer Capture interrupt request.</description>
	<value>30</value>
</interrupt><interrupt>
	<name>RFDIAG</name>
	<description>Baseband or Radio Diagnostics interrupt request.</description>
	<value>31</value>
</interrupt><interrupt>
	<name>LCD_CONTROLLER</name>
	<description>Parallel LCD Controller interrupt request.</description>
	<value>32</value>
</interrupt><interrupt>
	<name>PLL_LOCK</name>
	<description>Pll lock interrupt request.</description>
	<value>33</value>
</interrupt><interrupt>
	<name>TIMER3</name>
	<description>TIMER3 interrupt request.</description>
	<value>34</value>
</interrupt><interrupt>
	<name>TIMER4</name>
	<description>TIMER4 interrupt request.</description>
	<value>35</value>
</interrupt><interrupt>
	<name>LRA</name>
	<description>LRA/ERM interrupt request.</description>
	<value>36</value>
</interrupt><interrupt>
	<name>RTC_EVENT</name>
	<description>RTC event interrupt request.</description>
	<value>37</value>
</interrupt><interrupt>
	<name>GPIO_P0</name>
	<description>GPIO port 0 toggle interrupt request.</description>
	<value>38</value>
</interrupt><interrupt>
	<name>GPIO_P1</name>
	<description>GPIO port 1 toggle interrupt request.</description>
	<value>39</value>
</interrupt>
	<registers>
	<register>
	<name>CRYPTO_CLRIRQ_REG</name>
	<description>Crypto Clear interrupt request</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_CLRIRQ</name>
	<description>Write 1 to clear a pending interrupt request.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_CTRL_REG</name>
	<description>Crypto Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_AES_KEXP</name>
	<description>It forces (active high) the execution of the key expansion process with the starting of the AES encryption/decryption process. The bit will be cleared automatically by the hardware, after the completion of the AES key expansion process.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_MORE_IN</name>
	<description>0 : Define that this is the last input block. When the current input is consumed by the crypto engine and the output data is written to the memory, the calculation ends (CRYPTO_INACTIVE goes to one).
1 : The current input data block is not the last. More input data will follow. When the current input is consumed, the engine stops and waits for more data (CRYPTO_WAIT_FOR_IN goes to one).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_OUT_LEN</name>
	<description>The number of bytes minus one of the hash result which will be saved at the memory by the DMA. In relation with the selected hash algorithm the accepted values are:
MD5: 0..15 -&gt; 1-16 bytes
SHA-1: 0..19 -&gt; 1-20 bytes
SHA-256: 0..31 -&gt; 1 - 32 bytes
SHA-256/224: 0..27 -&gt; 1- 28 bytes
SHA-384: 0..47 -&gt; 1 - 48 bytes
SHA-512: 0..63 -&gt; 1 - 64 bytes
SHA-512/224: 0..27 -&gt; 1- 28 bytes
SHA-512/256: 0..31 -&gt; 1 - 32 bytes</description>
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_SEL</name>
	<description>Selects the type of the algorithm
0 : The encryption algorithm (AES)
1 : A hash algorithm.
The exact algorithm is defined by the fileds CRYPTO_ALG and CRYPTO_ALG_MD.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_IRQ_EN</name>
	<description>Interrupt Request Enable
0 : The interrupt generation ability is disabled.
1 : The interrupt generation ability is enabled. Generates an interrupt request at the end of operation.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ENCDEC</name>
	<description>Encryption/Decryption
0 : Decryption
1 : Encryption</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_AES_KEY_SZ</name>
	<description>The size of AES Key
0x0 : 128 bits AES Key
0x1 : 192 bits AES Key
0x2 : 256 bits AES Key
0x3 : 256 bits AES Key</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_OUT_MD</name>
	<description>Output Mode. This field makes sense only when the AES algorithm is selected (CRYPTO_HASH_SEL =0)
0 : Write back to memory all the resulting data
1 : Write back to memory only the final block of the resulting data</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG_MD</name>
	<description>It defines the mode of operation of the AES algorithm when the controller is configured for an encryption/decryption processing (CRYPTO_HASH_SEL = 0).
0x0 : ECB
0x1 : ECB
0x2 : CTR
0x3 : CBC

When the controller is configured to applies a HASH function, this field selects the desired HASH algorithm with the help of the CRYPTO_ALG.

0x0 : HASH algorithms that are based on 32 bits operations
0x1 : HASH algorithms that are based on 64 bits operations
0x2 : Reserved
0x3 : Reserved

See also the CRYPTO_ALG field.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG</name>
	<description>Algorithm selection. When CRYPTO_HASH_SEL = 0 the only available choice is the AES algorithm.
0x0 : AES
0x1 : Reserved
0x2 : Reserved
0x3 : Reserved

When CRYPTO_HASH_SEL = 1, this field selects the desired hash algorithm, with the help of the CRYPTO_ALG_MD field.

If CRYPTO_ALG_MD = 0x0
0x0 : MD5
0x1 : SHA-1
0x2 : SHA-256/224
0x3 : SHA-256

If CRYPTO_ALG_MD = 0x1
0x0 : SHA-384
0x1 : SHA-512
0x2 : SHA-512/224
0x3 : SHA-512/256


</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_DEST_ADDR_REG</name>
	<description>Crypto DMA destination memory</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_DEST_ADDR</name>
	<description>Destination address at where the result of the processing is stored. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_FETCH_ADDR_REG</name>
	<description>Crypto DMA fetch register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_FETCH_ADDR</name>
	<description>The memory address from where will be retrieved the data that will be processed. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_KEYS_START</name>
	<description>Crypto First position of the AES keys storage memory</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_KEY_X</name>
	<description>CRYPTO_KEY_(0-63)
This is the AES keys storage memory. This memory is accessible via AHB slave interface, only when the CRYPTO is inactive (CRYPTO_INACTIVE = 1).</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_LEN_REG</name>
	<description>Crypto Length of the input block in bytes</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_LEN</name>
	<description>It contains the number of bytes of input data. If this number is not a multiple of a block size, the data is automatically extended with zeros. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG0_REG</name>
	<description>Crypto Mode depended register 0</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG0</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[31:0]
CTR - CTRBLK[31:0]. It is the initial value of the 32 bits counter.
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG1_REG</name>
	<description>Crypto Mode depended register 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG1</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[63:32]
CTR - CTRBLK[63:32]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG2_REG</name>
	<description>Crypto Mode depended register 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG2</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[95:64]
CTR - CTRBLK[95:64]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG3_REG</name>
	<description>Crypto Mode depended register 3</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG3</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[127:96]
CTR - CTRBLK[127:96]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_START_REG</name>
	<description>Crypto Start calculation</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_START</name>
	<description>Write 1 to initiate the processing of the input data. This register is auto-cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_STATUS_REG</name>
	<description>Crypto Status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_IRQ_ST</name>
	<description>The status of the interrupt request line of the CRYPTO block.
0 : There is no active interrupt request.
1 : An interrupt request is pending.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_WAIT_FOR_IN</name>
	<description>Indicates the situation where the engine waits for more input data. This is applicable when the CRYPTO_MORE_IN= 1, so the input data are fragmented in the memory.
0 : The crypto is not waiting for more input data.
1 : The crypto waits for more input data.
The CRYPTO_INACTIVE flag remains to zero to indicate that the calculation is not finished. The supervisor of the CRYPTO must program to the CRYPTO_FETCH_ADDR and CRYPTO_LEN a new input data fragment. The calculation will be continued as soon as the CRYPTO_START register will be written with 1. This action will clear the CRYPTO_WAIT_FOR_IN flag.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_INACTIVE</name>
	<description>0 : The CRYPTO is active. The processing is in progress.
1 : The CRYPTO is inactive. The processing has finished.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC_BIF</name>
	<version>1.0</version>
	<description>ANAMISC_BIF registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030b00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CAL_CLK_SEL</name>
	<description>Select reference clock input to be used in calibration:
0x0 : DIVN clock
0x1 : RC32K
0x2 : RC32M
0x3 : XTAL32K
0x4 : RCOSC
0x5, 0x6, 0x7: Reserved</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXT_CNT_EN_SEL</name>
	<description>0 : Enable XTAL_CNT counter by the REF_CLK selected by REF_CLK_SEL.
1 : Enable XTAL_CNT counter from an external input.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select clock input for calibration:
0x0 : RC32K
0x1 : RC32M
0x2 : XTAL32K
0x3 : RCX
0x4 : RCOSC</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_REG</name>
	<description>DIVN reference cycles, lower 16 bits</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>APU</name>
	<version>1.0</version>
	<description>APU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>276</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>APU_MUX_REG</name>
	<description>APU mux register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>PDM1_MUX_IN</name>
	<description>PDM1 input mux
0 = SRC1_MUX_IN
1 = PDM input</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM1_MUX_IN</name>
	<description>PCM1 input mux
0 = off
1 = SRC1 output
2 = PCM output registers</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC1_MUX_IN</name>
	<description>SRC1 input mux
0 = off
1 = PCM output
2 = SRC1 input registers</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF0A_SET1_REG</name>
	<description>SRC coefficient 10 set 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000041f2</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRC_COEF10</name>
	<description>coefficient 10</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF10_SET1_REG</name>
	<description>SRC coefficient 1,0 set 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x79a99278</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_COEF1</name>
	<description>coefficient 1</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF0</name>
	<description>coefficient 0</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF32_SET1_REG</name>
	<description>SRC coefficient 3,2 set 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x6d568b41</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_COEF3</name>
	<description>coefficient 3</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF2</name>
	<description>coefficient 2</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF54_SET1_REG</name>
	<description>SRC coefficient 5,4 set 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_COEF5</name>
	<description>coefficient 5</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF4</name>
	<description>coefficient 4 </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF76_SET1_REG</name>
	<description>SRC coefficient 7,6 set 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_COEF7</name>
	<description>coefficient 7
</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF6</name>
	<description>coefficient 6</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>COEF98_SET1_REG</name>
	<description>SRC coefficient 9,8 set 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_COEF9</name>
	<description>coefficient 9</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF8</name>
	<description>coefficient 8</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM1_CTRL_REG</name>
	<description>PCM1 Control register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PCM_FSC_DIV</name>
	<description>PCM Framesync divider, Values 7-0xFFF. To divide by N, write N-1. (Minimum value N-1=7 for 8 bits PCM_FSC)
Note if PCM_CLK_BIT=1, N must always be even</description>
	<bitRange>[31:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSC_EDGE</name>
	<description>0: shift channels 1, 2, 3, 4, 5, 6, 7, 8 after PCM_FSC edge
1: shift channels 1, 2, 3, 4 after PCM_FSC edge shift channels 5, 6, 7, 8 after opposite PCM_FSC edge </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CH_DEL</name>
	<description>Channel delay in multiples of 8 bits </description>
	<bitRange>[15:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CLK_BIT</name>
	<description>0:One clock cycle per data bit
1:Two cloc cycles per data bit</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCINV</name>
	<description>0: PCM FSC
1: PCM FSC inverted</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CLKINV</name>
	<description>0:PCM CLK
1:PCM CLK inverted</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_PPOD</name>
	<description>0:PCM DO push pull
1:PCM DO open drain</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCDEL</name>
	<description>0:PCM FSC starts one cycle before MSB bit
1:PCM FSC starts at the same time as MSB bit</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCLEN</name>
	<description>0:PCM FSC length equal to 1 data bit
N:PCM FSC length equal to N*8 </description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_MASTER</name>
	<description>0:PCM interface in slave mode
1:PCM interface in master mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_EN</name>
	<description>0:PCM interface disabled
1:PCM interface enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM1_IN1_REG</name>
	<description>PCM1 data in 1</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PCM_IN</name>
	<description>PCM1_IN1 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PCM1_IN2_REG</name>
	<description>PCM1 data in 2</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PCM_IN</name>
	<description>PCM1_IN2 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PCM1_OUT1_REG</name>
	<description>PCM1 data out 1</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT1 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM1_OUT2_REG</name>
	<description>PCM1 data out 2</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT2 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_CTRL_REG</name>
	<description>SRC1 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_PDM_DO_DEL</name>
	<description>PDM_DO output delay line (typical)
0: no delay
1: 8 ns
2: 12 ns
3: 16 ns</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_MODE</name>
	<description>PDM Output mode selection on PDM_DO1
00: No output
01: Right channel (data from SRC1_IN_REG)
10: Left channel (data from SRC2_IN_REG)
11: Left and Right channel</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_DI_DEL</name>
	<description>PDM_DI input delay line (typical)
0: no delay
1: 4 ns
2: 8 ns
3: 12 ns</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_OUT Overflow/underflow bits 23-22. No more over/underflow indications while bit is 1. Keep 1 until the over/under flow bit is cleared </description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_IN_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_IN Overflow/underflow bits 21-20. No more over/underflow indications while bit is 1. Keep 1 until the over/under flow bit is cleared </description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_UNFLOW</name>
	<description>1 = SRC1_OUT Underflow occurred </description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_OVFLOW</name>
	<description>1 = SRC1_OUT Overflow occurred </description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_UNFLOW</name>
	<description>1 = SRC1_IN Underflow occurred </description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_OVFLOW</name>
	<description>1 = SRC1_IN Overflow occurred </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_RESYNC</name>
	<description>1 = SRC will restart synchronisation</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_OK</name>
	<description>SRC1_OUT Status
0: acquisition in progress
1: acquisition ready (In manual mode this bit is always 1)</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_US</name>
	<description>SRC1_OUT UpSampling IIR filters setting
00: for sample rates up-to 48kHz
01: for sample rates of 96kHz
10: reserved
11: for sample rates of 192kHz</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_CAL_BYPASS</name>
	<description>SRC1_OUT1 upsampiling filter bypass
0:Do not bypass
1:Bypass filter</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_AMODE</name>
	<description>SRC1_OUT1 Automatic Conversion mode
0:Manual mode
1:Automatic mode</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_OUT_INV</name>
	<description>Swap the left and the right output PDM channel</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_DIRECTION</name>
	<description>0 = SRC fifo is used to store samples from memory to SRC
1 = SRC fifo is used to store sample from SRC to memory</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_ENABLE</name>
	<description>0 = fifo disable. On each src request, one sample is serviced
1 = fifo enable. Fifo is used to store samples from / to src
SRC supports only DMA burst size 4 when fifo is enable else no burst</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_DSD_MODE</name>
	<description>0 = SRC1 OUT PDM mode
1 = SRC1 OUT DSD mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_DSD_MODE</name>
	<description>0: SRC1 IN PDM mode
1: SRC1 IN DSD mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DITHER_DISABLE</name>
	<description>Dithering feature
0: Enable
1: Disable</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_OK</name>
	<description>SRC1_IN status
0: Acquisition in progress
1: Acquisition ready</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_DS</name>
	<description>SRC1_IN UpSampling IIR filters setting
00: for sample rates up-to 48kHz
01: for sample rates of 96kHz
10: reserved
11: for sample rates of 192kHz</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_IN_INV</name>
	<description>Swap the left and the right input PDM channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_CAL_BYPASS</name>
	<description>SRC1_IN upsampeling filter bypass
0: Do not bypass
1: Bypass filter</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_AMODE</name>
	<description>SRC1_IN Automatic conversion mode
0: Manual mode
1: Automatic mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_EN</name>
	<description>SRC1_IN and SRC1_OUT enable
0: disabled
1: enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN1_REG</name>
	<description>SRC1 data in 1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN2_REG</name>
	<description>SRC1 data in 2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN_FS_REG</name>
	<description>SRC1 Sample input rate</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_IN_FS</name>
	<description>SRC_IN Sample rate
SRC_IN_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192kHz. For 96kHz and 192kHz SRC_CTRLx_REG[SRC_IN_DS] must be set as shown below:
(for SRC_DIV=1)
Sample_rate SRC_IN_FS SRC_IN_DS Audio bandwidth
8000 Hz 0x050000 0 4000 Hz
11025 Hz 0x06E400 0 5512 Hz
16000 Hz 0x0A0000 0 8000 Hz
22050 Hz 0x0DC800 0 11025 Hz
32000 Hz 0x140000 0 16000 Hz
44100 Hz 0x1B9000 0 22050 Hz
48000 Hz 0x1E0000 0 24000 Hz
96000 Hz 0x1E0000 1 24000 Hz
192000 Hz 0x1E0000 3 24000 Hz

In manual SRC mode, SRC_IN_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_IN_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT1_REG</name>
	<description>SRC1 data out 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT2_REG</name>
	<description>SRC1 data out 2</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT_FS_REG</name>
	<description>SRC1 Sample output rate</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRC_OUT_FS</name>
	<description>SRC_OUT Sample rate
SRC_OUT_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192kHz. For 96kHz and 192kHz SRC_CTRLx_REG[SRC_DS] must be set as shown below:
(for SRC_DIV=1)
Sample_rate SRC_OUT_FS  SRC_OUT_DS Audio bandwidth
8000 Hz     0x050000    0          4000 Hz
11025 Hz    0x06E400    0          5512 Hz
16000 Hz    0x0A0000    0          8000 Hz
22050 Hz    0x0DC800    0          11025 Hz
32000 Hz    0x140000    0          16000 Hz
44100 Hz    0x1B9000    0          22050 Hz
48000 Hz    0x1E0000    0          24000 Hz
96000 Hz    0x1E0000    1          24000 Hz
192000 Hz   0x1E0000    3          24000 Hz

In manual SRC mode, SRC_OUT_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_OUT_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CACHE</name>
	<version>1.0</version>
	<description>CACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x100c0000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>84</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CACHE_ASSOCCFG_REG</name>
	<description>Cache associativity configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CACHE_ASSOC</name>
	<description>Cache associativity:
0: 1-way (direct mapped)
1: 2-way
2: 4-way
3: reserved.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_CTRL1_REG</name>
	<description>Cache control register 1</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CACHE_RES1</name>
	<description>Reserved. Always keep 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_FLUSH</name>
	<description>Writing a '1' into this bit, flushes the contents of the tag memories which invalidates the content of the cache memory.
The read of this bit is always '0'.
Note: The flushing of the cache TAG memory takes 0x100 or 0x200 HCLK cycles for a Cache Data RAM size of 8 KB resp. 16 KB.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CACHE_CTRL2_REG</name>
	<description>Cache control register 2</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CACHE_CGEN</name>
	<description>0: Cache controller clock gating is not enabled.
1: Cache controller clock gating is enabled (enabling power saving).
Note: This bit must be set to '0' (default) when setting the CACHE_FLUSH bit while executing from other than QSPI FLASH cached, e.g. from Booter or SYSRAM.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_WEN</name>
	<description>0: Cache Data and TAG memory read only.
1: Cache Data and TAG memory read/write.
The TAG and Data memory are only updated by the cache controller.
There is no HW protection to prevent unauthorized access by the ARM.
Note: When accessing the memory mapped Cache Data and TAG memory (for debugging purposes) only 32 bits access is allowed to the Cache Data memory and only 16 bits access is allowed to the Cache TAG memory.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_LEN</name>
	<description>Length of QSPI FLASH cacheable memory.
N*64 KByte. N = 0 to 512 (max. of 32 Mbyte).
Setting CACHE_LEN=0 disables the cache.
Note 1: The max. relevant CACHE_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_LEN=1) includes the memory space specified by CACHE_FLASH_REG[FLASH_REGION_OFFSET].</description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_FLASH_REG</name>
	<description>Cache Flash program size and base address register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x16000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FLASH_REGION_BASE</name>
	<description>These bits corresponds with the Flash region base address bits [31:16].
Default value is '0x1600'.
The Flash region base address bits [31:25] are fixed to '0x16' and bits [17:16] are fixed to '0x0'.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The Flash region base address setting depends on the chosen Flash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_OFFSET</name>
	<description>Flash region offset address (in words).
This value is added to the Flash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_SIZE</name>
	<description>Flash region size.
Default value is '6' (0.5 MBytes).
0 = 32 MBytes,
1 = 16 MBytes,
2 = 8 MBytes,
3 = 4 MBytes,
4 = 2 MBytes,
5 = 1 MBytes,
6 = 0.5 MBytes,
7 = 0.25 MBytes.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_LNSIZECFG_REG</name>
	<description>Cache line size configuration register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CACHE_LINE</name>
	<description>Cache line size:
0: 8 bytes,
1: 16 bytes,
2: 32 bytes,
3: reserved.
Note: Flush the cache just after the dynamic (run-time) reconfiguration of the cache with an 8 bytes cache line size: write the value &quot;01&quot; into the cache control register CACHE_CTRL1_REG just after the write of the value &quot;00&quot; into the cache line size configuration register CACHE_LNSIZECFG_REG.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_CTRL_REG</name>
	<description>Cache MRM (Miss Rate Monitor) CONTROL register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_IRQ_HITS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache hits reached the programmed threshold (threshold != 0).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MISSES_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor,</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the &quot;misses/hits&quot; counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to '1' and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 16 MHz) until it's '0'. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to '0' by the MRM hardware and the MRM interrupt will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS THRESHOLD register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_HITS_THRES_STATUS].
Note: When MRM_HITS_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) MISSES register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) THRESHOLD register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES_THRES</name>
	<description>Defines the misses threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_MISSES_THRES_STATUS].
Note: When MRM_MISSES_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_TINT_REG</name>
	<description>Cache MRM (Miss Rate Monitor) TIME INTERVAL register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 32 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SWD_RESET_REG</name>
	<description>SWD HW reset control register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SWD_HW_RESET_REQ</name>
	<description>0: default.
1: HW reset request (from the debugger tool). The register is automatically reset with a HW_RESET.
This bit can only be accessed by the debugger software and not by the application.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHARGER</name>
	<version>1.0</version>
	<description>CHARGER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>112</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHARGER_CC_CHARGE_TIMER_REG</name>
	<description>Maximum CC-charge time limit register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001c20</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CC_CHARGE_TIMER</name>
	<description>Returns the current value of the CC-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the Pre-Charge and the CV-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_CC_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CC_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the CC (Constant Current) charging stage. If this is exceeded, a CC charge time-out error will be captured by the Charger's control unit and its FSM will move to the ERROR state. In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CTRL_REG</name>
	<description>Charger main control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x003f6278</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>EOC_INTERVAL_CHECK_TIMER</name>
	<description>The specific bit-field determines the current state of the timer used to periodically check the End-of-Charge signal, as soon as the Charger's FSM is either in CC_CHARGE or CV_CHARGE state. Thus, as soon as the Charger's FSM enters the CC_CHARGE state:
  - The timer starts increasing when a positive edge detection on End-of-Charge signal occurs.
  - It keeps increasing until reaching the programmed EOC_INTERVAL_CHECK_THRES value, if and only if there is no detection of a negative edge on End-of-Charge signal. If this happens, the timer resets and starts over with a new End-of-Charge positive edge.
  - The timer also resets after having reached its programmed threshold or when the Charger's FSM next state is END_OF_CHARGE. This happens only after having found End-of-Charge signal asserted for 4 consecutive checks and provided that the specific signal has not de-asserted during the timer's interval.
Note: It must be noted that out of these two states, the specific timer is kept to zero. It is also noted that this timer runs at the 1Mhz clock of the Charger's block and its value always ranges from 0 to the EOC_INTERVAL_CHECK_THRES value set in the respective bit-field of CHARGER_CTRL_REG.</description>
	<bitRange>[27:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_INTERVAL_CHECK_THRES</name>
	<description>This bit-field determines the periodic interval of checking the End-of-Charge signal, when the Charger's FSM is either in CC_CHARGE or in CV_CHARGE state. To implement this, a dedicated timer has been used, counting from zero up to the value programmed into this bit-field (see also EOC_INTERVAL_CHECK_TIMER field's description).
As soon as this timer reaches the programmed value, the End-of-Charge signal is sampled and depending on its status (high or low), another counter, keeping the number of consecutive End-of-Charge events, is increased or not. See also the description of the EOC_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG, for this counter.
Note: The specific bit-field should always be programmed to a non-zero value.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REPLENISH_MODE</name>
	<description>When this bit-field is set and the Charger's FSM is in the BYPASSED state (thus, in Bypass mode), the internal multiplexer inside the digital part of the charger selects the Replenish, instead of the Pre-charge setting to be driven to the main Vbat comparator of the Charger's analogue circuitry. By this way, SW can read the respective analogue comparator's output in CHARGER_STATUS_REG (bit-field MAIN_VBAT_COMP_OUT), after the battery's volrtage has reached the End-of-Charge level, and determine if the battery voltage has dropped below the Replenish level, re-starting the battery charging accordingly.
Note: When the Charger's FSM is active and operational, this bit-field is don't care and the FSM determines which level (Pre-charge or Replenish) will be selected and driven to the analogue, depending on the current state. It is also noted that the supported Pre-charge and Replenish levels can be viewed in the respective bit-fields defined in CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRE_CHARGE_MODE</name>
	<description>When set, this bit-field enables a signal of the same name with the bit-field, driven from the Charger's digital part towards the analogue circuitry, in order to determine the current in Pre-Charge mode. If the Charger's FSM is active and operational, the specific bit-field is don't care. Hence, it is considered only when the Charger's FSM has reached the BYPASSED state (thus, in Bypass mode).
With the Charger's FSM being bypassed, SW should take over control and set the specific bit-field, in order to deliver the Pre-Charge instead of the normal Charge current to the Charger's analogue circuitry, during the Pre-Charge phase.
Note: See also the description of CHARGER_CURRENT_PARAM_REG register for the Pre-Charge and normal Charge current levels supported.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_LOOP_HOLD</name>
	<description>When set, this bit-field disables charging, provided that the Charger's FSM has switched to the BYPASSED state. This is possible only by setting the CHARGER_BYPASS bit-field of this register.
Thus, as soon as the Charger's FSM is bypassed, the respective signal driven by the FSM is overruled by this bit-field, making the analogue part of the Charger controllable also in this mode. If the Charger's FSM is not bypassed, this bit-field is don't care.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>JEITA_SUPPORT_DISABLED</name>
	<description>0 = Charger's JEITA FSM monitoring the battery temperature checks also if battery temperature is in the Warm or Cool zones.
In that case, it updates accordingly all the Charger's voltage levels (Charge, Pre-Charge, Replenish and OVP) programmed in CHARGER_VOLTAGE_PARAM_REG, as well as the charge and pre-charge current settings of CHARGER_CURRENT_PARAM_REG, depending on the temperature zone determined by the analogue circuitry of the Charger (see also the JEITA registers of the Charger's register file for the Voltage/Current levels in Warm and Cool temperature zones).
1 = Charger's JEITA FSM monitoring the battery temperature checks only if battery temperature is either in the Hot or Cold zones. In that case, it notifies the main Charger FSM to stop charging automatically, when in Hot zone. The same will happen also for the case of Cold, unless the NTC_LOW_DISABLE bit-field of CHARGER_CTRL_REG is set.
Note : It is not recommended to have the specific bit-field kept to '0' (and thus the JEITA support enabled), if at the same time the bit-field TBAT_PROT_ENABLE of the same register is also '0'. Thus, JEITA support should be coupled with the Battery's temperature protection.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_MONITOR_MODE</name>
	<description>Battery temperature pack monitoring modes, according to the following encoding:
00 = Battery temperature state checked and updated once, as soon as the charger is powered-up and settled.
01 = Battery temperature state checked periodically, depeding on TBAT_MON_TIMER_REG.TBAT_MON_INTERVAL and provided that Charger has been powered-up and charger's FSM is enabled.
10 = Battery temperature state checked periodically depending on TBAT_MON_TIMER_REG.TBAT_MON_INTERVAL, provided that Charger is powered-up and regardless if the Charger's FSM is enabled or not. Hence, this mode can be effective regardless of the state of CHARGE_START bit-field of CHARGER_CTRL_REG.
11 = When selected, it freezes the Battery temperature monitor FSM, as soon as the latter reaches the CHECK_IDLE state (see also CHARGER_STATUS_REG.CHARGER_JEITA_STATE bit-field's description for the states of this FSM). In this mode, the monitoring of Battery temperature is possible only by checking the status of TBAT_HOT_COMP_OUT and MAIN_TBAT_COMP_OUT bit-fields of CHARGER_STATUS_REG, thus by letting SW take over monitoring. This setting may be used in conjunction with Bypass mode (by setting CHARGER_BYPASS of CHARGER_CTRL_REG), so that both charging and battery temperature status monitoring are controlled by SW.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_TIMERS_HALT_ENABLE</name>
	<description>0 = Charge timeout timers continue running when charging is disabled because of a Die or of a Battery temperature error.
1 = Charge timeout timers are halted in case of a Die or of a Battery temperature error.
In that case, the global charge timer is stopped as soon as the Charger's FSM moves to TDIE_PROT or TBAT_PROT state. Also, either the Pre-Charge, the CC_CHARGE or the CV_CHARGE timer is also stopped, depending on the charging state of the FSM when the Die/Battery temperature error has been detected. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NTC_LOW_DISABLE</name>
	<description>0 = Charging is disabled when the battery temperature is found to have reached the &quot;COLD&quot; region. Therefore, the Charger's FSM moves directly to &quot;TBAT_PROT&quot; error and generates an IRQ to notify the system accordingly, in case the respective IRQ mask bit of CHARGER_ERROR_IRQ_MASK_REG is set. Also, CHARGER_ERROR_IRQ_STATUS_REG. TBAT_ERROR_IRQ field is updated accordingly.
1 = Charging is allowed to continue, even when the battery temperature pack reaches the &quot;COLD&quot; region. Consequently, the FSM continues charging and no battery temperature error event is generated.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_PROT_ENABLE</name>
	<description>0 = Battery temperature protection disabled
1 = Battery temperature protection enabled.
Charging will be stopped in case Battery temperature reaches &quot;Hot&quot; zone. It will also be disabled when reaching &quot;Cold&quot; zone, provided that CHARGER_CTRL_REG.NTC_LOW_DISABLE is not set. This is handled by the Charger's FSM, which moves directly to the respective error state (TBAT_PROT), also generating an Error IRQ if the respective IRQ mask bit is set (see also CHARGER_ERROR_IRQ_MASK_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_ERROR_RESUME</name>
	<description>0 = FSM will not resume from a Die temperature error. Consequently, its state will be staying to &quot;TDIE_PROT&quot;, for as long as this bit-field is kept low, regardless of the status of the die tempeture comparator. Also, disabling the specific bit-field will reset the Die temperature error debounce counter, when the Charger's FSM is in TDIE_PROT state (so when a Die temperature error has been already detected) and the specific counter will remain frozen to 0 until the TDIE_ERROR_RESUME bit-field is set (see also the TDIE_ERROR_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG).
1 = FSM will resume from a Die temperature error, as soon as the respective analogue compator confirms that die temperature is again below the maximum allowed level.
It is noted that the maximum Die temperature level is programmable via the CHARGER_TEMPSET_PARAM_REG register's respective bit-field (T_DIE_MAX).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_PROT_ENABLE</name>
	<description>0 = Die temperature protection is disabled, thus charging will not be disabled by the Charger's FSM in case of a Die temperature error.
1 = Die temperature protection is enabled, thus the Charger's FSM will move to &quot;TDIE_PROT&quot; state, disabling charging at the same time.
It is noted that the Die temperature error event will be logged in the respective status bit of CHARGER_IRQ_ERROR_STATUS_REG and an IRQ will be generated, if and only if the corresponding mask bit of CHARGER_IRQ_MASK_REG is set. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_RESUME</name>
	<description>0 = Charger's FSM is not enable to resume from a charge timeout error or a Vbat OVP (Over-Voltage Protection) error. Consequently, FSM stays in &quot;ERROR&quot; state.
1 = Charger's FSM will resume from a charge timeout or from an OVP error, thus its state will move from &quot;ERROR&quot; to &quot;DISABLED&quot; state, so that the charge cycle starts-over.
It is noted that in the case of a Vbat OVP error, the FSM will leave &quot;ERROR&quot; state, as soon as the Vbat comparator for the OVP level shows that Vbat is again OK (so lower than the OVP setting).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_BYPASS</name>
	<description>0 = Charger's FSM is active and running, notifying SW upon switching between its states
1 = Charger's FSM is bypassed, so its state stays to &quot;BYPASS&quot;, so SW should take over the monitoring of the battery voltage and control of the charger. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_START</name>
	<description>0 = Charger's FSM is disabled, FSM stays at &quot;DISABLED&quot; state
1 = Charger's FSM is enabled, so FSM's state can move from DISABLED to the actual charge states, starting from &quot;PRE_CHARGE&quot;.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_ENABLE</name>
	<description>0 = Charger's analogue circuitry is powered-down
1 = Charger's analogue circuitry is being powered-up and will be available after a certain settling time (in ms).
As soon as this bit-field is set, the Charger's FSM waits for this settling time, before proceeding into DISABLED state, where it checks the Vbat level, as well as the Die temperature and the Battery temperature states. This is mandatory, before the actual charging begins, so before the FSM moves to PRE_CHARGE state.
It is finally noted that the settling time is configurable via CHARGER_PWR_UP_TIMER_REG, counting with the 1Khz clock.
Note: The Charger clocks must have been enabled first, by setting the CLK_SYS_REG[CLK_CHG_EN] bit-field to '1', in order to let the FSM proceed.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CURRENT_PARAM_REG</name>
	<description>Charger current settings register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000020c6</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I_EOC_DOUBLE_RANGE</name>
	<description>When set, the specific bit-field enables an increase of the (%) range of End-of-Charge current setting. Consequently, the default lower and upper limits of 4% of I_CHARGE (value 0x0 of I_END_OF_CHARGE bit-field) and 16% (value 0x7 of the same bit-field) are increased to 8.8% and 35.2% respectively, as soon as the I_EOC_DOUBLE_RANGE field is set.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_END_OF_CHARGE</name>
	<description>End-of-Charge current setting, ranging from 4%(&quot;000&quot;) to 16% (&quot;111&quot;) of the charge current set, with a step size of 1.5% for the
first 4 settings and 2% for the last 4 settings, as follows (when I_EOC_DOUBLE_RANGE = 0):
000 : 4%
001 : 5.5%
010 : 7%
011 : 8.5%
100 : 10%
101 : 12%
110 : 14%
111 : 16%
When I_EOC_DOUBLE_RANGE = 1, the range is:
000 : 8.8%
001 : 12.1%
010 : 15.4%
011 : 18.7%
100 : 22%
101 : 26.4%
110 : 30.8%
111 : 35.2%</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_PRECHARGE</name>
	<description>This bit-field determines the Pre-Charge current, in mA, ranging from 0.5 to 56mA, according to the following encoding:
0   :  0.5 mA
1   :  1  mA
2   :  1.5mA
3   :  2 mA
4   :  2.5mA
5   :  3  mA
6   :  3.5mA
7   :  4  mA
8   :  4.5mA
9   :  5  mA
10 :  5.5mA
11 :  6  mA
12 :  6.5mA
13 :  7  mA
14 :  7.5mA
15 :  8  mA
16 :  9  mA
17 : 10 mA
18 : 11 mA
19 : 12 mA
20 : 13 mA
21 : 14 mA
22 : 15 mA
23 : 16 mA
24 : 17 mA
25 : 18 mA
26 : 19 mA
27 : 20 mA
28 : 21 mA
29 : 22 mA
30 : 23 mA
31 : 24 mA
32 : 26 mA
33 : 28 mA
34 : 30 mA
35 : 32 mA
36 : 34 mA
37 : 36 mA
38 : 38 mA
39 : 40 mA
40 : 42 mA
41 : 44 mA
42 : 46 mA
43 : 48 mA
44 : 50 mA
45 : 52 mA
46 : 54 mA
47 : 56 mA
48 : 56 mA
49 : 56 mA
50 : 56 mA
51 : 56 mA
52 : 56 mA
53 : 56 mA
54 : 56 mA
55 : 56 mA
56 : 56 mA
57 : 56 mA
58 : 56 mA
59 : 56 mA
60 : 56 mA
61 : 56 mA
62 : 56 mA
63 : 56 mA</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE</name>
	<description>This bit-field determines the charge current range, in mA. The range is from 5mA to 560mA, according to the following encoding:
0   :   5 mA
1   :  10 mA
2   :  15 mA
3   :  20 mA
4   :  25 mA
5   :  30 mA
6   :  35 mA
7   :  40 mA
8   :  45 mA
9   :  50 mA
10 :  55 mA
11 :  60 mA
12 :  65 mA
13 :  70 mA
14 :  75 mA
15 :  80 mA
16 :  90 mA
17 : 100 mA
18 : 110 mA
19 : 120 mA
20 : 130 mA
21 : 140 mA
22 : 150 mA
23 : 160 mA
24 : 170 mA
25 : 180 mA
26 : 190 mA
27 : 200 mA
28 : 210 mA
29 : 220 mA
30 : 230 mA
31 : 240 mA
32 : 260 mA
33 : 280 mA
34 : 300 mA
35 : 320 mA
36 : 340 mA
37 : 360 mA
38 : 380 mA
39 : 400 mA
40 : 420 mA
41 : 440 mA
42 : 460 mA
43 : 480 mA
44 : 500 mA
45 : 520 mA
46 : 540 mA
47 : 560 mA
48 : 560 mA
49 : 560 mA
50 : 560 mA
51 : 560 mA
52 : 560 mA
53 : 560 mA
54 : 560 mA
55 : 560 mA
56 : 560 mA
57 : 560 mA
58 : 560 mA
59 : 560 mA
60 : 560 mA
61 : 560 mA
62 : 560 mA
63 : 560 mA
Note: It has to be noted that the specific values correspond to the normal battery temperature zone. However, the specific register field may be updated by the JEITA FSM (which checks the battery temperature either once or periodically), in order to adapt the Charge current to the new battery temperature zone (see also CHARGER_CTRL_REG.TBAT_MONITOR_MODE field as well). This is valid also for the Pre-Charge current field of this register and provided that JEITA support is enabled in CHARGER_CTRL_REG.
Consequently, in that case the register return the Charge current settings that abide to the JEITA requirements for the battery (either COOL, WARM or NORMAL).</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CV_CHARGE_TIMER_REG</name>
	<description>Maximum CV-charge time limit register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001c20</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CV_CHARGE_TIMER</name>
	<description>Returns the current value of the CV-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the Pre-Charge and the CC-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_CV_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CV_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the CV (Constant Voltage) charging stage. If this is exceeded, a CV charge time-out error will be captured by the Charger's control unit and its FSM will move to the ERROR state. In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_CLR_REG</name>
	<description>Interrupt clear register of Charger Error IRQs</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TDIE_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_MASK_REG</name>
	<description>Mask register of Charger Error IRQs</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of Battery temperature IRQs.The IRQ is generated as soon as the JEITA FSM detects that the battery temperature is either in the &quot;Hot&quot; or in the &quot;Cold&quot; temperature region, by sampling the respective comparators' output.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of Die temperature error IRQs. The IRQ is generated as soon as a Die temperature error is captured, so as soon as the Charger's FSM moves to the TDIE_PROT state. For this to happen, the Die temperature comparator should indicate that Die temperature has exceeded the limit defined in CHARGER_TEMPSET_PARAM_REG.TDIE_MAX.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of VBAT_OVP IRQs. The IRQ is generated as soon as the dedicated Vbat comparator shows that Vbat has exceeded the OVP level and the Charger's FSM has switched to the respective error state (&quot;ERROR&quot;).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the total charge timeout IRQs. The IRQ is generated as soon as the Charger's global charge timer expires, reaching 0.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the CV charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer expires, reaching 0 when the FSM is in the CV_CHARGE state.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the CC charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer, expires, reaching 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the Pre-Charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer expires, reaching 0.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_STATUS_REG</name>
	<description>Status register of Charger Error IRQs</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ</name>
	<description>0 = No Battery temperature error IRQ event is captured, so charging may continue
1 = A Battery temperature error IRQ event has been captured, declaring that the Charger's FSM has moved to the respective error state (TBAT_PROT).
Note : The status bit is updated automatically when the Battery temperature is detected to be either in the HOT or in the COLD zone, regardless of the state of the respective IRQ mask bit.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_ERROR_IRQ</name>
	<description>0 = No Die temperature error IRQ events have been captured, so charging may continue
1 = A Die temperature error IRQ event is captured, declaring that the Charger's FSM has switched to the respective error state (TDIE_PROT) and charging will be automatically stopped.
Note : The status bit is updated automatically when a Die temperature error is detected, thus when the die temperature is found to have exceeded the programmed level, regardless of the state of the respective IRQ mask bit. The same applies to all the rest of the bits of CHARGER_ERROR_IRQ_STATUS_REG.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ</name>
	<description>0 = Vbat has not exceeded the Over-Voltage Protection (OVP) level, so charging may continue
1 = Vbat has exceeded the Over-Voltage level, thus an OVP error event has been captured. The Charger's FSM switches to the respective error state (ERROR) as soon as the OVP event is captured by the digital part of the Charger and charging will be automatically stopped.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = Total charge time counter has not yet reached the maximum charge time (set in CHARGER_TOTAL_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum CV charge time (set in CHARGER_CV_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum CV charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum CC charge time (set in CHARGER_CC_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum CC charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum Pre-charge time (set in CHARGER_PRECHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum Pre-charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_CURRENT_REG</name>
	<description>JEITA-compliant current settings register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00042105</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I_PRECHARGE_TWARM</name>
	<description>Pre-Charge current setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_PRECHARGE_TCOOL</name>
	<description>Pre-Charge current setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TWARM</name>
	<description>Charge current setting for the Warm battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TCOOL</name>
	<description>Charge current setting for the &quot;COOL&quot; battery temperature level. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_CHARGE_REG</name>
	<description>JEITA-compliant Charge voltage settings register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000a68</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>V_CHARGE_TWARM</name>
	<description>Charge voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE_TCOOL</name>
	<description>Charge voltage setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_OVP_REG</name>
	<description>JEITA-compliant OVP settings register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000d76</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>V_OVP_TWARM</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Warm battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_OVP_TCOOL</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Cool battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_PRECHARGE_REG</name>
	<description>JEITA-compliant Pre-Charge voltage settings register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000187</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>V_PRECHARGE_TWARM</name>
	<description>Pre-Charge voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE_TCOOL</name>
	<description>Pre-Charge current setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_REPLENISH_REG</name>
	<description>JEITA-compliant Replenish settings register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000079f</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>V_REPLENISH_TWARM</name>
	<description>Replenish voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH_TCOOL</name>
	<description>Replenish voltage setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_PRE_CHARGE_TIMER_REG</name>
	<description>Maximum pre-charge time limit register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000708</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PRE_CHARGE_TIMER</name>
	<description>Returns the current value of the Pre-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the CC-Charge and the CV-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_PRE_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_PRE_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the Pre-Charge stage. If this is exceeded, a Pre-Charge time-out error will be captured by the Charger's control unit and its FSM will move to the respective state (ERROR). In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_PWR_UP_TIMER_REG</name>
	<description>Charger power-up (settling) timer</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>CHARGER_PWR_UP_TIMER</name>
	<description>Returns the current value of the charger's power-up timer, running with the 1Khz clock.
Note: The specific timer is reset to the value programmed to CHARGER_PWR_UP_SETTLING bit-field, when the Charger's analogue circuitry has been enabled, after being disabled initially. By setting CHARGER_CTRL_REG[CHARGER_ENABLE] to '0', the analogue part is disabled and in order to be properly enable, SW has to wait for 1ms (one 1Khz clock period) time. The latter is is needed to ensure that the power-up timer's control signals in the Charger's digital part will be cleared when the analogue part is again enabled, so that a proper new start-up of the Charger's FSM is possible.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_PWR_UP_SETTLING</name>
	<description>This bit-field determines the charger's power-up (settling) time, required for the analogue circuitry of the charger. As soon as the charger is powered-on by setting the CHARGER_ENABLE bit-field of CHARGER_CTRL_REG, the charger's FSM loads a dedicated timer with this value and waits for this timer to expire, before proceeding to the next states.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_CLR_REG</name>
	<description>Interrupt clear register of Charger FSM IRQs</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[11:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_TO_CC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ_CLR</name>
	<description>Writing a 1 will reset the Battery temperature status update IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_TO_EOC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_EOC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_CV_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_MASK_REG</name>
	<description>Mask register of Charger FSM IRQs</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to PRE_CHARGE state.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to PRE_CHARGE state.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_TO_CC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to CC_CHARGE state.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ_EN</name>
	<description>When set, this bit-field enables the generation of the Charger's state IRQ as soon as the battery temperature status is refreched by the Charger's Battery temperature monitor (JEITA) FSM. As soon as the specific FSM checks the current battery temperature level, it notifies the main Charger FSM that it has run and that the Battery temperature pack state is checked (and potentially refreshed with a new status).</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's state IRQ generation as soon as the Charger's FSM switches from the Battery temperature protection state (TBAT_PROT) to PRE_CHARGE, resuming charging.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's state IRQ generation as soon as the Charger's FSM switches from the Die temperature protection state (TDIE_PROT) to PRE_CHARGE, resuming charging.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's State IRQ generation as soon as the Charger's FSM switches from END_OF_CHARGE again to PRE_CHARGE state. This happens when the Vbat voltage level is detected to be below the Replenish level set.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_TO_EOC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to END_OF_CHARGE state.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_EOC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to END_OF_CHARGE state.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_CV_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to CV_CHARGE state.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from PRE_CHARGE to CC_CHARGE state..</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from DISABLED to PRE_CHARGE state.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_STATUS_REG</name>
	<description>Status register of Charger FSM IRQs</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to PRE_CHARGE state</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to PRE_CHARGE state</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_TO_CC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to CC_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to CC_CHARGE state</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ</name>
	<description>0 = No battery temperature status update event has been captured
1 = Battery temperature pack's status has been checked and refreshed by the Charger's Battery temperature monitor FSM. Thus, the new status of the battery temperature should be checked by SW.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from TBAT_PROT to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from TBAT_PROT to PRE_CHARGE state, resuming charging after having recovered from a battery temperature error.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from TDIE_PROT to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from TDIE_PROT to PRE_CHARGE state, resuming charging after having recovered from a Die temperature error.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from END_OF_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from END_OF_CHARGE to PRE_CHARGE state</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_TO_EOC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to END_OF_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to END_OF_CHARGE state</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_EOC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to END_OF_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to END_OF_CHARGE state</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_CV_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to CV_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to CV_CHARGE state</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from PRE_CHARGE to CC_CHARGE state has been captured
1 = Charger's FSM has switched from PRE_CHARGE to CC_CHARGE state</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from DISABLED to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from DISABLED to PRE_CHARGE state</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATUS_REG</name>
	<description>Charger main status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>OVP_EVENTS_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the consecutive number of times Vbat has exceeded the programmed Over-Voltage Protection (OVP) level. It is used to determine when the Charger's FSM will exit any of the charging states (PRE/CC/CV_CHARGE) and will switch to the ERROR state due to an OVP error. This will happen as soon as the respective counter of OVP events reaches or exceeds a fixed number (4), similar to the approach adopted in the End-of-Charge and Die Temperature debouncing mechanisms.
The specific counter increases only while the Charger's FSM is in any of the three charging,states, the Vbat OVP interval check timer has reached the threshold set and when Vbat OVP comparator's output is asserted.
Note 1 : By default, as soon as the counter reaches 4, the FSM will switch to the ERROR state and the counter will reset again. Thus, in that case the specific counter ranges from 0 to 4 and vice-versa. However, if the monitoring of Vbat OVP comparator's state is less frequent than 5 (4+1) times the CHARGER_OVP_COMP_TIMER_REG[OVP_INTERVAL_CHECK_THRES] and Vbat has exceeded the OVP voltage level based on the comparator's output signal, then this counter will exceed 4 and may overflow.
This will not harm, however, the detection of the OVP event, as it only increases the number of OVP event occurrences by the debounce timer, until the OVP comparator timer's settling time has expired. Thus, the Charger FSM will again switch to ERROR when the counter has reached or exceeded 4 (bit [2] of OVP_EVENTS_DEBOUNCE_CNT is set) and the OVP comparator's timer has expired.
Note 2: See also the OVP_INTERVAL_CHECK_TIMER, OVP_INTERVAL_CHECK_THRES of CHARGER_OVP_COMP_TIMER_REG, for the debouncing mechanism of the Vbat OVP comparator's output.</description>
	<bitRange>[29:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_EVENTS_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the number of times the End-of-Charge signal has been consecutively found to be high. It is used to determine when the Charger's FSM will switch from CV_CHARGE to END_OF_CHARGE state, implementing a debounce mechanism on End-of-Charge signal, coming from the analogue circuitry of the Charger towards the FSM.
The specific counter, running with the Charger's 1Mhz clock:
  - Increases after detecting that the End-of-Charge signal is high when the respective interval for the End-of-Charge check expires. This actually happens after having detected a positive edge on End-of-Charge signal, since only after that is it possible for the interval timer to start ticking.
  - Resets to zero when End-of-Charge is seen low when the interval timer has expired or when an End-of-Charge negative edge is seen before the timer's expiration, starting-over.
  - Does not count if End-of-Charge signal is seen high and either the CV_MODE signal (also driven by the analogue circutry) or the End-of-Charge signal of the previous clock cycle is seen low.
  - Is reset when the Charger's FSM is not in either the CC_CHARGE or the CV_CHARGE state or after having reached &quot;100&quot;(4). This is the threshold after which the End-of-Charge signal is considered stable by the Charger's FSM, to switch to the END_OF_CHARGE state. Thus, in practice, the specific counter (and bit-field) ranges between 0 and 4.
Note: See also the EOC_INTERVAL_CHECK_TIMER/THRES bit-fields of CHARGER_CTRL_REG.</description>
	<bitRange>[26:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_ERROR_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the consecutive number of times the Die temperature is seen either above (for the case of an error) or below (for the case of recovering from an error) the set Die temperature level.This is performed by a counter, which is increased:
- Each time the Die temperature comparator shows that Die temperature exceeds the set level, and while charging is active, provided that Die temperature protection is enabled. If, however, the CHARGER_CTRL_REG.TDIE_PROT_ENABLE bit-field is not set, the counter is reset and stays frozen to zero.
- Each time the Die temperature comparator shows that Die temperature is again below the set level, and while the FSM is in the Die temperature protection error state (TDIE_PROT) and the TDIE_ERROR_RESUME bit-field of CHARGER_CTRL_REG is set. If the specific bit-field is not set, the debounce counter is reset to 0 and it is kept frozen until the FSM is again enabled to resume from Die temperature errors.
If the Die temperature comparator of the Charger's analogue circuitry shows that temperature has exceeded the programmed level for four consecutive times and charging is active, the Charger's FSM considers this as a Die temperature error and moves to the TDIE_PROT state, resetting the timer at the same time and of course halting charging.
To recover from this state and resume charging, the FSM needs to see that Die temperature is below the programmed level for four consecutive times, again, provided that the TDIE_ERROR_RESUME bit-field of CHARGER_CTRL_REG is set. As soon as this happens, the error counter is again reset and the Charger's FSM resumes, by moving to PRE_CHARGE state. Consequently, the counter's value always ranges from 0 to 4.
Note: When the Charger's FSM is in BYPASSED state, then this bit-field is reset and kept frozen to zero. Consequently, the number of times Die temperature has exceeded the pre-programmed threshold should be determined by SW.</description>
	<bitRange>[23:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_JEITA_STATE</name>
	<description>Returns the state of the Charger's JEITA FSM. This FSM is used to update the state of the battery temperature pack, depending on the value programmed in CHARGER_CTRL_REG.TBAT_MONITOR_MODE bit-field. The encoding of the states is as follows:
0x0 = CHECK_IDLE
0x1 = CHECK_THOT
0x2 = CHECK_TCOLD
0x3 = CHECK_TWARM
0x4 = CHECK_TCOOL
0x5 = CHECK_TNORMAL
0x6 = UPDATE_TBAT
The FSM initially is in CHECK_IDLE state and starts checking the battery's temperature by visiting the states that check for the respective temperature area (Hot, Cold, Warm, Cool, Normal), in this order.
If the battery temperature is found to be in one of the aforementioned zones, it directly moves to UPDATE_TBAT state, to update the battery temperature's state and notify the main FSM of the Charger about the battery temperature status, before returning to the CHECK_IDLE state. A Charger State IRQ will also be generated upon refreshing the battery temperature status (see also the description of CHARGER_STATE_IRQ_MASK_REG register).</description>
	<bitRange>[20:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_STATE</name>
	<description>Indicating the state of the Charger's main FSM, based on the following encoding:
0x0 = POWER_UP (Charger's power-up not yet set)
0x1 = INIT (Charger is being power-up, FSM waiting for the analogue to settle)
0x2 = DISABLED (Charger powered-up but charging not yet started)
0x3 = PRE_CHARGE (Pre-Charge state)
0x4 = CC_CHARGE (Constant Current state)
0x5 = CV_CHARGE (Constant Voltage state)
0x6 = END_OF_CHARGE (End-of-Charge state)
0x7 = TDIE_PROT (Die temperature protection state, visited when Die temperature limit is exceeded)
0x8 = TBAT_PROT (Battery temperature protection state, visited when Battery temperature is either COLD or HOT)
0x9 = BYPASSED (Bypassed state, visited only when the FSM is bypassed and SW takes over control)
0xA = ERROR (Error state, visited when a charge time-out occurs or in the case of Vbat exceeding over-voltage level)</description>
	<bitRange>[17:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_STATUS</name>
	<description>Battery pack temperature status, according to the following (&quot;1-Hot&quot;-like) encoding:
0x1   : Battery temperature in COLD zone (default)
0x2   : Battery temperature in COOL zone
0x4   : Battery temperature in NORMAL zone (above COOL and below WARM zones)
0x8   : Battery temperature in WARM zone
0x10 : Battery temperature in HOT zone
It is noted that, according to the JEITA standard (supported if the JEITA_SUPPORT_DISABLED bit-field of CHARGER_CTRL_REG is not set), if the battery pack temperature is in the &quot;HOT&quot; zone, charging will always be stopped. The same will happen also for the case of the COLD zone, unless the &quot;NTC_LOW_DISABLE&quot; bit-field of CHARGER_CTRL_REG is set. In that case, charging will be continued.
It is finally noted that only the aforementioned values are available for this bit-field, since it is 1-Hot encoding based. Not more than 1 bit can be high at the same time, since this would mean that battery temperature is at two different temperature zones concurrently.</description>
	<bitRange>[13:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAIN_TBAT_COMP_OUT</name>
	<description>Returns the status of the main battery temperature comparator. This comparator by default checks if the battery temperature is in the Cold zone. However, if JEITA support is enabled and battery temperature is found to not be in either the Hot or the Cold zone, the same comparator is used to check for the Warm and Cool zones, as JEITA suggests.
The specific bit-field is suggested to be used in bypass mode and when the JEITA support is disabled (so when the battery temperature is checked agains the Hot and the Cold zones). In that case, the comparator checks the battery temperature agains the Cold level and its status can be as follows:
0 = Battery temperature pack is found to be below the Cold level, so in the non-allowed Cold temperature zone. Thus, charging will be disabled, provided that the NTC_LOW_DISABLE bit-field of CHARGER_CTRL_REG is not set.
1 = Battery temperature pack is found to be above the non-allowed Cold temperature zone. Thus, charging will be continued, provided that battery temperature will not be in the Hot zone as well.
When the Charger's main FSM is active and JEITA is enabled, the Charger's digital block takes over and controls the respective comparator's output.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_HOT_COMP_OUT</name>
	<description>Returns the status of the battery temperature comparator dedicated to the Hot temperature zone.
0 = Battery temperature pack is found to be below the Hot zone
1 = Battery temperature pack is found to be in the non-allowed Hot temperature zone. Thus, charging will be disabled, provided that battery temperature protection is enabled.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_COMP_OUT</name>
	<description>0 = Die temperature is found to be below the programmed level, set in CHARGER_TEMPSET_PARAM_REG.TDIE_SET level (normal operation)
1 = Die temperature is found to be above the set level.
Charging will be disabled if Die temperature protection is enabled and the Die temperature is found to be above the set level four consecutive times (see also TDIE_ERROR_DEBOUNCE_CNT bit-field). In that case, the Charger's FSM will also move the respective error state (TDIE_PROT) and an IRQ may be generated, if the respective mask bit of CHARGER_ERROR_IRQ_MASK_REG is set.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_COMP_OUT</name>
	<description>0 = Vbat has not exceeded the Over-Voltage Protection (OVP) voltage limit, according to the respective analogue comparator's output.
1 = Vbat is found to have exceeded the OVP voltage setting, thus charging should be disabled.
The OVP voltage settings are defined in CHARGER_VOLTAGE_PARAM_REG.V_OVP (for the Normal battery temperature zone), as well as in CHARGER_JEITA_V_OVP_REG (for Cool and Warm temperature zones, to comply with JEITA). </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAIN_VBAT_COMP_OUT</name>
	<description>This bit-field reflects the status of the main Vbat comparator residing in the analogue circuitry of the Charger.
This comparator is used to check Vbat against either the Pre-Charge or the Replenish voltage level, depending on what is driven by the Charger's digital block.
Thus, when the FSM is active, the comparator gets as reference the Replenish setting as soon as the FSM has reached the END_OF_CHARGE state. Otherwise,the Pre-Charge voltage setting is driven, including the Bypass mode.
According to the above, the encoding is as follows for the case the comparator compares Vbat against the Pre-Charge level:
0 = Vbat has not exceeded the set Pre-Charge voltage level.
1 = Vbat has reached or exceeded the set Pre-Charge voltage level.
For the case the comparator compares agains the Replenish level (when the FSM has reached the END_OF_CHARGE state, so when the charging has been completed), the encoding is as follows:
0 = Vbat has dropped below the set Replenish level, so charging will re-start and the FSM will move to the PRE_CHARGE state.
1 = Vbat is still greater or equal to the set Replenish level, thus charging remains in hold and the FSM in END_OF_CHARGE state.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>END_OF_CHARGE</name>
	<description>0 = Actual charge current is above the current level programmed in I_END_OF_CHARGE field of CHARGER_CURRENT_PARAM_REG (or charger is off)
1 = Actual charge current is below the current level programmed in I_END_OF_CHARGE bit-field of CHARGER_CURRENT_PARAM_REG.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_CV_MODE</name>
	<description>0 = Charger's voltage loop not in regulation (or Charger is off)
1 = Charger's Constant Voltage (CV) mode active, voltage loop in regulation</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_CC_MODE</name>
	<description>0 = Charger's Current loop not in regulation (or Charger is off)
1 = Charger's Constant Current (CC) mode active, current loop in regulation</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_IS_POWERED_UP</name>
	<description>0 = Charger is either off or it is being powered-on but the analogue ciruitry is not yet settled. The charger's main FSM is either in POWER_UP or INIT states.
1 = Charger is powered-up, so its analogue ciruitry should now be settled. The Charger's FSM has left both power-up states (POWER_UP, INIT), so charging can start.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_TBAT_COMP_TIMER_REG</name>
	<description>Battery temperature (main) comparator timer</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TBAT_COMP_TIMER</name>
	<description>Returns the main battery temperature comparator's timer, used for the latching of the comparator's output. The output of the comparator is used by the JEITA FSM, to determine the current battery temperature pack's status.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_COMP_SETTLING</name>
	<description>Settling time (specified in us) for the main battery temperature comparator, checking for the &quot;COOL&quot;, &quot;COLD&quot; and &quot;WARM&quot; levels. The charger's digital block uses a dedicated timer to sample the specific comparator's output. The comparator's output is latched as soon as the timer expires, reaching 0. Then, the timer is reloaded with the settling time value and starts-over, down-counting to 0.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TBAT_MON_TIMER_REG</name>
	<description>Battery temperature monitor interval timer</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TBAT_MON_TIMER</name>
	<description>This is the battery temperature monitoring timer, counting with the Charger's 1KHz clock. If the battery monitor mode is accordingly set in the TBAT_MONITOR_MODE bit-field of CHARGER_CTRL_REG (so either to 0x1 or 0x2), this timer is initially loaded with the value set in TBAT_MON_INTERVAL bit-field in the subsequent 1khz cycles starts down-counting to 0. As soon as the specific timer expires,the JEITA FSM starts-over again, to refresh the battery temperature status.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_MON_INTERVAL</name>
	<description>Timing interval (in ms) for the Battery temperature monitoring. This interval determines how often the JEITA FSM will be checking and potentially refreshing the Battery temperature status, by selecting accordingly the proper level (Hot, Cold, Warm, Cool or Normal), based on the feedback of the two battery temperature comparators being present in the Charger's analogue circuitry (one for the Hot level and one for Cold, Cool and Warm, to support JEITA).
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TDIE_COMP_TIMER_REG</name>
	<description>Die temperature comparator timer register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TDIE_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the Die temperature comparator's output must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from TDIE_COMP_SETTLING) the comparator's output is latched by the Charger's digital block and used by the main FSM. After expiring, the timer starts-over again, down-counting, to enable the continuous monitoring of Die temperature by the digital.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over, sampling the status of the TDIE_PROT_COMP_OUT bit-field of CHARGER_STATUS_REG to determine if the Die temperature limit has been exceeded.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Die temperature comparator. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TEMPSET_PARAM_REG</name>
	<description>Charger battery temperature settings register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x03ded50a</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>TDIE_MAX</name>
	<description>This bit-field determines the maximum Die temperature level limit, ranging from 0C to 130C, according to the following encoding:
000: 0 C (mainly for test purposes)
001: 50 C
010: 80 C
011: 90 C
100: 100 C
101: 110 C
110: 120 C
111: 130 C</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_HOT</name>
	<description>This bit-field determines the battery temperature above which the charge current is zero, defining the &quot;Hot&quot; battery temperature zone. It ranges from minus 10C to 53C. The range is the same with the one defined in detail in TBAT_COLD bit-field.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_WARM</name>
	<description>This bit-field determines the battery temperature above which the charge current is reduced, defining the &quot;Warm&quot; temperature zone. It ranges from minus 10C to 53C. The range is the same with the one defined in detail in TBAT_COLD bit-field.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_COOL</name>
	<description>This bit-field determines the battery temperature below which the charge current is reduced, defining the &quot;Cool&quot; temperature zone. It ranges from minus 10C to 53C and the range is the same with the one defined in TBAT_COLD bit-field.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_COLD</name>
	<description>This bit-field determines the battery temperature below which the charge current is zero, defining the &quot;Cold&quot; temperature zone. It ranges from minus 10C to 53C, according to the following encoding:
0   :  -10 C
1   :   -9 C
2   :   -8 C
3   :   -7 C
4   :   -6 C
5   :   -5 C
6   :   -4 C
7   :   -3 C
8   :   -2 C
9   :   -1 C
10 :    0 C
11 :    1 C
12 :    2 C
13 :    3 C
14 :    4 C
15 :    5 C
16 :    6 C
17 :    7 C
18 :    8 C
19 :    9 C
20 :   10 C
21 :   11 C
22 :   12 C
23 :   13 C
24 :   14 C
25 :   15 C
26 :   16 C
27 :   17 C
28 :   18 C
29 :   19 C
30 :   20 C
31 :   21 C
32 :   22 C
33 :   23 C
34 :   24 C
35 :   25 C
36 :   26 C
37 :   27 C
38 :   28 C
39 :   29 C
40 :   30 C
41 :   31 C
42 :   32 C
43 :   33 C
44 :   34 C
45 :   35 C
46 :   36 C
47 :   37 C
48 :   38 C
49 :   39 C
50 :   40 C
51 :   41 C
52 :   42 C
53 :   43 C
54 :   44 C
55 :   45 C
56 :   46 C
57 :   47 C
58 :   48 C
59 :   49 C
60 :   50 C
61 :   51 C
62 :   52 C
63 :   53 C</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TEST_CTRL_REG</name>
	<description>Charger test control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001e88</resetValue>
	<resetMask>0x0001ffff</resetMask>
	
</register><register>
	<name>CHARGER_THOT_COMP_TIMER_REG</name>
	<description>Battery temperature comparator timer for &quot;Hot&quot; zone</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>THOT_COMP_TIMER</name>
	<description>Returns the battery temperature comparator's timer dedicated for the &quot;Hot&quot; level.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>THOT_COMP_SETTLING</name>
	<description>Charger's battery temperature comparator settling time (specified in us), specifically for the Hot temperature zone. The charger's digital block uses a dedicated timer to sample the specific comparator's output. The comparator's output is latched as soon as the timer expires, reaching 0. Then, the timer is reloaded with the settling time value and starts-over again
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TOTAL_CHARGE_TIMER_REG</name>
	<description>Maximum total charge time limit register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00003f48</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TOTAL_CHARGE_TIMER</name>
	<description>Returns the current value of the overall charge timeout counter, running at a 1Hz clock. This timer has been set to 16 bits, so that it can count up to 10.5 hours, and ranges from 0 to MAX_TOTAL_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_TOTAL_CHARGE_TIME</name>
	<description>This bit-field determines the maximum overall charging time allowed (measured in ticks of the 1Hz clock). If this is exceeded, a total charge time-out error will be captured by the Charger's controller and its FSM will move to the ERROR state. An IRQ will be also generated if the respective IRQ mask bit of CHARGER_ERROR_IRQ_MASK_REG is already set. In order to to exit this state, the &quot;CHARGER_RESUME&quot; bit-field of CHARGER_CTRL_REG must be set, to enable the Charger's FSM switch from ERROR to DISABLED state and start-over.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VBAT_COMP_TIMER_REG</name>
	<description>Main Vbat comparator timer register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>VBAT_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the output of the Vbat comparator (checking Vbat vs Pre_Charge and Replenish levels) must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from the value set in VBAT_COMP_SETTLING), the comparator's output is latched by the Charger's digital block and used by the FSM.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over. In this mode, the specific comparator checks the level of Vbat against the Pre-Charge level. Hence, SW can periodically sample the status of this comparator by reading the MAIN_VBAT_COMP_OUT bit-field of CHARGER_STATUS_REG, to determine if Vbat has exceeded the Pre-Charge level or not.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Vbat comparator checking Vbat vs the programmed Pre-Charge and Replenish levels. The settings (voltage levels) of the comparator are controlled by the digital block of the Charger and they are driven based on the state of the main FSM (PRE_CHARGE, END_OF_CHARGE).</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VOLTAGE_PARAM_REG</name>
	<description>Charger voltage settings register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00ca122b</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_OVP</name>
	<description>This bit-field determines the VBAT Over-voltage protection limit. This Over-voltage protection level is used by the Charger's analogue circuitry and specifically by a dedicated comparator, the output of which is sampled by the digital block of the Charger. As soon as VBAT is detected to have reached or exceeded this level, the Charger's FSM moves to ERROR state, interrupting charging. If the respective Error IRQ mask bit is set, an Error IRQ pulse will be also generated.
Regarding the actual range of supported values for this bit-field, see the the description of V_CHARGE bit-field of this register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH</name>
	<description>This bit-field determines the absolute value (in V) of the Replenish voltage threshold. As soon as charging has been completed and the Charger's FSM has reached the END_OF_CHARGE state, the respective analogue comparator of the Charger compares VBAT with the Replenish level. If VBAT is found to have dropped below this level, charging should start-over again and in that case, the FSM moves again to the PRE_CHARGE state.
Regarding the supported Replenish voltage levels, see the description of V_CHARGE bit-field.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE</name>
	<description>This bit-field determines the voltage level at which the battery is considered as Pre-charged and therefore the Charger's FSM should move to the CC_CHARGE state, entering the Constant Current charging phase.
Regarding the supported Pre-Charge voltage levels, see also the description of V_CHARGE bit-field of this register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE</name>
	<description>This bit-field determines the charge voltage levels supported. The supported levels are determined according to the following encoding:
0   : 2.80V
1   : 2.85V
2   : 2.90V
3   : 2.95V
4   : 3.00V
5   : 3.05V
6   : 3.10V
7   : 3.15V
8   : 3.20V
9   : 3.25V
10 : 3.30V
11 : 3.35V
12 : 3.40V
13 : 3.45V
14 : 3.50V
15 : 3.55V
16 : 3.60V
17 : 3.65V
18 : 3.70V
19 : 3.75V
20 : 3.80V
21 : 3.82V
22 : 3.84V
23 : 3.86V
24 : 3.88V
25 : 3.90V
26 : 3.92V
27 : 3.94V
28 : 3.96V
29 : 3.98V
30 : 4.00V
31 : 4.02V
32 : 4.04V
33 : 4.06V
34 : 4.08V
35 : 4.10V
36 : 4.12V
37 : 4.14V
38 : 4.16V
39 : 4.18V
40 : 4.20V
41 : 4.22V
42 : 4.24V
43 : 4.26V
44 : 4.28V
45 : 4.30V
46 : 4.32V
47 : 4.34V
48 : 4.36V
49 : 4.38V
50 : 4.40V
51 : 4.42V
52 : 4.44V
53 : 4.46V
54 : 4.48V
55 : 4.50V
56 : 4.52V
57 : 4.54V
58 : 4.56V
59 : 4.58V
60 : 4.60V
61 : 4.70V
62 : 4.80V
63 : 4.90V*
It has to be noted that the specific values correspond to the normal battery temperature zone. However, the specific register field may be updated by the JEITA FSM (which checks the battery temperature either once or periodically), in order to adapt the charge voltage to the battery temperature zone (see also CHARGER_CTRL_REG.TBAT_MONITOR_MODE field as well). This is valid also for the other three fields of the current register. Consequently, in that case the register returns the Charge voltage settings that abide to the JEITA requirements for the battery (either COOL, WARM or NORMAL).
Note: Option &quot;63&quot; (4.90V) is not supported for V_CHARGE, V_PRECHARGE and V_REPLENISH bit-fields (and respective levels). It should be used only in the V_OVP bit-field, as the (maximum) Over-voltage protection level.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VOVP_COMP_TIMER_REG</name>
	<description>Vbat OVP comparator timer register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000fc63</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVP_INTERVAL_CHECK_TIMER</name>
	<description>The specific bit-field determines the current state of the timer used to periodically check the output of the Over-Voltage Protection comparator's output signal, as soon as the Charger's FSM reaches any of the charging states (PRE/CC/CV_CHARGE).
When this happens, the timer starts ticking with the 1Mhz clock, ranging from 0 up to the programmed interval threshold (see also OVP_INTERVAL_CHECK_THRES field). As soon as this timer reaches the programmed threshold value, the Vbat OVP comparator's output is evaluated, increasing or not the counter keeping the consecutive OVP events. It is noted that out of the charging states, the specific timer is kept frozen to zero, not counting.
Note : See also the OVP_OCCURRENCES_CNT bit-field of CHARGER_STATUS_REG for the consecutive OVP events counter.</description>
	<bitRange>[31:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the Vbat Over-Voltage protection (OVP) comparator's output must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from VBAT_OVP_COMP_SETTLING), the comparator's output is latched by the Charger's digital block and used by the main FSM.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over, sampling the status of the VBAT_OVP_COMP_OUT bit-field of CHARGER_STATUS_REG to determine if the Vbat has exceeded the OVP limit.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OVP_INTERVAL_CHECK_THRES</name>
	<description>This bit-field determines the periodic interval of checking the dedicated Vbat OVP comparator's output, when the Charger's FSM is in any of the charging states (PRE/CC/CV_CHARGE). The implementation is based on a dedicated timer, counting from zero up to the value programmed into this bit-field (see also OVP_INTERVAL_CHECK_TIMER field's description) and only when the FSM is in any of the three charging states. Out of these states, the timer is kept frozen to zero.
As soon as this timer reaches the programmed threshold, the Vbat OVP comparator's output is sampled and depending on its level, (high or low), another counter, keeping the number of consecutive OVP events, is increased or not. The programmed threshold value should always be non-zero.
Note: See also the OVP_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG, for the consecutive OVP events counter.</description>
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_OVP_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Vbat comparator checking Vbat vs the programmed Over-Voltage level.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_ID1</name>
	<description>First character of device type &quot;2522&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000035</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_ID2</name>
	<description>Second character of device type &quot;2522&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_ID3</name>
	<description>Third character of device type &quot;2522&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID4_REG</name>
	<description>Chip identification register 4.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_ID4</name>
	<description>Fourth character of device type &quot;2522&quot; in ASCII.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	<description>Chip revision register.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_REVISION</name>
	<description>Chip version, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	<description>Software compatibility register.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_SWC</name>
	<description>SoftWare Compatibility code.
Integer (default = 0) which is incremented if a silicon change has impact on the CPU Firmware.
Can be used by software developers to write silicon revision dependent code. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST1_REG</name>
	<description>Chip test register 1.</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_LAYOUT_REVISION</name>
	<description>Chip layout revision, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST2_REG</name>
	<description>Chip test register 2.</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CHIP_METAL_OPTION</name>
	<description>Chip metal option value.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_COM</name>
	<version>1.0</version>
	<description>CRG_COM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020900</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_COM_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00030000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>LCD_EXT_CLK_SEL</name>
	<description>Select LCD external clock speed.
0x0: 1 Hz
0x1: 62.5 Hz
0x2: 125 Hz
0x3: off</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_DIV</name>
	<description>Division factor for SNC, w.r.t. pclk setting
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_COM_REG</name>
	<description>Peripheral divider register RESET register. Reads back 0x0000</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>LCD_EXT_CLK_SEL</name>
	<description>Select LCD external clock speed.
0x0: 1 Hz
0x1: 62.5 Hz
0x2: 125 Hz
0x3: off</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_DIV</name>
	<description>Division factor for SNC, w.r.t. pclk setting
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_CLK_COM_REG</name>
	<description>Peripheral divider register SET register. Reads back 0x0000</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>LCD_EXT_CLK_SEL</name>
	<description>Select LCD external clock speed.
0x0: 1 Hz
0x1: 62.5 Hz
0x2: 125 Hz
0x3: off</description>
	<bitRange>[17:16]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SNC_DIV</name>
	<description>Division factor for SNC, w.r.t. pclk setting
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<bitRange>[15:14]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_PER</name>
	<version>1.0</version>
	<description>CRG_PER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030c00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>80</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>MC_TRIG_DIV</name>
	<description>Trigger divider for the motor controller
0x0: divide LP_CLK by 1
0x1: divide LP_CLK by 2
...
0x1F: divide LP_CLK by 32</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MC_CLK_DIV</name>
	<description>Clock divider for the motor controller slot. The slots are clocked on (a PCLK synchronized version of) the LP clock, and can be further divided by this divider:
0x0: divide LP clock by 1
0x1: divide LP clock by 2
...
0x1F: divide LP clock by 32</description>
	<bitRange>[7:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MC_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/ 2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM_DIV_REG</name>
	<description>PCM divider and enables</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>PCM_SRC_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PCM_EN</name>
	<description>Enable for the internally generated PCM clock
The PCM_DIV must be set before or together with CLK_PCM_EN.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_DIV</name>
	<description>PCM clock divider. Minimum value is 0x2.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM_FDIV_REG</name>
	<description>PCM fractional division register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PCM_FDIV</name>
	<description>These bits define the fractional division part of the PCM clock. The left most '1' defines the denominator, the number of '1' bits define the numerator. E.g.
0x0110 means 2/9, with a distribution of 1.0001.0000
0xfeee means 13/16, with a distribution of 1111.1110.1110.1110
</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDM_DIV_REG</name>
	<description>PDM divider and enables</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PDM_MASTER_MODE</name>
	<description>Master mode selection
0: slave mode
1: master mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PDM_EN</name>
	<description>Enable for the internally generated PDM clock
The PDM_DIV must be set before or together with CLK_PDM_EN.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PDM_DIV</name>
	<description>PDM clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_PER_REG</name>
	<description>Peripheral divider register RESET register, reads 0x0000</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>MC_TRIG_DIV</name>
	<description>Trigger divider for the motor controller
0x0: divide LP_CLK by 1
0x1: divide LP_CLK by 2
...
0x1F: divide LP_CLK by 32</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MC_CLK_DIV</name>
	<description>Clock divider for the motor controller slot. The slots are clocked on (a PCLK synchronized version of) the LP clock, and can be further divided by this divider:
0x0: divide LP clock by 1
0x1: divide LP clock by 2
...
0x1F: divide LP clock by 32</description>
	<bitRange>[7:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MC_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/ 2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_CLK_PER_REG</name>
	<description>Peripheral divider register SET register, reads 0x0000</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>MC_TRIG_DIV</name>
	<description>Trigger divider for the motor controller
0x0: divide LP_CLK by 1
0x1: divide LP_CLK by 2
...
0x1F: divide LP_CLK by 32</description>
	<bitRange>[12:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>MC_CLK_DIV</name>
	<description>Clock divider for the motor controller slot. The slots are clocked on (a PCLK synchronized version of) the LP clock, and can be further divided by this divider:
0x0: divide LP clock by 1
0x1: divide LP clock by 2
...
0x1F: divide LP clock by 32</description>
	<bitRange>[7:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>MC_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>LRA_CLK_EN</name>
	<description>Enables the clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/ 2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>SRC_DIV_REG</name>
	<description>SRC divider and enables</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>CLK_SRC_EN</name>
	<description>Enable for the internally generated SRC clock
The SRC_DIV must be set before or together with CLK_SRC_EN.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DIV</name>
	<description>SRC clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_SYS</name>
	<version>1.0</version>
	<description>CRG_SYS registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BATCHECK_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BATCHECK_LOAD_ENABLE</name>
	<description>Enable a current load on the battery.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BATCHECK_ILOAD</name>
	<description>Set the current load to (ILOAD+1) mA.</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BATCHECK_TRIM</name>
	<description>Trim the current load with steps of 2.7% from -19.1% to +19.1%.
0: +0.0% , 8: -0%
1: +2.7% , 9: -2.7%
2: +5.5% , 10: -5.5%
3: +8.2% , 11: -8.2%
4: +10.9% , 12: -10.9%
5: +13.6% , 13: -13.6%
6: +16.4% , 14: -16.4%
7: +19.1% , 15: -19.1%</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SYS_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CLK_CHG_EN</name>
	<description>Enables the clocks for the charger FSM block</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_RESET_REQ</name>
	<description>Generates a SW reset towards the LCD controller.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>252</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Analog Signals Status Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>COMP_VBUS_HIGH</name>
	<description>COMP_VBUS_HIGH = 1 -&gt; VBUS &gt; 4V</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBUS_LOW</name>
	<description>COMP_VBUS_LOW = 1 -&gt; VBUS &gt; 3.4V</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_HIGH</name>
	<description>COMP_VBAT_HIGH =1 -&gt; VBAT &gt; 2.5V</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_LOW</name>
	<description>COMP_VBAT_LOW = 1 -&gt; VBAT &gt; 1.667V</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VDD_OK</name>
	<description>COMP_VDD_OK = 1 -&gt; VDD &gt; 1.125V</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBUS_AVAILABLE</name>
	<description>High when VBUS &gt; ( VBAT + 150 mV). Hysteresis is approx. 40 mV</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BANDGAP_OK</name>
	<description>When high bandgap is active</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_3V0_VBAT_OK</name>
	<description>When high LDO_VBAT is active</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_3V0_VBUS_OK</name>
	<description>When high LDO_VBUS is active</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_1V8P_OK</name>
	<description>When high LDO_IO2 is active</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_1V8_OK</name>
	<description>When high LDO_IO is active</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_RADIO_OK</name>
	<description>When high LDO_RADIO is active</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_CORE_OK</name>
	<description>When high LDO_CORE(LDO1V2) is active</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VDD_HIGH_OK</name>
	<description>When high the ADC LDO is active. This LDO also supplies part of the LRA</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VIN_NOK</name>
	<description>General output of the BOD to indicate that one of the monitored inputs is below the trigger-level.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>bandgap trimming</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>BANDGAP_ENABLE_CLAMP</name>
	<description>Enables a supply clamp inside the bandgap that improves PSRR. Should be enabled by software after cold boot.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_ITRIM</name>
	<description>Current trimming for bias </description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYSRAM_LPMX</name>
	<description>RAM Transparent Light Sleep (TLS) Core Enable for System RAMs. Assert low to enable the TLS core feature, which will result in lower leakage current.
In case VDD is below 0.81V, it is necessary to hold this pin high to maintain data retention.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim register for bandgap </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BIAS_VREF_SEL_REG</name>
	
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000bb</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BIAS_VREF_RF2_SEL</name>
	<description>same coding as BIAS_VREF_RF1_SEL.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BIAS_VREF_RF1_SEL</name>
	<description>Vref_code | Vref_Voltage (mV)
0:900
1:930
2:960
3:990
4:1020
5:1050
6:1080
7:1110
8:1140
9:1170
10:1200
11:1230
12:1260
13:1290
14:1320
15:1350</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_CTRL_REG</name>
	<description>Brown Out Detection control register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0001fc80</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>BOD_V14_RST_EN</name>
	<description>If set, generate power-on reset on channel V14</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18F_RST_EN</name>
	<description>If set, generate power-on reset on channel V18F</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VDD_RST_EN</name>
	<description>If set, generate power-on reset on channel VDD</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18P_RST_EN</name>
	<description>If set, generate power-on reset on channel V18P</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18_RST_EN</name>
	<description>If set, generate power-on reset on channel V18</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V30_RST_EN</name>
	<description>If set, generate power-on reset on channel V30</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VBAT_RST_EN</name>
	<description>If set, generate power-on reset on channel VBAT</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V14_EN</name>
	<description>Enable brown-out detection for channel V14</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18F_EN</name>
	<description>Enable brown-out detection for channel V18F</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VDD_EN</name>
	<description>Enable brown-out detectionfor channel VDD</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18P_EN</name>
	<description>Enable brown-out detectio for channel V18P</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18_EN</name>
	<description>Enable brown-out detectionfor channel V18</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V30_EN</name>
	<description>Enable brown-out detection for channel V30</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VBAT_EN</name>
	<description>Enable brown-out detectionfor channel VBAT</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_STATUS_CLEAR</name>
	<description>Clears the brownout status register</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_CLK_DIV</name>
	<description>Brown-out detector clock divider.
0x0: BOD_CLK/1
0x1: BOD_CLK/2
0x2: BOD_CLK/4
0x3: BOD_CLK/8 (BOD_CLK = 1MHz)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_LVL_CTRL0_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x041e0eaf</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BOD_LVL_V18</name>
	<description>Brown-out detection level for V18; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[26:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_LVL_V30</name>
	<description>Brown-out detection level for V30; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_LVL_VBAT</name>
	<description>Brown-out detection level for VBAT; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.5*(1.2 * (BOD_LVL+1)/192)</description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_LVL_CTRL1_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00df0107</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>BOD_LVL_VDD_RET</name>
	<description>Brown-out detection level for VDD in sleep; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[24:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_LVL_VDD_ON</name>
	<description>Brown-out detection level for VDD in active; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[16:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_LVL_V18P</name>
	<description>Brown-out detection level for V18P; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_LVL_CTRL2_REG</name>
	
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018f07</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>BOD_LVL_V14</name>
	<description>Brown-out detection level for V14; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_LVL_V18F</name>
	<description>Brown-out detection level for V18F; disable the bod channel before adjusting the level setting.
VTH_BOD = 1.2 * (BOD_LVL+1)/192 </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_STATUS_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>BOD_V14</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18F</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDD</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18P</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V30</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VBAT</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000022</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QSPI2_ENABLE</name>
	<description>Clock enable for QSPI RAM controller </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPI2_DIV</name>
	<description>QSPI divider
00 = divide by 1
01 = divide by 2
10 = divide by 4
11 = divide by 8</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPI_ENABLE</name>
	<description>Clock enable for QSPI controller </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPI_DIV</name>
	<description>QSPI divider
00 = divide by 1
01 = divide by 2
10 = divide by 4
11 = divide by 8</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRNG_CLK_ENABLE</name>
	<description>Clock enable for TRNG block </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AES_CLK_ENABLE</name>
	<description>Clock enable for AES crypto block </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock, Cascaded with HCLK:
00 = divide hclk by 1
01 = divide hclk by 2
10 = divide hclk by 4
11 = divide hclk by 8 </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock. Source clock divided by:
000 = divide hclk by 1
001 = divide hclk by 2
010 = divide hclk by 4
011 = divide hclk by 8
1xx = divide hclk by 16</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00002041</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RUNNING_AT_PLL96M</name>
	<description>Indicates that the PLL96MHz clock is used as clock, and may not be switched off </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_XTAL32M</name>
	<description>Indicates that the XTAL32M clock is used as clock, and may not be switched off </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RC32M</name>
	<description>Indicates that the RC32M clock is used as clock </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_LP_CLK</name>
	<description>Indicates that either the LP_CLK is being used as clock </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_CLK_SRC</name>
	<description>Selects the USB source clock
0 : PLL clock, divided by 2
1 : HCLK</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LP_CLK_SEL</name>
	<description>Sets the clock source of the LowerPower clock
0x0: RC32K
0x1: RCX
0x2: XTAL32K through the oscillator with an external Crystal.
0x3: XTAL32K through an external square wave generator (set PID of GPIO to FUNC_GPIO)</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0 : XTAL32M
0x1 : RC32M
0x2 : The Low Power clock is used
0x3 : The PLL96Mhz is used</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_SYNCH_RESET</name>
	<description>Force synchronous reset to CMAC core and Sleep Timer. Its effective only when both Radio and Timer Power Domains are powered and the clocks are enabled.
CMAC CPU and CMAC registers, including the retained ones, will be reset.
It should be kept in reset for enough time to make sure that it will be captured by CMAC, Low Power and APB clocks.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CLK_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_DIV</name>
	<description>Division factor for CMAC
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32K_REG</name>
	<description>32 kHz RC oscillator register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>RC32K_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_ENABLE</name>
	<description>Enables the 32kHz RC oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32M_REG</name>
	<description>Fast RC control register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001804ae</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>RC32M_INIT_RANGE</name>
	<description>Course frequency adjustment</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_INIT_DEL</name>
	<description>Fine frequency adjustment</description>
	<bitRange>[19:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_INIT_DTCF</name>
	<description>Fine duty-cycle adjustment.
0x0: minimum
0x2: default
0x4: maximum
0x5 until 0x7: oscillator does not work.</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_INIT_DTC</name>
	<description>Course duty-cycle adjustment.
0x0: minimum
0x5: default
0xA: maximum
0xB until 0xF: oscillator does not work</description>
	<bitRange>[8:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_BIAS</name>
	<description>Bias adjustment</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_ENABLE</name>
	<description>Enables the 32MHz RC oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000afc</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RCX_BIAS</name>
	<description>LDO bias current.
0x0: minimum
0xF: maximum</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_C0</name>
	<description>Add unit capacitance to RC-time delay.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_CADJUST</name>
	<description>Adjust capacitance part of RC-time delay.
0x00: minimum capacitance
0x1F: maximum capacitance</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_RADJUST</name>
	<description>Adjust resistance part of RC-time delay. Lower resistance increases power consumption.
0x0: maximum resistance
0x1: minimum resistance</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_ENABLE</name>
	<description>Enable the RCX oscillator</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RTCDIV_REG</name>
	<description>Divisor for RTC 100Hz clock</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00051ea8</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>RTC_RESET_REQ</name>
	<description>Reset request for the RTC module</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_ENABLE</name>
	<description>Enable for the 100 Hz generation for the RTC block</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_DENOM</name>
	<description>Selects the denominator for the fractional division:
0b0: 1000
0b1: 1024</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_INT</name>
	<description>Integer divisor part for RTC 100Hz generation</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_FRAC</name>
	<description>Fractional divisor part for RTC 100Hz generation.
if RTC_DIV_DENOM=1, &lt;RTC_DIV_FRAC&gt; out of 1024 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;
If RTC_DIV_DENOM=0, &lt;RTC_DIV_FRAC&gt; out of 1000 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SWITCH2XTAL_REG</name>
	<description>Switches clock from RC32M to XTAL32M</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>SWITCH2XTAL</name>
	<description>When writing to this register, the clock switch will happen from RC32M to XTAL32M. If any other clock is selected than RC32M, the selection is discarded.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CLK_TMR_REG</name>
	<description>Clock control for the timers</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TMR2_PWM_AON_MODE</name>
	<description>Maps Timer2_pwm onto P1_06.
This state is preserved during deep sleep, to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_PWM_AON_MODE</name>
	<description>Maps Timer1_pwm onto P1_01
This state is preserved during deep sleep, to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_XTAL32K_REG</name>
	<description>32 kHz XTAL oscillator register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000002e</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>XTAL32K_DISABLE_OUTPUT</name>
	<description>Disables output buffer, test only</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock to XTAL32Kp
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator. 0000 is minimum, 1111 is maximum, 0011 is default. For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Prefered setting will be provided by Dialog </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DISCHARGE_RAIL_REG</name>
	<description>Immediate rail resetting. There is no LDO/DCDC gating</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RESET_V18P</name>
	<description>1: Enables immediate discharging of the V18P rail. Note that the source is not disabled.
0: disable immediate discharging of the V18P rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V18P</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_V18</name>
	<description>1: Enables immediate discharging of the V18 rail. Note that the source is not disabled.
0: disable immediate discharging of the V18 rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V18</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_V14</name>
	<description>1: Enables immediate discharging of the V14 rail. Note that the source is not disabled.
0: disable immediate discharging of the V14 rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V14</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LDO_VDDD_HIGH_CTRL_REG</name>
	<description>LDO control register</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>LDO_VDDD_HIGH_LOW_ZOUT_DISABLE</name>
	<description>Disables the low Zout switch. The low Zout switch pulls the output of the LDO to ground. When 0, the output of the LDO is pulled to ground when the LDO is disabled. When 1, the output of the LDO remains floating when the LDO is disabled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VDDD_HIGH_STATIC_LOAD_ENABLE</name>
	<description>Enables a static load of approx. 10 uA at the output of the LDO VDDD_HIGH.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VDDD_HIGH_ENABLE</name>
	<description>0: LDO VDDD_HIGH off,
1: LDO VDDD_HIGH on.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VDDD_HIGH_VREF_HOLD</name>
	<description>0: Indicates that the reference input is tracked,
1: Indicates that the reference input is sampled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_LATCH_EN</name>
	<description>Direct write to the specific pad_latch_enable signal</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>P1_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x007fffff</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_LATCH_EN</name>
	<description>Direct write to the specific pad_latch_enable signal</description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[22:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>ENABLE_CLKLESS</name>
	<description>Selects the clockless sleep mode. Wakeup is done asynchronously.
When set to '1', the lp_clk is stopped during deep sleep, until a wakeup event (not debounced) is detected by the WAKUPCT block.
When set to '0', the lp_clk continues running, so the MAC counters keep on running.
This mode cannot be combined with regulated sleep, so keep SLEEP_TIMER=0 when using ENABLE_CLKLESS.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RETAIN_CACHE</name>
	<description>Selects the retainability of the cache block during deep sleep.
'1' is retainable, '0' is power gated</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_SLEEP</name>
	<description>Put the System powerdomain (PD_SYS) in powerdown.
If this bit is '1', and there is no pending IRQ in the PDC for the M33, the PD_SYS will be switched off.
Wakeup should be handled by the PDC.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_BANDGAP_EN</name>
	<description>Setting this bit will:

-map bandgap_enable to P0_25
-map (wokenup OR cmac_slp_timer_expire) to P0_16
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>COM_SLEEP</name>
	<description>Put the Communications powerdomain (PD_COM) in powerdown </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SLEEP</name>
	<description>Put the Timers Powerdomain (PD_TIM) in powerdown.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio, including CMAC (PD_RAD) in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PERIPH_SLEEP</name>
	<description>Put the peripherals power domain (PD_PER) in powerdown</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_SLEEP_REG</name>
	<description>Configures the sleep/wakeup strategy</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010080</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>CLAMP_VDD_WKUP_MAX</name>
	<description>Forces the VDD clamp voltage to its maximum value when waking up from sleep.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ULTRA_FAST_WAKEUP</name>
	<description>Allows the core to start running on the RC32M while the PMU is still waiting for supplies to settle to the final value. Only use in combination with FAST_WAKEUP and 0.9 V on VDD during sleep.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FAST_WAKEUP</name>
	<description>Speeds up the wakeup process by enabling all LDOs simultaneously instead of in staggered order. Only use if all voltages have been retained during sleep.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_SLEEP_INTERVAL</name>
	<description>This is a value defining the interval every which Brown Out Detection is activated to check on the power rails voltage. The value represents BG_REFRESH_INTERVALs</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_REFRESH_INTERVAL</name>
	<description>This is a value defining the interval every which the Bandgap will be activated for refresh. The value represents ticks of lp_clk/64 e.g. 30,5 us * 64 = 1,9 ms.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_TRIM_REG</name>
	<description>LDO trimming register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008800</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LDO_1V8_TRIM</name>
	<description>Trim setting for LDO_1V8
Unsigned binary notation, trim range &#177;10 %</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8P_TRIM</name>
	<description>Trim setting for LDO_1V8P
Unsigned binary notation, trim range &#177;10 %</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_SUPPLY_VBAT_TRIM</name>
	<description>Trim setting for LDO_SUPPLY_VBAT
Sign-magnitude notation, trim range &#177;10 %</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_SUPPLY_VBUS_TRIM</name>
	<description>Trim setting for LDO_SUPPLY_VBUS
Sign-magnitude notation, trim range &#177;10 %</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_PIN_REG</name>
	<description>Selects a GPIO pin for POR generation</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000003f</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>POR_PIN_POLARITY</name>
	<description>0: Active Low
1: Active High
Note: This applies only for the GPIO pin. Reset pad is always active High
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_PIN_SELECT</name>
	<description>0x00: P0_00
...
0x1f: P0_31
0x20: P1_00
...
0x36: P1_22
0x37 to 0x3E: reserved
0x3F: POR generation disabled</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_TIMER_REG</name>
	<description>Time for POR to happen</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>POR_TIME</name>
	<description>Time for the POReset to happen.
Formula:
Time = POR_TIME x 4096 x RC32 clock period
Default value: ~3 seconds
</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_VBAT_CTRL_REG</name>
	<description>Controls the POR on VBAT</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000326f</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>POR_VBAT_MASK_N</name>
	<description>Enables propagation of the generated POR</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_ENABLE</name>
	<description>Enables generation of the POR</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HYST_LOW</name>
	<description>Controls hysteresis of POR. 20mV per step. Must be set to 0x2 when thres_ctrl_low is set to 0xf.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_THRES_HIGH</name>
	<description>High-side (PTAT) threshold contribution:
Level --&gt; Threshold
0x0 --&gt; 1.25V
0x1 --&gt; 1.27V
0x2 --&gt; 1.29V
0x3 --&gt; 1.31V
0x4 --&gt; 1.44V
0x5 --&gt; 1.49V
0x6 --&gt; 1.53V
0x7 --&gt; 1.58V
0x8 --&gt; 1.63V
0x9 --&gt; 1.68V
0xA --&gt; 1.73V
0xB --&gt; 1.78V0xC --&gt; 1.83V0xD --&gt; 1.87V0xE --&gt; 1.92V
0xF --&gt; 1.97V
</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_THRES_LOW</name>
	<description>Low-side (CTAT) threshold contribution
Level --&gt; Threshold
0xC --&gt; 1.25V
0xC --&gt; 1.27V
0xC --&gt; 1.29V
0xC --&gt; 1.31V
0x0 --&gt; 1.44V
0x1 --&gt; 1.49V
0x2 --&gt; 1.53V
0x3 --&gt; 1.58V
0x4 --&gt; 1.63V
0x5 --&gt; 1.68V
0x6 --&gt; 1.73V
0x7 --&gt; 1.78V
0x8 --&gt; 1.83V
0x9 --&gt; 1.87V
0xA --&gt; 1.92V
0xB --&gt; 1.97V
0xF --&gt; 1.63V; use only with POR_VBAT_THRES_LOW=0x6 and POR_VBAT_THRES_HYST=0x2</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	<description>Power control register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x08c35bdd</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>VDD_SLEEP_LEVEL</name>
	<description>Level setting for VDD rail when using sleep LDO
0x0: 0.75 V
0x1: 0.80 V
0x2: 0.85 V
0x3: 0.90 V
0x4: 0.95 V
0x5: 1.00 V
0x6: N.A.
0x7: N.A.</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_CLAMP_LEVEL</name>
	<description>Level setting for VDD when using clamp
Typical output voltages (not regulated):
0x0: 1037 mV
0x1: 1005 mV
0x2: 978 mV
0x3: 946 mV
0x4: 1120 mV
0x5: 1089 mV
0x6: 1058 mV
0x7: 1030 mV
0x8: 952 mV
0x9: 918 mV
0xA: 889 mV
0xB: 861 mV
0xC: 862 mV
0xD: 828 mV
0xE: 798 mV
0xF: 706 mV ( changed to be lower than ldo_core_ret level)</description>
	<bitRange>[28:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLAMP_3V0_VBAT_ENABLE</name>
	<description>Enables (1) or disables (0) clamp that can supply V30 from VBAT</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V18_LEVEL</name>
	<description>Level setting for V18 rail
0x0: 1.2 V
0x1: 1.8 V</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V14_LEVEL</name>
	<description>Level setting for V14 rail
0x0: 1.20 V
0x1: 1.25 V
0x2: 1.30 V
0x3: 1.35 V
0x4: 1.40 V
0x5: 1.45 V
0x6: 1.50 V
0x7: 1.55 V</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V30_LEVEL</name>
	<description>Level setting for V30 rail
0x0: 3.0 V
0x1: 3.45 V
0x2: 3.3 V
0x3: 3.3 V</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_LEVEL</name>
	<description>Level setting for VDD rail
0x0: 0.9 V
0x1: 1.0 V
0x2: 1.1 V
0x3: 1.2 V</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_3V0_REF</name>
	<description>Selects reference source for V30 LDOs
0x0: VDD rail
0x1: Bandgap output</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or disables (0) LDO_CORE_RET in sleep mode</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or disables (0) LDO_CORE_RET in active mode</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_ENABLE</name>
	<description>Enables (1) or disables (0) LDO_CORE</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_3V0_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or disables (0) LDO_3V0_RET in sleep mode</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_3V0_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or disables (0) LDO_3V0_RET in active mode</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_3V0_MODE</name>
	<description>Controls for LDO_3V0
0x0: Disabled
0x1: LDO_VBAT enabled
0x2: LDO_VBUS enabled
0x3: Automatic selection of LDO_VBAT or LDO_VBUS</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_ENABLE</name>
	<description>Enables (1) or disables (0) LDO_RADIO</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or disables (0) LDO_1V8_RET in sleep mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or disables (0) LDO_1V8_RET in active mode</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8_ENABLE</name>
	<description>Enables (1) or disables (0) LDO_1V8</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_1V8F_ENABLE_FORCE</name>
	<description>Forces switch between V18P and V18F rails on</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8P_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or disables (0) LDO_1V8P_RET in sleep mode</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8P_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or disables (0) LDO_1V8P_RET in active mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_1V8P_ENABLE</name>
	<description>Enables (1) or disables (0) LDO_1V8P</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_PWR_CTRL_REG</name>
	<description>Control power state of System RAMS</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RAM8_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM7_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM6_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM5_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM4_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM3_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_PWR_CTRL</name>
	<description>Power state control of the individual RAMs. May only change when the memory isn't accessed.
When PD_MEM_IS_UP:
0x0: Normal operation
0x1: Normal operation
0x2: Retained (no access possible)
0x3: Off (memory content corrupted)
When PD_MEM_IS_DOWN:
0x0: Retained
0x1: Off (memory content corrupted)
0x2: Retained
0x3: Off (memory content corrupted)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000003f</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CMAC_WDOGRESET_STAT</name>
	<description>Indicates that a CMAC-Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWD_HWRESET_STAT</name>
	<description>Indicates that a write to SWD_RESET_REG has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a SW Reset has happened</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a HW Reset has happened</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened.
All bitfields of RESET_STAT_REG should be read (in order to check the source of reset) and then cleared to '0', allowing thus the HW to automatically set to '1' the proper bitfields during the next reset event.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SECURE_BOOT_REG</name>
	<description>Controls secure booting</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>PROT_QSPI_KEY_READ</name>
	<description>This bit will permanently disable CPU read capability at OTP offset 0x00000B00 and for the complete segment</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_QSPI_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x00000B00 and for the complete segment </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_AES_KEY_READ</name>
	<description>This bit will permanently disable CPU read capability at OTP offset 0x00000A00 and for the complete segment </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_AES_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x00000A00 and for the complete segment </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_SIG_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x000008C0 and for the complete segment </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_CMAC_DEBUGGER_OFF</name>
	<description>This bit will permanently disable the CMAC debugger</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_DEBUGGER_OFF</name>
	<description>Follows the respective OTP flag value. Its value is updated by the BootROM code.
1: The system debugger SWD is totally disabled.
0: The system debugger is enabled with DEBUGGER_ENABLE</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SECURE_BOOT</name>
	<description>Follows the respective OTP flag value. Its value is updated by the BootROM code.
1: system is a secure system supporting secure boot
0: system is not supporting secure boot</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will generate a SW_RESET.</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CACHERAM_MUX</name>
	<description>Controls accessiblity of Cache RAM:
0: the cache controller is bypassed, the cacheRAM is visible in the memory space
1: the cache controller is enabled, the cacheRAM is not visible anymore in the memory space</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPI_INIT</name>
	<description>Enables QSPI initialization after wakeup</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_INTVECT</name>
	<description>0: normal operation
1: If ARM is in address range 0 to 0x1FF then the address is remapped to SYS-RAM 0x0080.0000 to 0x0080.01FF. This allows to put the interrupt vector table to be placed in RAM while executing from QSPI.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP un-cached
0x2: QSPI FLASH cached (see also the CACHE_FLASH_REG.FLASH_REGION.* descriptions)

Note 1: When REMAP_ADR0=0x2, address 0x0 is mapped to FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2.Note 2: When REMAP_ADR0=0x2, the CPU can only access the Flash region [FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2, FLASH_REGION_SIZE] from the 0x16000000 address range. The complete Flash can be accessed via the 0x36000000 address range but only uncached.0x3: RAMS un-cached
0x4: QSPI FLASH un-cached (for verification only)
0x5: SYSRAM2 (for testing purposes only)
0x6: Cache Data RAM un-cached (CACHERAM_MUX=0, for testing purposes only)


Note 1: DWord (64 bits) access is not supported by the Cache Data RAM interface in mirrored mode (only 32, 16 and 8 bits).Note 2: DMA access is not supported by the Cache Data RAM interface when REMAP_ADR0=0x6.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000025a5</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>POWER_IS_UP</name>
	<description>Indicates that the Startup statemachine is finished, and all power regulation is in order.
In UltraFastWakeup mode, the SW needs to wait for this signal before starting any heavy traffic.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_ACTIVE</name>
	<description>Indicates that a debugger is attached.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COM_IS_UP</name>
	<description>Indicates that PD_COM is functional </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COM_IS_DOWN</name>
	<description>Indicates that PD_COM is in power down </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_UP</name>
	<description>Indicates that PD_TIM is functional </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_DOWN</name>
	<description>Indicates that PD_TIM is in power down </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_UP</name>
	<description>Indicates that PD_MEM is functional</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_DOWN</name>
	<description>Indicates that PD_MEM is in power down</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_UP</name>
	<description>Indicates that PD_SYS is functional </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_DOWN</name>
	<description>Indicates that PD_SYS is in power down </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_UP</name>
	<description>Indicates that PD_PER is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_DOWN</name>
	<description>Indicates that PD_PER is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>VBUS_IRQ_CLEAR_REG</name>
	<description>Clear pending IRQ register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VBUS_IRQ_CLEAR</name>
	<description>Writing any value to this register will reset the VBUS_IRQ line</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>VBUS_IRQ_MASK_REG</name>
	<description>IRQ masking</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VBUS_IRQ_EN_RISE</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to ramp above threshold</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBUS_IRQ_EN_FALL</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to fall below threshold</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_XTAL</name>
	<version>1.0</version>
	<description>CRG_XTAL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>116</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_FREQ_TRIM_REG</name>
	<description>Xtal frequency trimming register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2bfafd70</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_START</name>
	<description>Xtal frequency trimming register - START phase of startup
0x2BF = lowest frequency (high load capacitance)
0x000 = highest frequency (low load capacitance)
Cload = 5.0p + 6.09p * XTAL32M_TRIM/0x2BF- this includes the PCB parasitic capacitances of the reference desing</description>
	<bitRange>[29:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RAMP</name>
	<description>Xtal frequency trimming register - RAMP phase of startup.
0x2BF = lowest frequency (high load capacitance)
0x000 = highest frequency (low load capacitance)
Cload = 5.0p + 6.09p * XTAL32M_TRIM/0x2BF- this includes the PCB parasitic capacitances of the reference desing</description>
	<bitRange>[19:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Xtal frequency trimming register.
0x2BF = lowest frequency (high load capacitance)
0x000 = highest frequency (low load capacitance)
Cload = 5.0p + 6.09p * XTAL32M_TRIM/0x2BF- this includes the PCB parasitic capacitances of the reference desing</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_CTRL1_REG</name>
	<description>System PLL control register 1.</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00006860</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_SEL_MIN_CUR_INT</name>
	<description>0: VCO current read from min_current &lt;5:0&gt;,
1: VCO current is internally determined with a calibration algoritm.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_PRE_DIV</name>
	<description>PLL input divider (1: Indicates divide by 2).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_N_DIV</name>
	<description>PLL loop divider N (x means divide by x, 0 means divide by 1) </description>
	<bitRange>[10:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_VREF_HOLD</name>
	<description>0: Indicates that the reference input is tracked,
1: Indicates that the reference input is sampled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_ENABLE</name>
	<description>0: LDO PLL off,
1: LDO PLL on.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_EN</name>
	<description>0: Power down
1: PLL on </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_CTRL2_REG</name>
	<description>System PLL control register 2.</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c00</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PLL_RECALIB</name>
	<description>Recalibrate</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_CTRL3_REG</name>
	<description>System PLL control register 3.</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008070</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_TEST_VCTR</name>
	<description>1: map loopfilter voltage on external pin &lt;tbd&gt; </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_MIN_CURRENT</name>
	<description>VCO current trimming.</description>
	<bitRange>[6:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_STATUS_REG</name>
	<description>System PLL status register.</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LDO_PLL_OK</name>
	<description>1: Indicates that LDO PLL is in regulation.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_CALIBRATION_END</name>
	<description>Indicates that calibration has finished.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_BEST_MIN_CUR</name>
	<description>Calibrated VCO current.</description>
	<bitRange>[10:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_LOCK_FINE</name>
	<description>1: PLL locked </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TRIM_CTRL_REG</name>
	<description>Control trimming of the XTAL32M</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000522</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>XTAL_SETTLE_N</name>
	<description>Designates that the XTAL can be safely used as the CPU clock. When XTAL_CLK_CNT reases this value, the signal XTAL_SETTLE_READY will be set</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_TRIM_SELECT</name>
	<description>Select which source controls the XTAL trimming
0b00: xtal counter. Starts CLK_FREQ_TRIM_REG[XTAL32M_START] after COUNT_N * 32 xtal pulses trim is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b01: xtal OK filter. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START], when xtal is ramping is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b10: statically forced off. Only uses CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b11: xtal OK filter, 2 stage. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START] switches to CLK_FREQ_TRIM_REG[XTAL32M_RAMP] after timeout (sw1='1', XTAL32M_CTRL0_REG[XTAL32M_SW_DELAY]), and switches to CLK_FREQ_TRIM_REG[XTAL32M_TRIM] when sw2='1'.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_COUNT_N</name>
	<description>Defines the number of XTAL cycles to be counted, before the xtal trimming is applied, in steps of 32.
0x01: 32
0x02: 64
0x3f:2016 </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL0_REG</name>
	<description>Control register for XTAL32M</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0b82e6b4</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_DXTAL_SYSPLL_ENABLE</name>
	<description>Enables DXTAL for the system PLL.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CORE_CUR_SET</name>
	<description>Core current trim setting.
0x0: min current
...
0x3: default current
...
0x6 max amplitude
0x7 is equal to 0x3.</description>
	<bitRange>[17:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RCOSC_CALIBRATE</name>
	<description>Request an RC-oscillator calibration. If set, calibration will be started after xtal startup.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RCOSC_XTAL_DRIVE</name>
	<description>Enable drive of crystal by RCOSC, needed for fast startup</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CXCOMP_ENABLE</name>
	<description>Enable the shunt-capacitance compensation amplifier circuit (OSF BOOST).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL1_REG</name>
	<description>Control register for XTAL32M</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7503e8a4</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_STARTUP_TDISCHARGE</name>
	<description>Discharge time.
0x0: disable
0x1: 8 us
0x2: 4 us
0x3: 2 us
0x4: 1 us
0x5: 1/2 us
0x6: 1/8 us
0x7: 1/32 us</description>
	<bitRange>[30:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_STARTUP_TSETTLE</name>
	<description>Settle time.
0x0: 16 us
0x1: 8 us
0x2: 4 us
0x3: 2 us
0x4: 1 us
0x5: 1/2 us
0x6: 1/4 us
0x7: 1/8 us</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_XTAL_ENABLE</name>
	<description>Enable xtal (startup) or enable xtal block (software control mode) - testing only, to enable xtal, use PDC.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_STARTUP_TDRIVE_LSB</name>
	<description>LSB part of the sequence drive time. From 0 to 32us with steps of 1/32us.</description>
	<bitRange>[22:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_DRIVE_CYCLES</name>
	<description>Number of sequences to drive at startup.</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_STARTUP_TDRIVE</name>
	<description>Drive time of the sequence.
0x0: 32 us
0x1: 16 us
0x2: 8 us
0x3: 4 us
0x4: 2 us
0x5: 1 us
0x6: 1/2 us
0x7: 1/4 us</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RCOSC_SYNC_DELAY_TRIM</name>
	<description>Synchronization mode delay trim..</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL2_REG</name>
	<description>Control register for XTAL32M</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001e4007</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_RCOSC_TRIM_SNS</name>
	<description>Trim sensitivity used during calibration of the RC-oscillator.
XTAL_RCOSC_TRIM_SNS = 128/(M0*S)
M0=8196
S = sensitivity of RCOSC (~128ppm/LSB)
Using the internal frequency counter
S = (FreqDetHigh -FreqDetLow) /(M*D)
FreqDetHigh, FreqDetLow: the frequency counter reading (XTAL32M_STAT0_REG.FREQ_DET_OUT) at trim setting T0 and T1 (XTAL32M_CTRL3_REG.XTAL32M_RCOSC_TRIM)
D = T0 - T1
M -&gt; see XTAL32M_CTRL2_REG.XTAL32M_FREQ_DET_LEN
XTAL_RCOSC_TRIM_SNS = 64 * D / (FreqDetHigh-FreqDetLow), when XTAL32M_FREQ_DET_LEN = 1</description>
	<bitRange>[21:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CXCOMP_PHI_TRIM</name>
	<description>Phase correction for cxcomp circuit.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CXCOMP_TRIM_CAP</name>
	<description>Size of shunt capacitance compensation cap</description>
	<bitRange>[11:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL3_REG</name>
	<description>Control register for XTAL32M</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00096255</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_RCOSC_TRIM_STROBE</name>
	<description>Force RC-oscillator trim setting.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_FREQ_DET_START</name>
	<description>Force start frequency detector.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_SW_CTRL_MODE</name>
	<description>Enable all the software overrides, the state-machine will remain in IDLE.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RCOSC_BAND_SELECT</name>
	<description>Set RCOSC band select - apply with RCOSC_TRIM_STROBE</description>
	<bitRange>[17:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_RCOSC_TRIM</name>
	<description>Set RCOSC trim (fine) - apply with RCOSC_TRIM_STROBE</description>
	<bitRange>[13:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL4_REG</name>
	<description>Control register for XTAL32M</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>XTAL32M_STAT0_REG</name>
	<description>Status register for XTAL32M</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_RCOSC_BAND_SELECT_STAT</name>
	<description>Currently selected band.</description>
	<bitRange>[31:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_RCOSC_CALIBRATION_DONE</name>
	<description>Signals that the calibration phase has been completed.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_STAT1_REG</name>
	<description>Status register for XTAL32M</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_CAL_STATE</name>
	<description>Current state of the calibration state-machine.
0x0: CAL_DELAY - Delay for the biasing to settle
0x1: CAL_SYNC - Enables synchronization circuit
0x2: CAL_FREQDET - Enables the frequency detector
0x3: CAL_OFFSET - Evaluate OFFSET trimresult
0x4: CAL_MULT_SHIFT - Evaluate (delta) trimresult
0x5: CAL_TRIM - Generate new trimvalue
0x6: CAL_BAND_UPDWN - Delay after band change
0x7: CAL_END - Calibration ended
0x8: CAL_IDLE - Calibration IDLE (default state)
</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_STATE</name>
	<description>Current state of the startup state-machine.
0x0: XTAL_WAIT_LDO - Allow for setling of the biasing
0x1: XTAL_DRIVE - Crystal is driven by rcosc
0x2: XTAL_DISCHARGE - Discharge loadcaps
0x3: XTAL_SETTLE - Allows for settling of the xtal signal
0x4: XTAL_SYNC - Restart RCOSC, and synchronize
0x5: XTAL_OVERLOAD_DETECT - amplitude detection mode by overload bit
0x6: XTAL_OVERLOAD_BLANK_SETTLE - setling delay for amplitude regulator when drive ends
0x7: XTAL_OVERLOAD_BLANK - blank glitch from enabling gm_current
0x8: XTAL_RUN - Startup ended
0x9: XTAL_SAMPLE - Delay before sample amplitude control
0xa: XTAL_SW2_MASK - Delay for masked SW2
0xb: XTAL_IDLE - Idle state (default)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTALRDY_CTRL_REG</name>
	<description>Control register for XTALRDY IRQ</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTALRDY_CLK_SEL</name>
	<description>XTALRDY IRQ timer clock selection:
0: 32KHz
1: 256kHz</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTALRDY_CNT</name>
	<description>Number of 32kHz or 256kHz cycles between the crystal is enabled, and the XTALRDY_IRQ is fired. Frequency set by XTALRDY_CLK_SEL.
0x00: no interrupt
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTALRDY_STAT_REG</name>
	<description>Difference between XTAL_OK and XTALRDY_IRQ in LP clock cycles</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTALRDY_COUNT</name>
	<description>Current value of IRQ counter</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTALRDY_STAT</name>
	<description>Value of IRQ counter when trimming is switched from RAMP to TRIM</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC</name>
	<version>1.0</version>
	<description>DCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>60</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DCDC_CTRL1_REG</name>
	<description>DCDC First Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCDC_SH_ENABLE</name>
	<description>Enables sample and hold circuit in output comparators.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_STARTUP_DELAY</name>
	<description>Delay between turning bias on and converter becoming active
0 - 31 us, 1 us step size</description>
	<bitRange>[30:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_IDLE_MAX_FAST_DOWNRAMP</name>
	<description>Maximum output idle time for fast current limit downramping.
0 - 7875 ns, 125 ns step size</description>
	<bitRange>[25:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_SW_TIMEOUT</name>
	<description>P and N switch timeout, if switch is closed longer than this a timeout is generated and the FSM is forced to the next state
Writing 0 disables timeout functionality
62.5 - 1937.5 ns, 62.5 ns step size</description>
	<bitRange>[19:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FAST_STARTUP</name>
	<description>Set current limit to maximum during initial startup</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_MAN_LV_MODE</name>
	<description>Manually activates low voltage settings</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_AUTO_LV_MODE</name>
	<description>Switches to low voltage settings when battery voltage drops below 2.5 V</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_IDLE_CLK_DIV</name>
	<description>Idle Clock Divider
00 = 2
01 = 4
10 = 8
11 = 16</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_PRIORITY</name>
	<description>Charge priority register (4x 2 bit ID)
Charge sequence is [1:0] &gt; [3:2] &gt; [5:4] &gt; [7:6]
V14 = 00
V18 = 01
VDD = 10
V18P = 11</description>
	<bitRange>[9:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FW_ENABLE</name>
	<description>Freewheel switch enable</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ENABLE</name>
	<description>Enable setting for DCDC converter</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_CTRL2_REG</name>
	<description>DCDC Second Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x080888df</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>DCDC_V_NOK_CNT_MAX</name>
	<description>Maximum number of V_NOK events on an output before V_AVAILABLE is reset</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_N_COMP_TRIM_MAN</name>
	<description>Enables manual trimming for N side comparator</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_N_COMP_TRIM_VAL</name>
	<description>Manual trim value for N side comparator
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_TIMEOUT_IRQ_TRIG</name>
	<description>Number of timeout events before timeout interrupt is generated</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_TIMEOUT_IRQ_RES</name>
	<description>Number of successive non-timed out charge events required to clear timeout event counter</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_SLOPE_CONTROL</name>
	<description>Sets strength of N and P switch drivers</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VBTSTRP_TRIM</name>
	<description>Trim bootstrap voltage
V = 1.6 V + 100 mV * N</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_LSSUP_TRIM</name>
	<description>Trim low side supply voltage
V = 2 V + 300 mV * N</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_HSGND_TRIM</name>
	<description>Trim high side ground
V = VBAT - (2 V + 400 mV * N)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_IRQ_CLEAR_REG</name>
	<description>DCDC Interrupt Clear Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DCDC_LOW_VBAT_IRQ_CLEAR</name>
	<description>Clear low VBAT interrupt</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V18P timeout interrupt</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear VDD timeout interrupt</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V18 timeout interrupt</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V14 timeout interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>DCDC_IRQ_MASK_REG</name>
	<description>DCDC Interrupt Mask Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DCDC_LOW_VBAT_IRQ_MASK</name>
	<description>Mask low VBAT interrupt</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_MASK</name>
	<description>Mask V18P timeout interrupt</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_MASK</name>
	<description>Mask VDD timeout interrupt</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_MASK</name>
	<description>Mask V18 timeout interrupt</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_MASK</name>
	<description>Mask V14 timeout interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_IRQ_STATUS_REG</name>
	<description>DCDC Interrupt Status Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DCDC_LOW_VBAT_IRQ_STATUS</name>
	<description>Low VBAT detector triggered (battery voltage below 2.5 V)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V18P output</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on VDD output</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V18 output</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V14 output</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DCDC_STATUS1_REG</name>
	<description>DCDC First Status Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>DCDC_V18P_AVAILABLE</name>
	<description>Indicates whether V18P is available
Requires that converter is enabled, output is enabled and V_OK has occured. Reset when too many V_NOK events have occured.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDD_AVAILABLE</name>
	<description>Indicates whether VDD is available
Requires that converter is enabled, output is enabled and V_OK has occured. Reset when too many V_NOK events have occured.</description>
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18_AVAILABLE</name>
	<description>Indicates whether V18 is available
Requires that converter is enabled, output is enabled and V_OK has occured. Reset when too many V_NOK events have occured.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V14_AVAILABLE</name>
	<description>Indicates whether V14 is available
Requires that converter is enabled, output is enabled and V_OK has occured. Reset when too many V_NOK events have occured.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18P_COMP_OK</name>
	<description>OK output of V18P comparator</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDD_COMP_OK</name>
	<description>OK output of VDD comparator</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18_COMP_OK</name>
	<description>OK output of V18 comparator</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V14_COMP_OK</name>
	<description>OK output of V14 comparator</description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18P_COMP_NOK</name>
	<description>NOK output of V18P comparator</description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDD_COMP_NOK</name>
	<description>NOK output of VDD comparator</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18_COMP_NOK</name>
	<description>NOK output of V18 comparator</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V14_COMP_NOK</name>
	<description>NOK output of V14 comparator</description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_N_COMP_P</name>
	<description>DCDC N side dynamic comparator P output</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_N_COMP_N</name>
	<description>DCDC N side dynamic comparator N output</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_P_COMP</name>
	<description>DCDC P side continuous time comparator output</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_N_COMP</name>
	<description>DCDC N side continuous time comparator output</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_LV_MODE</name>
	<description>Indicates if the converter is in low battery voltage mode</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18P_SW_STATE</name>
	<description>DCDC state machine V18P output</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDD_SW_STATE</name>
	<description>DCDC state machine VDD output</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V18_SW_STATE</name>
	<description>DCDC state machine V18 output</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_V14_SW_STATE</name>
	<description>DCDC state machine V14 output</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_N_SW_STATE</name>
	<description>DCDC state machine NSW output</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_P_SW_STATE</name>
	<description>DCDC state machine PSW output</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_STARTUP_COMPLETE</name>
	<description>Indicates if the converter is enabled and the startup counter has expired (internal biasing settled)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DCDC_V14_REG</name>
	<description>DCDC V14 Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x034c4243</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCDC_V14_FAST_RAMPING</name>
	<description>Fast current ramping (improves response time at the cost of more ripple)</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_TRIM</name>
	<description>Output voltage trim
Steps of 25 mV</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_CUR_LIM_MAX_HV</name>
	<description>Mximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[26:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_CUR_LIM_MAX_LV</name>
	<description>Maximum current limit (low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[21:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_CUR_LIM_MIN</name>
	<description>Minimum current limit
I = 30 mA * (1 + N)</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_IDLE_HYST</name>
	<description>Idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<bitRange>[11:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_IDLE_MIN</name>
	<description>Minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_ENABLE_HV</name>
	<description>Output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_ENABLE_LV</name>
	<description>Output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_V18P_REG</name>
	<description>DCDC V18P Control Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x47fe4242</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCDC_V18P_FAST_RAMPING</name>
	<description>Fast current ramping (improves response time at the cost of more ripple)</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_TRIM</name>
	<description>Output voltage trim
Steps of 25 mV</description>
	<bitRange>[30:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_CUR_LIM_MAX_HV</name>
	<description>Maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[26:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_CUR_LIM_MAX_LV</name>
	<description>Maximum current limit (low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[21:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_CUR_LIM_MIN</name>
	<description>Minimum current limit
I = 30 mA * (1 + N)</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_IDLE_HYST</name>
	<description>Idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<bitRange>[11:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_IDLE_MIN</name>
	<description>Minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_ENABLE_HV</name>
	<description>Output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_ENABLE_LV</name>
	<description>Output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_V18_REG</name>
	<description>DCDC V18 Control Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x47fe4242</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCDC_V18_FAST_RAMPING</name>
	<description>Fast current ramping (improves response time at the cost of more ripple)</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_TRIM</name>
	<description>Output voltage trim
Steps of 25 mV</description>
	<bitRange>[30:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_CUR_LIM_MAX_HV</name>
	<description>Maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[26:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_CUR_LIM_MAX_LV</name>
	<description>Maximum current limit (low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[21:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_CUR_LIM_MIN</name>
	<description>Minimum current limit
I = 30 mA * (1 + N)</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_IDLE_HYST</name>
	<description>Idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<bitRange>[11:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_IDLE_MIN</name>
	<description>Minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_ENABLE_HV</name>
	<description>Output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_ENABLE_LV</name>
	<description>Output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_VDD_REG</name>
	<description>DCDC VDD Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x261a4243</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCDC_VDD_FAST_RAMPING</name>
	<description>Fast current ramping (improves response time at the cost of more ripple)</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_TRIM</name>
	<description>Output voltage trim
Steps of 25 mV</description>
	<bitRange>[29:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_CUR_LIM_MAX_HV</name>
	<description>Maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[26:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_CUR_LIM_MAX_LV</name>
	<description>Maximum current limit (low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<bitRange>[21:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_CUR_LIM_MIN</name>
	<description>Minimum current limit
I = 30 mA * (1 + N)</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_IDLE_HYST</name>
	<description>Idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<bitRange>[11:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_IDLE_MIN</name>
	<description>Minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_ENABLE_HV</name>
	<description>Output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VDD_ENABLE_LV</name>
	<description>Output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DMA</name>
	<version>1.0</version>
	<description>DMA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040800</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>272</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DMA0_A_START_REG</name>
	<description>Start address A of DMA channel 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA0_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_B_START_REG</name>
	<description>Start address B of DMA channel 0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA0_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_CTRL_REG</name>
	<description>Control register for the DMA channel 0</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_IDX_REG</name>
	<description>Index value of DMA channel 0</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA0_INT_REG</name>
	<description>DMA receive interrupt register channel 0</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_LEN_REG</name>
	<description>DMA receive length register channel 0</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_A_START_REG</name>
	<description>Start address A of DMA channel 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA1_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_B_START_REG</name>
	<description>Start address B of DMA channel 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA1_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_CTRL_REG</name>
	<description>Control register for the DMA channel 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_IDX_REG</name>
	<description>Index value of DMA channel 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA1_INT_REG</name>
	<description>DMA receive interrupt register channel 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_LEN_REG</name>
	<description>DMA receive length register channel 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_A_START_REG</name>
	<description>Start address A of DMA channel 2</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA2_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_B_START_REG</name>
	<description>Start address B of DMA channel 2</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA2_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_CTRL_REG</name>
	<description>Control register for the DMA channel 2</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address
0 = do not increment
1 = increment according value of BW</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_IDX_REG</name>
	<description>Index value of DMA channel 2</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA2_INT_REG</name>
	<description>DMA receive interrupt register channel 2</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_LEN_REG</name>
	<description>DMA receive length register channel 2</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_A_START_REG</name>
	<description>Start address A of DMA channel 3</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA3_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_B_START_REG</name>
	<description>Start address B of DMA channel 3</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA3_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_CTRL_REG</name>
	<description>Control register for the DMA channel 3</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_IDX_REG</name>
	<description>Index value of DMA channel 3</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA3_INT_REG</name>
	<description>DMA receive interrupt register channel 3</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_LEN_REG</name>
	<description>DMA receive length register channel 3</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_A_START_REG</name>
	<description>Start address A of DMA channel 4</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA4_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_B_START_REG</name>
	<description>Start address B of DMA channel 4</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA4_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_CTRL_REG</name>
	<description>Control register for the DMA channel 4</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_IDX_REG</name>
	<description>Index value of DMA channel 4</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA4_INT_REG</name>
	<description>DMA receive interrupt register channel 4</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_LEN_REG</name>
	<description>DMA receive length register channel 4</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_A_START_REG</name>
	<description>Start address A of DMA channel 5</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA5_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_B_START_REG</name>
	<description>Start address B of DMA channel 5</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA5_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_CTRL_REG</name>
	<description>Control register for the DMA channel 5</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_IDX_REG</name>
	<description>Index value of DMA channel 5</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA5_INT_REG</name>
	<description>DMA receive interrupt register channel 5</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_LEN_REG</name>
	<description>DMA receive length register channel 5</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_A_START_REG</name>
	<description>Start address A of DMA channel 6</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA6_A_START</name>
	<description>Source start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_B_START_REG</name>
	<description>Start address B of DMA channel 6</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA6_B_START</name>
	<description>Destination start address</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_CTRL_REG</name>
	<description>Control register for the DMA channel 6</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_IDX_REG</name>
	<description>Index value of DMA channel 6</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA6_INT_REG</name>
	<description>DMA receive interrupt register channel 6</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_LEN_REG</name>
	<description>DMA receive length register channel 6</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_A_START_REG</name>
	<description>Start address A of DMA channel 7</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA7_A_START</name>
	<description>Source start address
NOTE: See also the DMA chapter of the Datasheet for the allowed range of the DMA7 channel's source address in Secure Boot mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_B_START_REG</name>
	<description>Start address B of DMA channel 7</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA7_B_START</name>
	<description>Destination start address
NOTE: See also the DMA chapter of the Datasheet for the allowed range of the DMA7 channel's destination address in Secure Boot mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_CTRL_REG</name>
	<description>Control register for the DMA channel 7</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0 = Ignores bus error response from the AHB bus, so DMA continues normally.
1 = Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically. It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.
NOTE: In secure boot mode, the bus error detection mode of DMA7 channel is always enabled, overruling the specific bit-field's programmed value.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.
NOTE: This bit-field is overruled to '0' when the DMA7 channel is configured as &quot;trusted&quot; channel (in Secure Boot mode).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.
*NOTE: This bit-field is overruled to '0' when the DMA7 channel is configured as &quot;trusted&quot; channel (in Secure Boot mode).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)
*NOTE: This bit-field is overruled to '0' when channel DMA7 is configured as &quot;trusted&quot; channel (in Secure Boot mode).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved
NOTE: This bit-field is overruled to &quot;10&quot; when channel DMA7 is configured as &quot;trusted&quot; channel (in Secure Boot mode).</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMAx_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_IDX_REG</name>
	<description>Index value of DMA channel 7</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied and so on.
When the transfer is completed (so when DMAx_CTRL_REG.DMA_ON has been cleared) and DMAx_CTRL_REG.CIRCULAR is not set, the register keeps its (last) value (which should be equal to DMAx_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In CIRCULAR mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA7_INT_REG</name>
	<description>DMA receive interrupt register channel 7</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field DMA_IRQ_ENABLEx of DMA_INT_MASK_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_LEN_REG</name>
	<description>DMA receive length register channel 7</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_CLEAR_INT_REG</name>
	<description>DMA clear interrupt register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_RST_IRQ_CH7</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 7 ; writing a 0 will have no effect</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH6</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 6 ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH5</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 5 ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH4</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 4 ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH3</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 3 ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH2</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 2 ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH1</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 1 ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH0</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 0 ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>DMA_INT_MASK_REG</name>
	<description>DMA Interrupt mask register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_IRQ_ENABLE7</name>
	<description>0 = disable interrupts on channel 7
1 = enable interrupts on channel 7</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE6</name>
	<description>0 = disable interrupts on channel 6
1 = enable interrupts on channel 6</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE5</name>
	<description>0 = disable interrupts on channel 5
1 = enable interrupts on channel 5</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE4</name>
	<description>0 = disable interrupts on channel 4
1 = enable interrupts on channel 4</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE3</name>
	<description>0 = disable interrupts on channel 3
1 = enable interrupts on channel 3</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE2</name>
	<description>0 = disable interrupts on channel 2
1 = enable interrupts on channel 2</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE1</name>
	<description>0 = disable interrupts on channel 1
1 = enable interrupts on channel 1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE0</name>
	<description>0 = disable interrupts on channel 0
1 = enable interrupts on channel 0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_INT_STATUS_REG</name>
	<description>DMA interrupt status register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA_BUS_ERR7</name>
	<description>0 = No bus error response is detected for channel 7
1 = Bus error response detected for channel 7
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.It is also noted that when the specific channel becomes secure (so when either of the PROT_AES_KEY_READ and PROT_QSPI_KEY_READ bits of SECURE_BOOT_REG is set), this bit-field is overruled to '0', masking the bus error status reporting to the user.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR6</name>
	<description>0 = No bus error response is detected for channel 6
1 = Bus error response detected for channel 6
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR5</name>
	<description>0 = No bus error response is detected for channel 5
1 = Bus error response detected for channel 5
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR4</name>
	<description>0 = No bus error response is detected for channel 4
1 = Bus error response detected for channel 4
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR3</name>
	<description>0 = No bus error response is detected for channel 3
1 = Bus error response detected for channel 3
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR2</name>
	<description>0 = No bus error response is detected for channel 2
1 = Bus error response detected for channel 2
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR1</name>
	<description>0 = No bus error response is detected for channel 1
1 = Bus error response detected for channel 1
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR0</name>
	<description>0 = No bus error response is detected for channel 0
1 = Bus error response detected for channel 0
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH7</name>
	<description>0 = IRQ on channel 7 is not set
1 = IRQ on channel 7 is set</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH6</name>
	<description>0 = IRQ on channel 6 is not set
1 = IRQ on channel 6 is set</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH5</name>
	<description>0 = IRQ on channel 5 is not set
1 = IRQ on channel 5 is set</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH4</name>
	<description>0 = IRQ on channel 4 is not set
1 = IRQ on channel 4 is set</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH3</name>
	<description>0 = IRQ on channel 3 is not set
1 = IRQ on channel 3 is set</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH2</name>
	<description>0 = IRQ on channel 2 is not set
1 = IRQ on channel 2 is set</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH1</name>
	<description>0 = IRQ on channel 1 is not set
1 = IRQ on channel 1 is set</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH0</name>
	<description>0 = IRQ on channel 0 is not set
1 = IRQ on channel 0 is set</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA_REQ_MUX_REG</name>
	<description>DMA channel assignments</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA67_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 6 and the second on channel 7.
See DMA01_SEL for the peripheral mapping.</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA45_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 4 and the second on channel 5.
See DMA01_SEL for the peripherals' mapping.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA23_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 2 and the second on channel 3.
See DMA01_SEL for the peripherals' mapping.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA01_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 0 and the second on channel 1.
0x0: SPI_rx / SPI_tx
0x1: SPI2_rx / SPI2_tx
0x2: UART_rx / UART_tx
0x3: UART2_rx / UART2_tx
0x4: I2C_rx / I2C_tx
0x5: I2C2_rx / I2C2_tx
0x6: USB_rx / USB_tx
0x7: UART3_rx/UART3_tx
0x8: PCM_rx / PCM_tx
0x9: SRC_out / SRC_in (for all the supported conversions)
0xA: Reserved
0xB: Reserved
0xC: GP_ADC / -
0xD: SD_ADC / -
0xE: Reserved
0xF: None

Note: If any of the four available peripheral selector fields (DMA01_SEL, DMA23_SEL, DMA45_SEL, DMA67_SEL) have the same value, the lesser significant selector has higher priority and will control the DMA acknowledge signal driven to the selected peripheral. Hence, if DMA01_SEL = DMA23_SEL, the channels 0 and 1 will provide the Rx and Tx DMA acknowledge signals for the selected peripheral. Consequently, it is suggested to assign the intended peripheral value to a unique selector field.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DW</name>
	<version>1.0</version>
	<description>DW registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30020000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>148</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>AHB_DMA_CCLM1_REG</name>
	<description>USB Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>Number of tokens (counted in AHB clock cycles) that a master can use on the bus before it has to arbitrate on a bus master with low priority and having tokens. Masters with tokens remaining have priority over masters that have used all of their tokens. User should configure all the token values ensuring that the sum does not exceeds the total allocated number of tokens. If a value of zero is configured, then the bus is deemed to have infinite tokens and will always operate in the upper-tier of arbitration.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM2_REG</name>
	<description>GenDMA Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>Refer to AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM3_REG</name>
	<description>CRYPTO Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM4_REG</name>
	<description>CRYPTO Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_DFLT_MASTER_REG</name>
	<description>Default master ID number (AHB DMA layer only)</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_DFLT_MASTER</name>
	<description>Default master ID number register. The default master is the master that is granted by the bus when no master has requested ownership.
0: Dummy master
1: RFPT
2: LCD
3: GEN-DMA
3: CRYPTO-DMA</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL1_REG</name>
	<description>AHB-DMA layer priority level for RFTP (AHB DMA layer only)</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL1</name>
	<description>Arbitration priority for master RFPT. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL2_REG</name>
	<description>AHB-DMA layer priority level for LCD (AHB DMA layer only)</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000e</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL2</name>
	<description>Arbitration priority for master LCD. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL3_REG</name>
	<description>AHB-DMA layer Priority level for GEN-DMA (AHB DMA layer only)</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000d</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL3</name>
	<description>Arbitration priority for master GEN-DMA. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL4_REG</name>
	<description>AHB-DMA layer Priority level for CRYPTO-DMA (AHB DMA layer only)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000c</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL4</name>
	<description>Arbitration priority for master CRYPTO-DMA. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_TCL_REG</name>
	<description>Master clock refresh period (AHB DMA layer only)</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_TCL</name>
	<description>Master clock refresh period, counting clock cycles. An arbitration period is defined over this number of tokens. When a new arbitration period starts, the master counters are reloaded. Recommended value is the sum of the AHB_DMA_CCLMx_REG valuesplus 2 tokens for each master, i.e. plus 6.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_VERSION_REG</name>
	<description>Version ID (AHB DMA layer only)</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3231332a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_VERSION</name>
	
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_WTEN_REG</name>
	<description>Weighted-Token Arbitration Scheme Enable (AHB DMA layer only)</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_WTEN</name>
	<description>Weighted-token arbitration scheme enable.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030900</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronisation
1: Data is stored two ADC_CLK cycles after internal start trigger
15: Data is stored sixteen ADC_CLK cycles after internal start trigger</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is one ADC_CLK cycle
1: The sample time is 1*32 ADC_CLK cycles
2: The sample time is 2*32 ADC_CLK cycles
15: The sample time is 15*32 ADC_CLK cycles</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_IDYN</name>
	<description>1: Enables dynamic load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN3X</name>
	<description>0: Input voltages up to 1.2V allowed.
1: Input voltages up to 3.6V allowed by enabling 3x attenuator. (if ADC_SEL=7 or 8, this bit is automatically set to 1) Enabling the attenuator requires a longer sampling time.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024ms interval between two conversions.
2: 2.048ms interval between two conversions.
255: 261.12ms interval between two conversions.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 32x ADC_CLK period.
n: n*32x ADC_CLK period.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>GP_ADC_DIFF_TEMP_EN</name>
	<description>1: Enable the on-chip temperature sensors</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DIFF_TEMP_SEL</name>
	<description>0= Gnd, 1 =sensor near radio, 2 =sensor near charger, 3 =sensor near bandgap
with sensors disabled (GP_ADC_DIFF_TEMP_EN = 0) :0 = GND 1 = Z, 2= V(ntc) from charger, 3 = V(temp) from charger</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_ZERO</name>
	<description>1: Samples and disconnects VREF, should be refreshed frequently. Note that the LDO consumpes power when bit is set.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL</name>
	<description>ADC input selection.
If GP_ADC_SE = 1 (single ended mode):
0: GP ADC0 (P1_09)
1: GP ADC1 (P0_25)
2: GP ADC2 (P0_08)
3: GP ADC3 (P0_09)
4: VDD ( internal)
5: V30 (GP_ADC_ATTN3X scaler automatically selected)
6: V30 (GP_ADC_ATTN3X scaler automatically selected)
7: Reserved
8: VBAT1 (5V to 1.2V scaler selected)
9: VSSA (analog ground)
10-15: Reserved
16: GP ADC4 (P1_13)
17: GP ADC5 (P1_12)
18: GP ADC6 (P1_18)
19: GP ADC7 (P1_19)
20: Diff Temperature sensor, See GP_ADC_DIFF_TEMP_SEL
21-31: Reserved
If GP_ADC_SE = 0 (differential mode):
0: P1[09] vs P0[25]
All other combinations are P0[08] vs P0[09].</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single ended mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_CLK_SEL</name>
	<description>0: Internal high-speed ADC clock used (recommended).
1: Digital clock used (ADC_CLK).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled..
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=0&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 64 samples results in six extra bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020a00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>260</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPIO_CLK_SEL_REG</name>
	<description>Select which clock to map on ports P0/P1</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DIVN_OUTPUT_EN</name>
	<description>DIVN output enable bit-field. When set, it enables the mapping of DIVN clock on dedicated GPIO (P0_15). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_OUTPUT_EN</name>
	<description>RC32M output enable bit-field. When set, it enables the mapping of RC32M clock on dedicated GPIO (P0_13). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_OUTPUT_EN</name>
	<description>XTAL32M output enable bit-field. When set, it enables the mapping of XTAL32M clock on dedicated GPIO (P0_12). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_OUTPUT_EN</name>
	<description>RCX output enable bit-field. When set, it enables the mapping of RCX clock on dedicated GPIO (P0_16). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_OUTPUT_EN</name>
	<description>RC32K output enable bit-field. When set, it enables the mapping of RC32K clock on dedicated GPIO (P0_17). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_OUTPUT_EN</name>
	<description>XTAL32K output enable bit-field. When set, it enables the mapping of XTAL32K clock on dedicated GPIO (P0_14).The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_EN</name>
	<description>If set, it enables the mapping of the selected clock signal, according to FUNC_CLOCK_SEL bit-field.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_SEL</name>
	<description>Select which clock to map when PID = FUNC_CLOCK.
0x0: XTAL32K
0x1: RC32K
0x2: RCX
0x3: XTAL32M
0x4: RC32M
0x5: DIVN
0x6: Reserved
0x7: Reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_00_MODE_REG</name>
	<description>P0_00 Mode Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port:
0:  GPIO (see also the PUPD bit-field)
1:  UART_RX
2:  UART_TX
3:  UART2_RX
4:  UART2_TX
5:  UART2_CTSN
6:  UART2_RTSN
7:  UART3_RX
8:  UART3_TX
9:  UART3_CTSN
10: UART3_RTSN
11: ISO_CLK
12: ISO_DATA
13: SPI_DI
14: SPI_DO
15: SPI_CLK16: SPI_EN
17: SPI2_DI
18: SPI2_DO
19: SPI2_CLK
20: SPI2_EN
21: I2C_SCL
22: I2C_SDA
23: I2C2_SCL
24: I2C2_SDA
25: USB_SOF
26: ADC (dedicated pins, see also the &quot;Input/Output Ports&quot; chapter of Datasheet)
27: USB (dedicated pins P0_14 and P0_15)
28: PCM_DI
29: PCM_DO
30: PCM_FSC
31: PCM_CLK
32: PDM_DATA
33: PDM_CLK
34: COEX_EXT_ACT
35: COEX_SMART_ACT
36: COEX_SMART_PRI
37: PORT0_DCF
38: PORT1_DCF
39: PORT2_DCF
40: PORT3_DCF
41: PORT4_DCF
42: CLOCK (see also GPIO_CLK_SEL_REG for the dedicated pins mapping of supported clocks)
43: PG (dedicated pins, see also the &quot;Input/Output Ports&quot; chapter of Datasheet)
44: LCD (dedicated pins see also the &quot;Input/Output Ports&quot; chapter of Datasheet)
45: LCD_SPI_DC
46: LCD_SPI_DO
47: LCD_SPI_CLK
48: LCD_SPI_EN
49: TIM_PWM
50: TIM2_PWM
51: TIM_1SHOT
52: TIM2_1SHOT
53: TIM3_PWM
54: TIM4_PWM
55: Reserved
56: CMAC_DIAG0
57: CMAC_DIAG1
58: CMAC_DIAG2
59: CMAC_DIAGX (dedicated pins, see also the &quot;Input/Output Ports&quot; chapter of Datasheet)
60: Reserved
61: Reserved
62: Reserved
63: Reserved
</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_01_MODE_REG</name>
	<description>P0_01 Mode Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_02_MODE_REG</name>
	<description>P0_02 Mode Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_03_MODE_REG</name>
	<description>P0_03 Mode Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_04_MODE_REG</name>
	<description>P0_04 Mode Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_05_MODE_REG</name>
	<description>P0_05 Mode Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_06_MODE_REG</name>
	<description>P0_06 Mode Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_07_MODE_REG</name>
	<description>P0_07 Mode Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_08_MODE_REG</name>
	<description>P0_08 Mode Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_09_MODE_REG</name>
	<description>P0_09 Mode Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_10_MODE_REG</name>
	<description>P0_10 Mode Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_11_MODE_REG</name>
	<description>P0_11 Mode Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_12_MODE_REG</name>
	<description>P0_12 Mode Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_13_MODE_REG</name>
	<description>P0_13 Mode Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_14_MODE_REG</name>
	<description>P0_14 Mode Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_15_MODE_REG</name>
	<description>P0_15 Mode Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_16_MODE_REG</name>
	<description>P0_16 Mode Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_17_MODE_REG</name>
	<description>P0_17 Mode Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_18_MODE_REG</name>
	<description>P0_18 Mode Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_19_MODE_REG</name>
	<description>P0_19 Mode Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_20_MODE_REG</name>
	<description>P0_20 Mode Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_21_MODE_REG</name>
	<description>P0_21 Mode Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_22_MODE_REG</name>
	<description>P0_22 Mode Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_23_MODE_REG</name>
	<description>P0_23 Mode Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_24_MODE_REG</name>
	<description>P0_24 Mode Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_25_MODE_REG</name>
	<description>P0_25 Mode Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_26_MODE_REG</name>
	<description>P0_26 Mode Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_27_MODE_REG</name>
	<description>P0_27 Mode Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_28_MODE_REG</name>
	<description>P0_28 Mode Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_29_MODE_REG</name>
	<description>P0_29 Mode Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_30_MODE_REG</name>
	<description>P0_30 Mode Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_31_MODE_REG</name>
	<description>P0_31 Mode Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input / output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001410</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Set P0 output register when written; Returns the value of P0 port when read </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_PADPWR_CTRL_REG</name>
	<description>P0 Output Power Control Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_OUT_CTRL</name>
	<description>0 = P0_x port output is powered by the V30 rail (default)
1 = P0_x port output is powered by the 1V8P rail
bit x controls the power supply of P0[x]</description>
	<bitRange>[31:6]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_00_MODE_REG</name>
	<description>P1_00 Mode Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_01_MODE_REG</name>
	<description>P1_01 Mode Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_02_MODE_REG</name>
	<description>P1_02 Mode Register</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_03_MODE_REG</name>
	<description>P1_03 Mode Register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_04_MODE_REG</name>
	<description>P1_04 Mode Register</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_05_MODE_REG</name>
	<description>P1_05 Mode Register</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_06_MODE_REG</name>
	<description>P1_06 Mode Register</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_07_MODE_REG</name>
	<description>P1_07 Mode Register</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_08_MODE_REG</name>
	<description>P1_08 Mode Register</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_09_MODE_REG</name>
	<description>P1_09 Mode Register</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_10_MODE_REG</name>
	<description>P1_10 Mode Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_11_MODE_REG</name>
	<description>P1_11 Mode Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_12_MODE_REG</name>
	<description>P1_12 Mode Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_13_MODE_REG</name>
	<description>P1_13 Mode Register</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_14_MODE_REG</name>
	<description>P1_14 Mode Register</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_15_MODE_REG</name>
	<description>P1_15 Mode Register</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_16_MODE_REG</name>
	<description>P1_16 Mode Register</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_17_MODE_REG</name>
	<description>P1_17 Mode Register</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_18_MODE_REG</name>
	<description>P1_18 Mode Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_19_MODE_REG</name>
	<description>P1_19 Mode Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_20_MODE_REG</name>
	<description>P1_20 Mode Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_21_MODE_REG</name>
	<description>P1_21 Mode Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_22_MODE_REG</name>
	<description>P1_22 Mode Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_DATA_REG</name>
	<description>P1 Data input / output Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_DATA</name>
	<description>Set P1 output register when written; Returns the value of P1 port when read </description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_PADPWR_CTRL_REG</name>
	<description>P1 Output Power Control Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_OUT_CTRL</name>
	<description>0 = P1_x port output is powered by the V30 rail (default)
1 = P1_x port output is powered by the 1V8P rail
bit x controls the power supply of P1[x]</description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_DATA_REG</name>
	<description>P1 Reset port pins Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_RESET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[22:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_SET_DATA_REG</name>
	<description>P1 Set port pins Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>P1_SET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[22:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PAD_WEAK_CTRL_REG</name>
	<description>Weak Pads Control Register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>P1_09_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_09 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_06_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_06 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_02_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_02 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_01_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_01 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_00_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_00 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_27_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_27 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_26_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_26 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_25_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_25 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_18_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_18 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_17_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_17 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_16_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_16 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_07_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_07 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_06_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_06 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000101</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CROSS_CPU_HALT_SENSITIVITY</name>
	<description>Select the cross CPU halt sensitivity.
0: Level triggered,
1: Pulse triggered.
Note: This bit is retained.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT_ON_JTAG</name>
	<description>1: Stall the processor core out of reset (only after a wake-up from JTAG). Debugger access continue when the core is stalled. When set to '0' again the core resumes instruction execution.
This feature is independent of the PDC (Power Domain Controller) settings. If this bit is set and there is SW/JTAG activity during deep sleep, the SYS CPU is stalled after the wake-up.
Note: This bit is retained.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT</name>
	<description>1: Stall the processor core out of reset (always after a wake-up). Debugger access continue when the core is stalled. When set to '0' again the core resumes instruction execution.
Note: This bit is retained.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_IS_HALTED</name>
	<description>1: CMAC CPU is halted.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_CPU_IS_HALTED</name>
	<description>1: SYS CPU (ARM CM33) is halted.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HALT_CMAC_SYS_CPU_EN</name>
	<description>1: Enable CMAC CPU halting to the SYS CPU (ARM CM33).
Note 1: This bit is retained.
Note 2: Set this bit to '0' before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HALT_SYS_CMAC_CPU_EN</name>
	<description>1: Enable SYS CPU (ARM CM33) halting to the CMAC CPU.
Note 1: This bit is retained.
Note 2: Set this bit to '0' before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the CMAC CPU.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the SYS CPU (ARM CM33).
Default '1', freezing of the on-chip peripherals is enabled when the Cortex-M33 is halted in DEBUG State.
If '0', freezing of the on-chip peripherals is only depending on [RE]SET_FREEZE_REG except the system watchdog timer. The system watchdog timer is always frozen when the Cortex-M33 is halted in DEBUG State.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_CONTROL_REG</name>
	<description>General purpose system control register.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CMAC_H2H_BRIDGE_BYPASS</name>
	<description>If '1', the AHB-to-AHB bridge is bypassed, reducing the wait cycles needed to access the CMAC Register File, only when the system clock source is the XTAL and both hclk and cmac_hclk are running at 32 MHz, i.e. at the XTAL clock rate.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If '1', the CMAC SW Watchdog Timer continues, '0' is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If '1', the SW Timer4 continues, '0' is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If '1', the SW Timer3 continues, '0' is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_PWMLED</name>
	<description>If '1', the PWM LED continues, '0' is discarded. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer2 continues, '0' is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA continues, '0' is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB continues, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If '1', the SYS SW Watchdog Timer continues, '0' is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer continues, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If '1', the CMAC SW Watchdog Timer is frozen, '0' is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If '1', the SW Timer4 is frozen, '0' is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If '1', the SW Timer3 is frozen, '0' is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_PWMLED</name>
	<description>If '1', the PWM LED is frozen, '0' is discarded. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer2 is frozen, '0' is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA is frozen, '0' is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB is frozen, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If '1', the SYS SW Watchdog Timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer is frozen, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USBPAD_REG</name>
	<description>USB pads control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>USBPHY_FORCE_SW2_ON</name>
	<description>0: Pull up resistor SW2 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be 2.3Kohm</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USBPHY_FORCE_SW1_OFF</name>
	<description>0: Pull up resistor SW1 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be switched off.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USBPAD_EN</name>
	<description>0: The power for the USB PHY and USB pads is switched on when the USB is enabled.
1: The power for the USB PHY and USB pads is forced on.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = issues the STOP_DET interrupt only when master is active.
0 = issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = slave issues STOP_DET intr only if addressed
0 = slave issues STOP_DET intr always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
3= high speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. 
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0.= The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 =Slave is disabled when it is active
0 =Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 =I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>ndicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = ignore bit 10 GC_OR_START and use IC_TAR normally
1 = perform special I2C command as specified in GC_OR_START
bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter : Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master- scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter : Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command- scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter : Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration- scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver : User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disable
0 = User initiating master operation when MASTER disabled- scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master : To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. 
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled- scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master : Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). 
1 = ACK detected for START byte
0 = ACK detected for START byte- scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master : Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode- scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter : The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus-scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter : the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave-scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter : This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave-scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1= Byte 2 of 10Bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 =Byte 1 of 10Bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 =This abort is generated because of NOACK for 7-bit address
0 =This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C2</name>
	<version>1.0</version>
	<description>I2C2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C2_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = issues the STOP_DET interrupt only when master is active.
0 = issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = slave issues STOP_DET intr only if addressed
0 = slave issues STOP_DET intr always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
3= high speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. 
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0.= The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 =Slave is disabled when it is active
0 =Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 =I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>ndicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = ignore bit 10 GC_OR_START and use IC_TAR normally
1 = perform special I2C command as specified in GC_OR_START
bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter : Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master- scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter : Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command- scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter : Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration- scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver : User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disable
0 = User initiating master operation when MASTER disabled- scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master : To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. 
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled- scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master : Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). 
1 = ACK detected for START byte
0 = ACK detected for START byte- scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master : Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode- scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter : The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus-scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter : the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave-scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter : This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave-scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1= Byte 2 of 10Bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 =Byte 1 of 10Bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 =This abort is generated because of NOACK for 7-bit address
0 =This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>LCDC</name>
	<version>1.0</version>
	<description>LCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30030000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>396</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>LCDC_BACKPORCHXY_REG</name>
	<description>Back Porch X and Y</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_BPORCH_X</name>
	<description>Back porch X (lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_BPORCH_Y</name>
	<description>Back porch Y (pixel clocks)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_BGCOLOR_REG</name>
	<description>Background Color</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_BG_RED</name>
	<description>Red color used as background.</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_BG_GREEN</name>
	<description>Green color used as background.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_BG_BLUE</name>
	<description>Blue color used as background.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_BG_ALPHA</name>
	<description>Alpha color used as background.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_BLANKINGXY_REG</name>
	<description>Blanking X and Y</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_BLANKING_X</name>
	<description>Blanking period X (VSYNC lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_BLANKING_Y</name>
	<description>Blanking period Y (HSYNC pulse length)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_CLKCTRL_REG</name>
	<description>Clock Divider</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000401</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_SEC_CLK_DIV</name>
	<description>Secondary clock divider that generates the format pipeline clock. Source clock of this divider is the main clock of LCD controller. The period of the generated clock is defined as : (LCDC_SEC_CLK_DIV + 1) x period_of_main_clock.</description>
	<bitRange>[31:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DMA_HOLD</name>
	<description>Hold time before DMA activated.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_CLK_DIV</name>
	<description>Clock divider that generates the pixel pipeline clock. Source clock of this divider is the format pipeline clock (see also LCDC_SEC_CLK_DIV). The period of the generated clock is defines as : LCDC_CLK_DIV x period_of_format_clk. A zero value gives division by one.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_CRC_REG</name>
	<description>CRC check</description>
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_CRC</name>
	<description>CRC check.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_DBIB_CFG_REG</name>
	<description>MIPI Config Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_DBIB_TE_DIS</name>
	<description>Disable the sampling of the tearing effect signal, which is provided by the LCD device.
0: the tearing effect signal is sampled
1: the tearing effect signal is not sampled.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_CSX_FORCE</name>
	<description>Forces the DBIB CSX value. When is enabled the DBIB CSX takes the value of the LCDC_DBIB_CSX_FORCE_VAL.
0 : disable
1 : enable</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_CSX_FORCE_VAL</name>
	<description>Value of DBIB CSX to be forced, if bit 30 is set. Defines also the active level of the DBIB CSX even if the bit 30 is not set.</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_PAD</name>
	<description>Data padding :
0 : disable
1 : enable</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_RESX</name>
	<description>DBIB RESX, reset signal for MIPI DBIB display.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_DMA_EN</name>
	<description>Send pixels from DMA to DBIB display.
0 : disable
1 : enable</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI3_EN</name>
	<description>Enable SPI3 interface.
0 : disable
1 : enable</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI4_EN</name>
	<description>Enable SPI4 interface.
0 : disable
1 : enable</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_CPHA</name>
	<description>Sets the data phase for the SPI interface</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_CPOL</name>
	<description>Sets the polarity of the clock (SCL)</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_JDI</name>
	<description>Enables the line addressing between the horizontal lines (JDI SPI output format).
0 : disable
1 : enable</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_HOLD</name>
	<description>Enables the command HOLD mode of operation. Commands and data transmissions binding.
0 : disable
1 : enable</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_SPI_INV_ADDR</name>
	<description>Enables horizontal line address inversion.
0 : disable
1 : enable</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_INV_DATA</name>
	<description>Data inversion
0 : disable
1 : enable</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_JDI_INV_PIX</name>
	<description>MSB-LSB bit selection for JDI parallel interface
0 : disable (MSB - LSB)
1 : enable (LSB -MSB)</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_JDI_SOFT_RST</name>
	<description>JDI timing generation soft reset.
0 : disable
1 : enable</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_FMT</name>
	<description>Defines the output format and depends of the type of the output interface. For the SPI3/SPI4 are supported the following formats:
0x06 : RGB111-1 {2b00, R(n), G(n), B(n), R(n+1), G(n+1), B(n+1)}
0x07 : RGB111-2 {R(n), G(n), B(n), 1b0, R(n+1), G(n+1), B(n+1), 1b0}
0x08 : RGB111-3 {R(n), G(n), B(n), R(n+1), G(n+1), B(n+1), R(n+2), G(n+2), B(n+2),... }
0x09 : RGB111-4 {D(n), D(n+1), D(n+2),...}
0x10 : RGB332
0x11 : RGB444
0x12 : RGB565
0x13 : RGB666
0x14 : RGB888

For the JDI parallel interface should be used the format :
0x0A : RGB222</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_DBIB_CMD_REG</name>
	<description>MIPI DBIB Command Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_DBIB_CMD_SEND</name>
	<description>Send command to the DBI interface</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_CMD_STORE</name>
	<description>This bit has meaning only when LCDC_DBIB_CFG_REG[LCDC_DBIB_SPI_JDI] = 1. When is enabled, stores the LCDC_DBIB_CMD_VAL to the register that keeps the Y position. </description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DBIB_CMD_VAL</name>
	<description>Data to send to the DBI interface</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_FRONTPORCHXY_REG</name>
	<description>Front Porch X and Y</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_FPORCH_X</name>
	<description>Front porch X (lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_FPORCH_Y</name>
	<description>Front porch Y (pixel clocks)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_GPIO_REG</name>
	<description>General Purpose IO (2-bits)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_TE_INV</name>
	<description>Applies an inversion on the TE (tearing effect) signal.
0 : the inversion is not applied on the TE signal
1 : the inversion is applied on TE signal</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_PARIF_SEL</name>
	<description>Selection of the parallel interface type that is forwarded to the gpio pins.
0 : JDI interface signals
1 : Clasic parallel interface</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_IDREG_REG</name>
	<description>Identification Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_ID</name>
	<description>Identification register</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_INTERRUPT_REG</name>
	<description>Interrupt Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_IRQ_TRIGGER_SEL</name>
	<description>IRQ trigger control
0: Level triggering
1: Edge triggering
In the case of the level triggering, the request remains active in the LCDC until to be cleared. The request can be cleared by performing a write access in the LCDC_INTERRUPT_REG. This is not required in the case of the edge triggering.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_FRAME_END_IRQ_EN</name>
	<description>Continuous mode: frame end. Single mode: frame end or idle.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_TE_IRQ_EN</name>
	<description>TE interrupt enable. See also the configuration bit LCDC_DBIB_CFG_REG[LCDC_DBIB_TE_DIS]</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_HSYNC_IRQ_EN</name>
	<description>HSYNC interrupt enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_VSYNC_IRQ_EN</name>
	<description>VSYNC or TE interrupt enabled. See also the configuration bit LCDC_DBIB_CFG_REG[LCDC_DBIB_TE_DIS] for the TE signal.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_ENB_END_HLINE_REG</name>
	<description>ENB end horizontal line</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_ENB_END_HLINE</name>
	<description>The number of the last horizontal line where the ENB signal is asserted</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_ENB_START_CLK_REG</name>
	<description>ENB start delay</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_ENB_START_CLK</name>
	<description>Defines the number of the HCK half periods that should take place after a transtion in the VCK and before to be enabled of the ENB. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_ENB_START_HLINE_REG</name>
	<description>ENB start horizontal line</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_ENB_START_HLINE</name>
	<description>The number of the first horizontal line where the ENB signal is asserted</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_ENB_WIDTH_CLK_REG</name>
	<description>ENB width</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_ENB_WIDTH_CLK</name>
	<description>ENB (high) width in HCK half periods</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_FBX_BLANKING_REG</name>
	<description>Horizontal front/back blanking (hck half periods)</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_FXBLANKING</name>
	<description>Horizontal front blanking as a number of hck half periods</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_JDI_BXBLANKING</name>
	<description>Horizontal back blanking as a number of hck half periods</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_FBY_BLANKING_REG</name>
	<description>Vertical front/back blanking (vck half periods)</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_FYBLANKING</name>
	<description>Vertical front blanking as a number of vck half periods</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_JDI_BYBLANKING</name>
	<description>Vertical back blanking as a number of vck half periods</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_HCK_WIDTH_REG</name>
	<description>HCK high/low width</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_HCK_WIDTH</name>
	<description>Number of format pipeline clock cycles that define the half period of the of the HCK (high and low width). The minimum allowed value is 2.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_HST_DELAY_REG</name>
	<description>VCK-to-HST delay</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_HST_DELAY</name>
	<description>VCK-to-HST delay in format pipeline clock cycles</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_HST_WIDTH_REG</name>
	<description>HST width</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_HST_WIDTH</name>
	<description>HST width in format pipeline clock cycles</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_RESXY_REG</name>
	<description>Resolution XY for the JDI parallel I/F</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_RES_X</name>
	<description>Number of horizontal transfers. Should be equal to the half of the horizontal resolution (in pixels).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_JDI_RES_Y</name>
	<description>Number of vertical transfers. Should be equal to the double of the vertical resolution (in lines). </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_VCK_DELAY_REG</name>
	<description>XRST-to-VCK delay</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_VCK_DELAY</name>
	<description>XRST-to-VCK delay in format pipeline clock cycles</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_VST_DELAY_REG</name>
	<description>XRST-to-VST delay</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_VST_DELAY</name>
	<description>XRST-to-VST delay in format pipeline clock cycles</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_VST_WIDTH_REG</name>
	<description>VST width</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_VST_WIDTH</name>
	<description>VST width in format pipeline clock cycles</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_JDI_XRST_WIDTH_REG</name>
	<description>XRST width</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_XRST_WIDTH</name>
	<description>Number of format pipeline clock cycles of XRST width</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_BASEADDR_REG</name>
	<description>Layer0 Base Addr</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_FB_ADDR</name>
	<description>Base Address of the frame buffer</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_MODE_REG</name>
	<description>Layer0 Mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_EN</name>
	<description>Enable layer.
0 : disable
1 : enable</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_COLOUR_MODE</name>
	<description>Colour Mode:
00001: 16-bit RGBX5551 color format,
00010: 32-bit RGBX8888 color format,
00100: 8-bit RGB332 color format,
00101: 16-bit RGB565 color format,
00110: 32-bit XRGB8888,
00111: L8 Grayscale/Palette format,
01000: L1 Grayscale/Palette format,
01001: L4 Grayscale/Palette format,
01101: ABGR8888,
01110: BGRA8888</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_OFFSETX_REG</name>
	<description>Layer0 OffsetX and DMA prefetch</description>
	<addressOffset>0x00000188</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_DMA_PREFETCH</name>
	<description>DMA fifo prefetch level (range: 0-4)
0x0 : Prefetch mechanism is disabled
0x1 : Prefetch at least 44 bytes
0x2 : Prefetch at least 84 bytes
0x3 : Prefetch at least 116 bytes
0x4 : Prefetch at least 108 bytes
Any other value : Reserved</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_OFFSETX</name>
	<description>Offset X (negative) of X start pixel (range [n-1,0], n : pixels /8)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_RESXY_REG</name>
	<description>Layer0 Res XY</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_RES_X</name>
	<description>Resolution X (Resolution of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_RES_Y</name>
	<description>Resolution Y (Resolution of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_SIZEXY_REG</name>
	<description>Layer0 Size XY</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_SIZE_X</name>
	<description>Size X (Size of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_SIZE_Y</name>
	<description>Size Y (Size of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_STARTXY_REG</name>
	<description>Layer0 Start XY</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_START_X</name>
	<description>Start X (offset pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_START_Y</name>
	<description>Start Y (offset pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_STRIDE_REG</name>
	<description>Layer0 Stride</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_L0_FIFO_THR</name>
	<description>Layer dma fifo threshold burst start
00: half fifo (default)
01: 2 burst size
10: 4 burst size
11: 8 burst size</description>
	<bitRange>[20:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_BURST_LEN</name>
	<description>Layer burst length
000: 16-beats (default)
001: 2-beats
010: 4-beats
011: 8-beats
100: 16-beats</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_L0_STRIDE</name>
	<description>Layer Stride (distance from line to line in bytes)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_MODE_REG</name>
	<description>Display Mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_MODE_EN</name>
	<description>Mode register.
0 : disable
1 : enable</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_VSYNC_POL</name>
	<description>VSYNC polarity.
0: positive
1: negative</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_HSYNC_POL</name>
	<description>HSYNC polarity.
0: positive
1: negative</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DE_POL</name>
	<description>DE polarity.
0: positive
1: negative</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_VSYNC_SCPL</name>
	<description>Set VSYNC for a single cycle per line.
0: disable
1: enable</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_PIXCLKOUT_POL</name>
	<description>Pixel clock out polarity.
0: positive
1: negative</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_FORCE_BLANK</name>
	<description>Forces output to blank.
0: disable
1: enable</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_SFRAME_UPD</name>
	<description>Single frame update.
0: disable
1: enable</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_PIXCLKOUT_SEL</name>
	<description>Selects the pixel out clock for the display.
0: based on the pixel pipeline clock
1: based on the format pipeline clock
See also the LCDC_CLKCTRL_REG.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_OUT_MODE</name>
	<description>Selection of the output mode
0000: Parallel RGB
1000: JDI MIP
All the other values are reserved.</description>
	<bitRange>[8:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_MIPI_OFF</name>
	<description>MIPI off. (SPI mode of MIPI standard)
0: disabled
1: enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_FORM_OFF</name>
	<description>Formating off
0: disabled
1: enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_DSCAN</name>
	<description>Double horizontal scan
0: disabled
1: enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_TMODE</name>
	<description>Test mode
0: disabled
1: enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_RESXY_REG</name>
	<description>Resolution X,Y</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_RES_X</name>
	<description>Resolution X in pixels.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_RES_Y</name>
	<description>Resolution Y in pixels.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_STATUS_REG</name>
	<description>Status Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_JDI_TIM_SW_RST</name>
	<description>JDI timing generation soft reset (active high)</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_FRAME_START</name>
	<description>Frame start (active high)</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_FRAME_END</name>
	<description>Frame end (active high)</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_DBIB_CMD_PENDING</name>
	<description>Transferring of command in progress.
0: idle
1: in progress</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_DBIB_CMD_FIFO_FULL</name>
	<description>Command fifo full indication.
0: is not full
1: is full</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_DBIB_CMD_FIFO_EMPTY_N</name>
	<description>Command fifo empty indication (negative)
0: the fifo is empty
1: the fifo is not empty</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_DBIB_TE</name>
	<description>The DBIB tearing effect signal</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_STICKY_UNDERFLOW</name>
	<description>Sticky underflow(clear with write in the LCDC_INTERRUPT_REG)
0: There is no underflow
1: Underflow has been detected.Remains high until to be cleared by performing a write access on the register LCDC_INTERRUPT_REG.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_UNDERFLOW</name>
	<description>Underflow on the current transfer.
0: There is no underflow
1: Underflow has been detected. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_LAST_ROW</name>
	<description>Last row (Last row is currently displayed)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_STAT_CSYNC</name>
	<description>CSYNC signal level</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_STAT_VSYNC</name>
	<description>VSYNC signal level</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_STAT_HSYNC</name>
	<description>HSYNC signal level</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_FRAMEGEN_BUSY</name>
	<description>The frame generator is busy (active high).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LCDC_STAT_ACTIVE</name>
	<description>Active (When not in vertical blanking)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>LRA</name>
	<version>1.0</version>
	<description>LRA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030a00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>92</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>LRA_ADC_CTRL1_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_ADC_BUSY</name>
	<description>0:ADC conversion ready.
1:ADC conversion in progress.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_ADC_OFFSET</name>
	<description>ADC offset compensation value.
Signed value with 3 fractional bits.
-16 (0x80) to +15.875 (0x7F) in intervals of 0.125 (0x01).
Note: ADC gain error must be compensated in the calculation of VREF.</description>
	<bitRange>[16:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_TEST_PARAM</name>
	<description>Select which inputs will be enabled on the ADC.
0,1 = normal inputs (i.e. both I and Q inputs connected to LRA-current-sense voltage source)
2 = I channel connected to the analog input testbus on PORTS P14 and P15, Q channel is muted.
3 =Q channel connected to the analog input testbus on PORTS P14 and P15, I channel is muted.
Note: The LRA_ADC_CTRL1_REG[ADC_MUTE] field takes precedence over this test functionality. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_TEST_IN_SEL</name>
	<description>Select analog testbus on ADC input.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_FREQ</name>
	<description>ADC clock divider</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_SIGN</name>
	<description>Change polarity of ADC input</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_MUTE</name>
	<description>0: Normal operation
1: Short the inputs of the ADC (used for DC offset cal) </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>LRA_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MAN_FLT_IN</name>
	<description>Manual value to replace the ADC output. Select its use by FLT_IN_SEL.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion as a signed value. The most significant 11 bits are always valid, the lower 5 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 32 samples results in 5 extra bits.
In the context of the LRA constant current or constant duty cycle control systems, the (non-oversampled) value is interpreted as a signed value with 7 integer bits and 3 fractional bits: -128.000 (0x8000) to +127.875 (0x7FE0) in steps of 0.125 (0x0010). 
Note that the measured values in this context are always positive.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_BRD_HS_REG</name>
	<description>LRA Bridge Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRIM_GAIN</name>
	<description>Current-sensing amplifier gain settings:
0001: x6
0010: x8
0100: x10
1000: x12</description>
	<bitRange>[14:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HSGND_TRIM</name>
	<description>HS gnd trim, default at 100
000: 2.2V and 111:3.6V with 0.2V per step</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCP_HS_TRIM</name>
	<description>HS short-circuit protection limit trimming</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCP_HS_EN</name>
	<description>HS short-circuit protection enable</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERC_HS_TRIM</name>
	<description>HS edge-rate control trimming. Lowto-High switching slewing:
00: 25 MV/s
01: 50 MV/s
10: 75 MV/s
11: 100 MV/s</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERC_HS_EN</name>
	<description>HS edge-rate control enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_BRD_LS_REG</name>
	<description>LRA Bridge Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00004fff</resetMask>
	<fields><field>
	<name>SCP_LS_TRIM_N</name>
	<description>LSN short-circuit protection limit trimming</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCP_LS_TRIM_P</name>
	<description>LSP short-circuit protection limit trimming</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCP_LS_EN</name>
	<description>LS short-circuit protection enable</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERC_LS_TRIM</name>
	<description>LS edge-rate control trimming. High-to-Low switching slewing:
00: 25 MV/s
01: 50 MV/s
10: 75 MV/s
11: 100 MV/s</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERC_LS_EN</name>
	<description>LS edge-rate control enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_BRD_STAT_REG</name>
	<description>LRA Bridge Staus Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCP_HS_OUT</name>
	<description>HS short circuit comparator output</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SCP_LS_COMP_OUT_N</name>
	<description>LSN short circuit comparator output</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SCP_LS_COMP_OUT_P</name>
	<description>LSP short circuit comparator output</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SC_EVENT_LS</name>
	<description>1: LS short-circuit event detected
0: no LS short-circuit event detected</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SC_EVENT_HS</name>
	<description>1: HS short-circuit event detected
0: no HS short-circuit event detected</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LOOP_STAT</name>
	<description>1: Loop saturation detected
0: Loop not saturated</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LSN_ON</name>
	<description>LSN control status</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LSP_ON</name>
	<description>LSP control status</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HSN_ON</name>
	<description>HSN control status</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HSP_ON</name>
	<description>HSP control status</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LSN_STAT</name>
	<description>LSN power FET gate actual status</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LSP_STAT</name>
	<description>LSP power FET gate actual status</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HSN_STAT</name>
	<description>HSN power FET gate actual status</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HSP_STAT</name>
	<description>HSP power FET gate actual status</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_CTRL1_REG</name>
	<description>General Purpose LRA Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000071c0</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SMP_IDX</name>
	<description>Current bin index (0-15). Check if equal to IRQ_IDX before and/or after updating HALF_PERIOD with ISR.</description>
	<bitRange>[27:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_SCP_EVENT_EN</name>
	<description>0 = interrupt scp event disabled
1 = interupt scp event enabled</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_ADC_EN</name>
	<description>0 = interrupt adc disabled
1 = interupt adc enabled</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_CTRL_EN</name>
	<description>0 = interrupt controller disabled
1 = interupt controller enabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_IDX</name>
	<description>At which sample index an IRQ will be generated (0-15). When IRQ_IDX &lt; 8, IRQs are generated at both half cycles (IRQ_IDX and IRQ_IDX+8), otherwise only in the second half cycle.</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_DIV</name>
	<description>Divider value of the interrupt request. Number of LRA/ERM periods, between successive IRQs. 0,1=every (half) cycle, depending on IRQ_IDX; 2=every second cycle, IRQ at the end of first or both half cycles (based on IRQ_IDX), etc.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMP_SEL</name>
	<description>Select which samples to store for the resonance control algorithm.
0=Sense voltage after down-sampling
1=Error voltage (after subtraction of VREF and down-sampled sense voltgae input)
2=Duty cycle signal after loop-filter
3=Duty cycle signal after summation with DREF</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PULLDOWN_EN</name>
	<description>LXP and LXN node pull down enbale, when SC_EVENT=0 &amp;&amp; LOOP_EN=0</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LOOP_EN</name>
	<description>0=disable loop
1=enable loop</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_EN</name>
	<description>0=lra ldo disabled
1=lra ldo enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_EN</name>
	<description>0=lra adc disabled
1=lra adc enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HBRIDGE_EN</name>
	<description>0=hbridge disabled
1=hbridge enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LRA_EN</name>
	<description>0=lra controller disabled
1=lra controller enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_CTRL2_REG</name>
	<description>General Purpose LRA Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x02710000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>HALF_PERIOD</name>
	<description>Half of the LRA period, in units of 4 ms (= 125 kHz divided by the resonant frequency of the LRA).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_MODE</name>
	<description>Automatic frequency control (0=disabled;, 1=enabled, not yet implemented)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMP_MODE</name>
	<description>Sampling mode for data aiding automatic resonance control (0=averaging, 1=last sample)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POLARITY</name>
	<description>Polarity of the square wave (0=normal; 1=inverted); Use for rapid stop.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLT_IN_SEL</name>
	<description>0 = normal operation
1 = ADC output overruled by register field MAN_FLT_IN</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWM_MODE</name>
	<description>PWM pulse placement: 0=middle, 1=left, 2=right, 3=alternate</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_CTRL3_REG</name>
	<description>General Purpose LRA Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>VREF</name>
	<description>Voltage reference for haptic feedback driver (1 bit sign + 7 bits integer + 8 bits fractional. (range -128 ... +127.99).
The voltage is computed based on the desired reference current (IREF) that flows into the haptic device.
VREF = IREF&#180;TRIM_GAIN&#180;AGC_GAIN&#180;128/2.4,
with IREF in Amperes,
TRIM_GAIN = 6, 8 (default), 10 or 12 as defined in LRA_BRD_HS_REG,
ADC_GAIN is the normalized gain of the ADC (i.e. ADC_GAIN = GP_ADC_VALUE&#180;300 mA/[ILRA&#180;128]).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREF</name>
	<description>Duty cycle reference, start value from which the current control loop settles (1 sign bit, 7 integer bits, 8 fractional bits, -128 ... +127.99). Valid settings 5% through 95% (0x0666 - 0x799A).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_DFT_REG</name>
	<description>LRA test Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPARE</name>
	<description>spare registers bits , currently not used</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWM_SEL</name>
	<description>0=use SWM from controller
1=use SWM_MAN</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWM_MAN</name>
	<description>swm manual</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWM_SEL</name>
	<description>0=use PWM from controller
1=use PWM_MAN</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWM_MAN</name>
	<description>pwm manual</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER_TRIM</name>
	<description>20ns unit delay cell trimming bits</description>
	<bitRange>[24:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER_SCALE_TRIM</name>
	<description>Selection of delay of MAG and DEMAG signal:
00: 60ns
01: 80ns
10: 100ns
11: 120ns</description>
	<bitRange>[22:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DFT_SEL</name>
	
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DFT_FORCE_HSPN</name>
	<description>Force HSP and HSN power FETs on:
0: not actived
1: HSP and HSN are forced on</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DFT_EN_TIMER</name>
	<description>Enable for the timer trimming</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DFT_STALL</name>
	<description>Force state machine in a certain state:
00: No test
01: High-Z
10: Mag
11: Demag</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DFT_CTRL</name>
	<description>Selection of test bus connection</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_COEF1_REG</name>
	<description>LRA Filter Coefficient Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x019a0e66</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FLT_COEF_01</name>
	<description>Loop filter state-space coefficient a12 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLT_COEF_00</name>
	<description>Loop filter state-space coefficient a11 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_COEF2_REG</name>
	<description>LRA Filter Coefficient Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0e660f3e</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FLT_COEF_10</name>
	<description>Loop filter state-space coefficient a21 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLT_COEF_02</name>
	<description>Loop filter state-space coefficient b1 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).
Note: For correct intended loop gain, modify the intended value of b1 to b1/ADC_GAIN, where
ADC_GAIN is the normalized gain of the ADC (i.e. ADC_GAIN = GP_ADC_VALUE&#180;300 mA/[ILRA&#180;128]).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_COEF3_REG</name>
	<description>LRA Filter Coefficient Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x16ce019a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FLT_COEF_12</name>
	<description>Loop filter state-space coefficient b2 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).
Note: For correct intended loop gain, modify the intended value of b1 to b1/ADC_GAIN, where
ADC_GAIN is the normalized gain of the ADC (i.e. ADC_GAIN = GP_ADC_VALUE&#180;300 mA/[ILRA&#180;128]).</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLT_COEF_11</name>
	<description>Loop filter state-space coefficient a22 (1 sign bit, 1 integer bit, 14 fractional bits, range -2.000 .. +1.999).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP1_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_2</name>
	<description>Second sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_1</name>
	<description>First sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP2_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_4</name>
	<description>Fourth sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_3</name>
	<description>Third sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP3_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_6</name>
	<description>Sixth sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_5</name>
	<description>Fifth sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP4_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_8</name>
	<description>Eighth sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_7</name>
	<description>Seventh sample in first half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP5_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_10</name>
	<description>Second sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_9</name>
	<description>First sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP6_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_12</name>
	<description>Fourth sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_11</name>
	<description>Third sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP7_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_14</name>
	<description>Sixth sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_13</name>
	<description>Fifth sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_FLT_SMP8_REG</name>
	<description>LRA Sample Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LRA_SMP_16</name>
	<description>Eighth sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LRA_SMP_15</name>
	<description>Seventh sample in second half-cycle used for resonance control algorithm.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LRA_LDO_REG</name>
	<description>LRA LDO Regsiter</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LDO_OK</name>
	<description>0: LDO not yet ok
1: LDO voltage is ready</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_TST</name>
	<description>When set to 1, LDO output is connected to the testbus through a test switch</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD</name>
	<description>0: Indicates that the reference input is tracked,
1: Indicates that the reference input is sampled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MEMCTRL</name>
	<version>1.0</version>
	<description>MEMCTRL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>128</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BUSY_RESET_REG</name>
	<description>BSR Reset Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_MOTOR</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BUSY_SET_REG</name>
	<description>BSR Set Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_MOTOR</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>writeOnce</access>
	</field></fields>
</register><register>
	<name>BUSY_STAT_REG</name>
	<description>BSR Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_MOTOR</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CMI_CODE_BASE_REG</name>
	<description>CMAC code Base Address Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_CODE_BASE_ADDR</name>
	<description>Base address for CMAC code with steps of 1 kB.
0x001: 1 kB base address
0x010: 16 kB base address
0x100: 256 kB base address</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_DATA_BASE_REG</name>
	<description>CMAC data Base Address Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_DATA_BASE_ADDR</name>
	<description>Base address for CMAC data with steps of 4 bytes.
0x00001: 4 byte base address
0x00010: 64 byte base address
0x00100: 1 kB base address
0x01000: 16 kB base address
0x10000: 256 kB base address</description>
	<bitRange>[18:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_END_REG</name>
	<description>CMAC end Address Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0007ffff</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_END_ADDR</name>
	<description>End address for CMAC code and data accesses with steps of 1 kB.
0x000: accesses up to 1kB are allowed
0x001: accesses up to 2kB are allowed
0x01F: accesses up to 32kB are allowed
0x1FF: accesses up to 512kB are allowed</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_SHARED_BASE_REG</name>
	<description>CMAC shared data Base Address Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_SHARED_BASE_ADDR</name>
	<description>Base address for CMAC shared data with steps of 1 kB.
0x001: 1 kB base address
0x010: 16 kB base address
0x100: 256 kB base address</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_PRIO_REG</name>
	<description>Priority Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>AHB_PRIO</name>
	<description>Priority for the AHB interface.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB2_PRIO</name>
	<description>Priority for the AHB2 interface.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_PRIO</name>
	<description>Priority for the SNC interface.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STALL_REG</name>
	<description>Maximum Stall cycles Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>AHB_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the AHB interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB2_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the AHB2 interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the SNC interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS2_REG</name>
	<description>RAM cells Status Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>RAM8_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM8 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM7_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM7 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM6_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM6 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM5_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM5 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM4_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM4 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM3_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM3 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM2 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM1 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS_REG</name>
	<description>Memory Arbiter Status Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>CMI_CLEAR_READY</name>
	<description>Writing a '1' clears CMI_NOT_READY bit.</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CMI_NOT_READY</name>
	<description>0: Normal operation
1: CMI access performed which couldn't be handled right away (interface doesn't allow wait cycles)</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB2_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an AHB2 access has been buffered.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an AHB access has been buffered.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB2_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB2_WR_BUFF_CNT.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_WR_BUFF_CNT.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB2_WRITE_BUFF</name>
	<description>0: No AHB2 write access is buffered.
1: Currently a single AHB2 write access is buffered in the arbiter.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_WRITE_BUFF</name>
	<description>0: No AHB write access is buffered.
1: Currently a single AHB write access is buffered in the arbiter.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SNC_BASE_REG</name>
	<description>Sensor Node Controller Base Address Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>SNC_BASE_ADDRESS</name>
	<description>Base address for SNC interface with steps of 4 bytes.
0x00001: 4 byte base address
0x00010: 64 byte base address
0x00100: 1 kB base address
0x01000: 16 kB base address
0x10000: 256 kB base address</description>
	<bitRange>[18:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>OTPC</name>
	<version>1.0</version>
	<description>OTPC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30070000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>OTPC_MODE_REG</name>
	<description>Mode register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_MODE_PRG_SEL</name>
	<description>Defines the part of the OTP cell that is programmed by the controller during the PROG mode, for each program request that is applied.
0x0 : Both normal and redundancy arrays are programmed. This is the normal way of programming.
0x1 : Only the normal array is programmed.
0x2 : Only the redundancy array is programmed.
0x3 : Reserved
The value of this configuration field can be modified only when the controller is in an inactive mode (PDOWN, DSTBY, STBY). The setting will take effect when will be enabled again the PROG mode.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_HT_MARG_EN</name>
	<description>Defines the temperature condition under which is performed a margin read. It affects only the initial margin read (RINI mode) and the programming verification margin read (PVFY).
0 : Regular temperature condition (less than 85&#176;C)
1 : High temperature condition (85&#176;C or more)
The value of this configuration field can be modified only when the controller is in an inactive mode (PDOWN, DSTBY, STBY). The selection will take effect at the next PVFY or RINI mode that will be enabled. The READ mode is not affected by the setting of this configuration bit.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_USE_TST_ROW</name>
	<description>Selects the memory area of the OTP cell that will be used.
0 - Uses the main memory area of the OTP cell
1 - Uses the test row of the OTP cell
The value of this configuration field can be modified only when the controller is in an inactive mode (PDOWN, DSTBY, STBY). The selection will take effect at the next programming or reading mode that will be enabled.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_MODE</name>
	<description>Defines the mode of operation of the OTPC controller. The encoding of the modes is as follows:
0x0: PDOWN. The power supply of the OTP memory is OFF.
0x1: DSTBY. The OTP memory is in deep standby mode (power supply ON and internal LDO OFF).
0x2: STBY. The OTP memory is powered (power supply ON and internal LDO ON, but is not selected.
0x3: READ. The OTP memory is in the normal read mode.
0x4: PROG. The OTP memory is in programming mode.
0x5: PVFY. The OTP memory is in programming verification mode (margin read after programming).
0x6: RINI. The OTP memory is in initial read mode (initial margin read).
0x7: Reserved.

Whenever the OTPC_MODE_REG[MODE] is changing, the status bit OTPC_STAT_REG[OTPC_STAT_MRDY] gets the value zero. The new mode will be ready for use when the OTPC_STAT_MRDY become again 1. During the mode transition the OTPC_MODE_REG[MODE] become read only. Do not try to use or change any function of the controller until the OTPC_STAT_MRDY bit to become equal to 1.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PADDR_REG</name>
	<description>The address of the word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PADDR</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTPC_PADDR_REG refers to a word address. The OTPC_PADDR_REG has to be writen after the OTP_PWORD_REG and only if the OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). A writting to the OTPC_PADDR_REG triggers the controller to start the programming procedure (only if the PROG mode is active).</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PWORD_REG</name>
	<description>The 32-bit word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PWORD</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP memory, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTP_PWORD_REG must be written before the OTPC_PADDR_REG and only if OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY] = 1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_STAT_MRDY</name>
	<description>Indicates the progress of the transition from a mode of operation to a new mode of operation.
0 : There is a transition in progress in a new mode of operation . Wait until the transition to be completed.
1 : The transition to the new mode of operation has been completed. The function that has been enabled by the new mode can be used. A new mode can be applied.
This status bit gets the value zero every time where the OTPC_MODE_REG[MODE] is changing. Do not try to use or change any function of the controller until this status bit to becomes equal to 1.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PBUF_EMPTY</name>
	<description>Indicates the status of the programming buffer (PBUF).
0 : The PBUF contains the address and the data of a programming request. The OTPC_PADDR_REG and the OTPC_PWORD_REG should not be written as long as this status bit is zero.
1 : The PBUF is empty and a new programming request can be registered in the PBUF by using the OTPC_PADDR_REG and the OTPC_PWORD_REG registers.
This status bit gets the value zero every time where a progrmaming is triggered by the OTPC_PADDR_REG (only if the PROG mode is active).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PRDY</name>
	<description>Indicates the state of the programming process.
0: The controller is busy. A programming is in progress.
1: The logic which performs programming is idle.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM1_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0999101f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM1_US_T_CSP</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for programming. It must be :
- at least 10us
- no more than 100us</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_CS</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for any kind of read. It must be at least 10us.</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_PL</name>
	<description>The number of microseconds (minus one) that are required until to be enabled the LDO of the OTP. It must be at least 10us.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_RD</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 60ns. This timing parameter refers to the access time of the OTP memory.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_20NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval that is at least higher than 20 ns.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_1US</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval equal to 1us. This setting affects all the timing parameters that refer to microseconds, due to that defines the correspondence of a microsecond to a number of hclk_c clock cycles.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM2_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM2_US_ADD_CC_EN</name>
	<description>Adds an additional hclk_c clock cycle at all the time intervals that count in microseconds.
0 : The extra hclk_c clock cycle is not applied
1 : The extra hclk_c clock cycle is applied</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_SAS</name>
	<description>The number of microseconds (minus one) that are required after the exit from the deep sleep standby mode and before to become ready to enter in an active mode (reading or programming). It must be at least 2us.</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPH</name>
	<description>The number of microseconds (minus one) that are required after the last programming pulse and before to be disabled the programming mode in the OTP memory. It must be:
- at least 5us
- no more than 20us</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_VDS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the power supply of the OTP memory and before to become ready for the enabling of the internal LDO. It must be at least 1us.</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the programming in the OTP memory and before to be applied the first programming pulse. It must be :
- at least 5us
- no more than 20us</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPR</name>
	<description>The number of microseconds (minus one) for recovery after a programming sequence. It must be :
- at least 5us
- no more than 100us</description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PWI</name>
	<description>The number of microseconds (minus one) between two consecutive programming pulses. It must be :
- at least 1us
- no more than 5us</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PW</name>
	<description>The number of microseconds (minus one) that lasts the programming of each bit. It must be :
- at least 10us
- no more than 20us</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PDC</name>
	<version>1.0</version>
	<description>PDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>152</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PDC_ACKNOWLEDGE_REG</name>
	<description>Clear a pending PDC bit</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>PDC_ACKNOWLEDGE</name>
	<description>Writing to this field acknowledges the PDC IRQ request.
The data controls which request is acknowledged</description>
	<bitRange>[4:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL0_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>Selects which individual bit from the selected bank is used for wakup.
For the peripheral banks, selected with TRIG_SELECT = 0x2 or 0x3, only the lower 4 bits are considered.</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>Selects which bank is used as wakeup trigger
When TRIG_SELECT is 0x0, selects GPIO port0 through the WAKEUP block.
When TRIG_SELECT is 0x1, selects GPIO port1 through the WAKEUP block.
When TRIG_SELECT is 0x2 or 0x3, selects the peripheral IRQ.

peripheral IRQ table:
0x0: Timer
0x1: Timer2
0x2: Timer3
0x3: Timer4
0x4: RTC Alarm/Rollover
0x5: RTC Timer
0x6: CMAC Timer OR wake up from CMAC debugger
0x7: Motor Controller
0x8: XTAL32MRDY_IRQ
0x9: RFDIAG_IRQ
0xA: CMAC2SYS_IRQ OR VBUS Present IRQ OR JTAG present OR Debounced IO
0xB: Sensor Node Controller
0xC to 0xE: reserved
0xF: Software trigger only
</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL10_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL11_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL12_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL13_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL14_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL15_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL1_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL2_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>IIf set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL3_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL4_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL5_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL6_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL7_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL8_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL9_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: PD_COM is woken up and SNC is triggered</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. This bit is implied when PDC_MASTER=SNC</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_CM33_REG</name>
	<description>Shows any pending IRQ to CM33</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending towards the CM33</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_CMAC_REG</name>
	<description>Shows any pending IRQ to CM33</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending towards the CMAC</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_REG</name>
	<description>Shows any pending wakup event</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_SNC_REG</name>
	<description>Shows any pending IRQ to SNC</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending towards the SensorNodeController</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_SET_PENDING_REG</name>
	<description>Set a pending PDC bit</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>PDC_SET_PENDING</name>
	<description>Writing to this field sets the PDC wakeup request and IRQ.
The data controls which request is acknowledged</description>
	<bitRange>[4:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PWMLED</name>
	<version>1.0</version>
	<description>PWMLED registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PWMLED_CTRL_REG</name>
	<description>PWM Control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>LED2_LOAD_SEL</name>
	<description>Defines LED2 output current: 2.5mA + (LED2_LOAD_SEL*2.5mA). Max = 20mA.</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED1_LOAD_SEL</name>
	<description>Defines LED1 output current: 2.5mA + (LED1_LOAD_SEL*2.5mA). Max = 20mA.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED2_EN</name>
	<description>0 = LED2 disabled
1 = LED2 enabled</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED1_EN</name>
	<description>0 = LED1 disabled
1 = LED1 enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED_TRIM</name>
	<description>LED current trimming bits</description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_PAUSE_EN</name>
	<description>0 = PWM are not blocked by SW
1 = PWM 1 and 2 are paused </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWM_ENABLE</name>
	<description>0 = PWM 1,2 are disabled
1 = PWM 1,2 are enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWMLED_DUTY_CYCLE_LED1_REG</name>
	<description>Defines duty cycle for PWM1</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LED1_PWM_START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED1_PWM_END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWMLED_DUTY_CYCLE_LED2_REG</name>
	<description>Defines duty cycle for PWM2</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LED2_PWM_START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED2_PWM_END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWMLED_FREQUENCY_REG</name>
	<description>Defines the PWM frequecny</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>LED_PWM_FREQUENCY</name>
	<description>Defines the frequency of PWM 1 2, period = PWM_CLK * ( FREQ+1)</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QSPIC</name>
	<version>1.0</version>
	<description>QSPIC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x38000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>180</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>QSPIC_BURSTBRK_REG</name>
	<description>Read break sequence in Auto mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_SEC_HF_DS</name>
	<description>Disable output during the transmission of the second half (QSPIC_BRK_WRD[3:0]). Setting this bit is only useful if QSPIC_BRK_EN =1 and QSPIC_BRK_SZ= 1.
0: The controller drives the QSPI bus during the transmission of the QSPIC_BRK_WRD[3:0].
1: The controller leaves the QSPI bus in Hi-Z during the transmission of the QSPIC_BRK_WORD[3:0].</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the burst break sequence.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_SZ</name>
	<description>The size of Burst Break Sequence
0: One byte (Send QSPIC_BRK_WRD[15:8])
1: Two bytes (Send QSPIC_BRK_WRD[15:0])</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_EN</name>
	<description>Controls the application of a special command (read burst break sequence) that is used in order to force the device to abandon the continuous read mode.
0: The special command is not applied
1: The special command is applied

This special command is applied by the controller to the external device under the following conditions:
- the controller is in Auto mode
- the QSPIC_INST_MD = 1
- the previous command that has been applied in the external device was read
- the controller want to apply to the external device a command different than the read.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_WRD</name>
	<description>This is the value of a special command (read burst break sequence) that is applied by the controller to the external memory device, in order to force the memory device to abandon the continuous read mode.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDA_REG</name>
	<description>The way of reading in Auto mode (command register A)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Dummy bytes phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Extra Byte phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ADR_TX_MD</name>
	<description>It describes the mode of the SPI bus during the address phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_TX_MD</name>
	<description>It describes the mode of the SPI bus during the instruction phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE</name>
	<description>The value of an extra byte which will be transferred after address (only if QSPIC_EXT_BYTE_EN= 1). Usually this is the Mode Bits in Dual/Quad SPI I/O instructions.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_WB</name>
	<description>IInstruction Value for Wrapping Burst. This value is the selected instruction when QSPIC_WRAP_MD is equal to 1 and the access is a wrapping burst of length and size described by the bit fields QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST</name>
	<description>Instruction Value for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported (QSPIC_WRAP_MD)</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDB_REG</name>
	<description>The way of reading in Auto mode (command register B)</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_FORCE</name>
	<description>By setting this bit, the number of dummy bytes is forced to be equal to 3. In this case the QSPIC_DMY_NUM field is overruled and has no function.
0: The number of dummy bytes is controlled by the QSPIC_DMY_NUM field
1: Three dummy bytes are used. The QSPIC_DMY_NUM is overruled.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CS_HIGH_MIN</name>
	<description>Between the transmissions of two different instructions to the flash memory, the SPI bus stays in idle state (QSPI_CS high) for at least this number of QSPI_SCK clock cycles. See the QSPIC_ERS_CS_HI register for some exceptions.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_SIZE</name>
	<description>It describes the selected data size of a wrapping burst (QSPIC_WRAP_MD).
0x0: byte access (8-bits)
0x1: half word access (16 bits)
0x2: word access (32-bits)
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_LEN</name>
	<description>It describes the selected length of a wrapping burst (QSPIC_WRAP_MD).
0x0: 4 beat wrapping burst
0x1: 8 beat wrapping burst
0x2: 16 beat wrapping burst
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_MD</name>
	<description>Wrap mode
0: The QSPIC_INST is the selected instruction at any access.
1: The QSPIC_INST_WB is the selected instruction at any wrapping burst access of length and size described by the registers QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively. In all other cases the QSPIC_INST is the selected instruction. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_MD</name>
	<description>Instruction mode
0: Transmit instruction at any burst access.
1: Transmit instruction only in the first access after the selection of Auto Mode.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DMY_NUM</name>
	<description>Number of Dummy Bytes

0x0: Zero Dummy Bytes (Don't Send Dummy Bytes)
0x1: Send 1 Dummy Byte
0x2: Send 2 Dummy Bytes
0x3: Send 4 Dummy Bytes

When QSPIC_DMY_FORCE is enabled, the QSPIC_DMY_NUM is overruled. In this case the number of dummy bytes is defined by the QSPIC_DMY_FORCE and is equal to 3, independent of the value of the QSPIC_DMY_NUM.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_HF_DS</name>
	<description>Extra Half Disable Output
0: if QSPIC_EXT_BYTE_EN=1, is transmitted the complete QSPIC_EXT_BYTE
1: if QSPIC_EXT_BYTE_EN=1, the output is disabled (hi-z) during the transmission of bits [3:0] of QSPIC_EXT_BYTE</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE_EN</name>
	<description>Extra Byte Enable
0: Don't Send QSPIC_EXT_BYTE
1: Send QSPIC_EXT_BYTE</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DAT_RX_MD</name>
	<description>It describes the mode of the SPI bus during the data phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CHCKERASE_REG</name>
	<description>Check erase progress in Auto mode</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CHCKERASE</name>
	<description>Writing any value to this register during erasing, forces the controller to read the flash memory status register. Depending on the value of the Busy bit, it updates the QSPIC_ERASE_EN.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTRLBUS_REG</name>
	<description>SPI Bus control register for the Manual mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DIS_CS</name>
	<description>Write 1 to disable the chip select (active low) when the controller is in Manual mode.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_EN_CS</name>
	<description>Write 1 to enable the chip select (active low) when the controller is in Manual mode. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_QUAD</name>
	<description>Write 1 to set the bus mode in Quad mode when the controller is in Manual mode.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_DUAL</name>
	<description>Write 1 to set the bus mode in Dual mode when the controller is in Manual mode.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_SINGLE</name>
	<description>Write 1 to set the bus mode in Single SPI mode when the controller is in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTRLMODE_REG</name>
	<description>Mode Control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_USE_32BA</name>
	<description>Controls the length of the address that the external memory device uses.
0: The external memory device uses 24 bits address.
1: The external memory device uses 32 bits address.
The controller uses this bit in order to decide the number of the address bytes that has to transfer to the external device during Auto mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUF_LIM_EN</name>
	<description>This bit has meaning only for the read in auto mode. Defines the behavior of the controller when the internal buffer is full and there are more data to be retrieved for the current burst.
0: The access in the flash device is not terminated when the internal buffer has no empty space. In this case the QSPI_SCK clock is blocked until to free space in the internal buffer.
1: The access in the flash device is terminated when the internal buffer has no empty space. A new access in the flash device will be initiated when will be requested addresses that are not present in the internal buffer.
In both cases the access in the flash device is terminated when there is no any read request.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PCLK_MD</name>
	<description>Read pipe clock delay relative to the falling edge of QSPI_SCK.
Refer to QSPI Timing for timing parameters and recommended values: 0 to 7</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RPIPE_EN</name>
	<description>Controls the use of the data read pipe.
0: The read pipe is disabled; the sampling clock is defined according to the QSPIC_RXD_NEG setting.
1: The read pipe is enabled. The delay of the sampling clock is defined according to the QSPI_PCLK_MD setting. (Recommended)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RXD_NEG</name>
	<description>Defines the clock edge that is used for the capturing of the received data, when the read pipe is not active (QSPIC_RPIPE_EN = 0).

0: Sampling of the received data with the positive edge of the QSPI_SCK
1: Sampling of the received data with the negative edge of the QSPI_SCK

The internal QSPI_SCK clock that is used by the controller for the capturing of the received data has a skew in respect of the QSPI_SCK that is received by the external memory device. In order to be improved the timing requirements of the read path, the controller supports a read pipe register with programmable clock delay. See also the QSPIC_RPIPE_EN register.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_HRDY_MD</name>
	<description>This configuration bit is useful when the frequency of the QSPI clock is much lower than the clock of the AMBA bus, in order to not locks the AMBA bus for a long time.

0: Adds wait states via hready signal when an access is performed on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. It is not needed to checked the QSPIC_BUSY of the QSPIC_STATUS_REG.
1: The controller don't adds wait states via the hready signal, when is performed access on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. The QSPIC_BUSY bit of the QSPIC_STATUS_REG must be checked in order to be detected the completion of the requested access.

It is applicable only when the controller is in Manual mode. In the case of the Auto mode, the controller always adds wait states via the hready signal.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_DAT</name>
	<description>The value of QSPI_IO3 pad if QSPI_IO3_OEN is 1</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_DAT</name>
	<description>The value of QSPI_IO2 pad if QSPI_IO2_OEN is 1</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_OEN</name>
	<description>QSPI_IO3 output enable. Use this only in SPI or Dual SPI mode to control /HOLD signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO3 pad is input.
1: The QSPI_IO3 pad is output.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_OEN</name>
	<description>QSPI_IO2 output enable. Use this only in SPI or Dual SPI mode to control /WP signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO2 pad is input.
1: The QSPI_IO2 pad is output.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CLK_MD</name>
	<description>Mode of the generated QSPI_SCK clock
0: Use Mode 0 for the QSPI_CLK. The QSPI_SCK is low when QSPI_CS is high.
1: Use Mode 3 for the QSPI_CLK. The QSPI_SCK is high when QSPI_CS is high.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_AUTO_MD</name>
	<description>Mode of operation
0: The Manual Mode is selected.
1: The Auto Mode is selected.
During an erasing the QSPIC_AUTO_MD goes in read only mode (see QSPIC_ERASE_EN)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_CTRL_REG</name>
	<description>Control register for the decryption engine of the QSPIC</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>QSPIC_CTR_EN</name>
	<description>Controls the AES-CTR decryption feature of the QSPIC, which enables the decryption (on-the-fly) of the data that are retrieved from the flash memory device.
0: The AES-CTR decryption is disabled.
1: The controller will decrypt the content of the flash memory device that is placed in the address space that is defined by the QSPIC_CTR_SADDR_REG and QSPIC_CTR_EADDR_REG registers. The data that are placed outside the previous space are not decrypted by the QSPIC. The decryption is performed by using the AES-CTR algorithm. The AES key is defined by the QSPIC_CTR_KEY_x_y_REG registers and the nonce value by the QSPIC_CTR_NONCE_x_y_REG registers.
This configuration bit has meaning only while the controller is in Auto mode. The on-the-fly decryption is not provided in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_EADDR_REG</name>
	<description>End address of the encrypted content in the QSPI flash</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000003ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_EADDR</name>
	<description>Defines the bits [31:10] of the end address in the flash memory, where an encrypted image is placed. The bits [9:0] are considered always as 0x3ff. This has meaning only when the decryption is active. See also the register QSPIC_CTR_CTRL_REG[QSPIC_CTR_EN].</description>
	<bitRange>[31:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_0_3_REG</name>
	<description>Key bytes 0 to 3 for the AES-CTR algorithm</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_0_3</name>
	<description>Defines the key that is used by the AES-CTR algorithm, when the on-the-fly decryption is enabled ( QSPIC_CTR_CTRL_REG[QSPIC_CTR_EN] = 1 ). The size of the decryption key is 256bits or 32 bytes :

K0 K1 K2 K3...K30 K31.

The mapping of the bytes to the corresponding QSPIC_CTR_KEY_X_Y_REG regisers is the following :

{K0, K1, K2, K3} = QSPIC_CTR_KEY_0_3_REG[31:0]
{K4, K5, K6, K7} = QSPIC_CTR_KEY_4_7_REG[31:0]
{K8, K9, K10, K11} = QSPIC_CTR_KEY_8_11_REG[31:0]
{K12, K13, K14, K15} = QSPIC_CTR_KEY_12_15_REG[31:0]
{K16, K17, K18, K19} = QSPIC_CTR_KEY_16_19_REG[31:0]
{K20, K21, K22, K23} = QSPIC_CTR_KEY_20_23_REG[31:0]
{K24, K25, K26, K27} = QSPIC_CTR_KEY_24_27_REG[31:0]
{K28, K29, K30, K31} = QSPIC_CTR_KEY_28_31_REG[31:0]

All these registers make sense only when QSPIC_CTR_CTRL_REG[QSPIC_CTR_EN] = 1. Do not perform access to an encrypted address range while the updating process of the decryption key is in progress.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_12_15_REG</name>
	<description>Key bytes 12 to 15 for the AES-CTR algorithm</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_12_15</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_16_19_REG</name>
	<description>Key bytes 16 to 19 for the AES-CTR algorithm</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_16_19</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_20_23_REG</name>
	<description>Key bytes 20 to 23 for the AES-CTR algorithm</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_20_23</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_24_27_REG</name>
	<description>Key bytes 24 to 27 for the AES-CTR algorithm</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_24_27</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_28_31_REG</name>
	<description>Key bytes 28 to 31 for the AES-CTR algorithm</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_28_31</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_4_7_REG</name>
	<description>Key bytes 4 to 7 for the AES-CTR algorithm</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_4_7</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_KEY_8_11_REG</name>
	<description>Key bytes 8 to 11 for the AES-CTR algorithm</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_KEY_8_11</name>
	<description>See the description in the QSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_NONCE_0_3_REG</name>
	<description>Nonce bytes 0 to 3 for the AES-CTR algorithm</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_NONCE_0_3</name>
	<description>Defines the 8 bytes of the nonce value (N0 - N7) that is used by the AES-CTR algorithm in order to be constructed the counter block (CTRB). The total size of the counter block is 128 bits or 16 bytes :

CTRB0 CTRB1 CTRB2 CTRB3...CTRB14 CTRB15.

The first 8 bytes (CTRB0 - CTRB7) of the counter block consisted by the nonce value.
The next 8 bytes of the counter block (CTRB8-CTRB15), are produced automatically by the hardware based on the address offset inside the encrypted image, from where are retrieved the requested data.
The mapping of the nonce bytes to the corresponding QSPIC_NONCE_X_Y_REG registers is the following :

{CTRB0, CTRB1, CTRB2, CTRB3} = {N0, N1, N2, N3} = QSPIC_NONCE_0_3_REG[31:0]
{CTRB4, CTRB5, CTRB6, CTRB7} = {N4, N5, N6, N7} = QSPIC_NONCE_4_7_REG[31:0]

All these registers make sense only when QSPIC_CTR_CTRL_REG[QSPIC_CTR_EN] = 1.Do not perform access to an encrypted address range while the updating process of the nonce value is in progress.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_NONCE_4_7_REG</name>
	<description>Nonce bytes 4 to 7 for the AES-CTR algorithm</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_NONCE_4_7</name>
	<description>See the description in the QSPIC_NONCE_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTR_SADDR_REG</name>
	<description>Start address of the encrypted content in the QSPI flash</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CTR_SADDR</name>
	<description>Defines the bits [31:10] of the start address in the flash memory, where an encrypted image is placed. The bits [9:0] are considered always as zero. This has meaning only when the decryption is active. See also the register QSPIC_CTR_CTRL_REG[QSPIC_CTR_EN].</description>
	<bitRange>[31:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_DUMMYDATA_REG</name>
	<description>Send dummy clocks to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DUMMYDATA</name>
	<description>Writing to this register generates a number of clock pulses to the SPI bus. During the last clock of this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. The data size of the access to this register can be 32-bits / 16-bits/ 8-bits. The number of generated pulses is equal to: (size of AHB bus access) / (size of SPI bus). The size of SPI bus is equal to 1, 2 or 4 for Single, Dual or Quad SPI mode respectively.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECMDA_REG</name>
	<description>The way of erasing in Auto mode (command register A)</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RES_INST</name>
	<description>The code value of the erase resume instruction</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_INST</name>
	<description>The code value of the erase suspend instruction.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_INST</name>
	<description>The code value of the write enable instruction.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_INST</name>
	<description>The code value of the erase instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECMDB_REG</name>
	<description>The way of erasing in Auto mode (command register B)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RESSUS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the previous erase resume command (or the initial erase command).
0: Dont wait. The controller starts immediately to suspend the erase procedure.
1..63: The controller waits for at least this number of 222kHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume command (or the initial erase command)</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERSRES_HLD</name>
	<description>The controller must stay without flash memory reading requests for this number of AMBA hclk clock cycles, before to perform the command of erase or erase resume
15 - 0</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_CS_HI</name>
	<description>After the execution of instructions: write enable, erase, erase suspend and erase resume, the QSPI_CS remains high for at least this number of qspi bus clock cycles.</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EAD_TX_MD</name>
	<description>The mode of the QSPI Bus during the address phase of the erase instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RES_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the resume instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the suspend instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the write enable instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_TX_MD</name>
	<description>The mode of the QSPI Bus during the instruction phase of the erase instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECTRL_REG</name>
	<description>QSPI Erase control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_ERS_STATE</name>
	<description>It shows the progress of sector/block erasing (read only).
0x0: No Erase.
0x1: Pending erase request
0x2: Erase procedure is running
0x3: Suspended Erase procedure
0x4: Finishing the Erase procedure
0x5..0x7: Reserved</description>
	<bitRange>[27:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QSPIC_ERASE_EN</name>
	<description>During Manual mode (QSPIC_AUTO_MD = 0). This bit is in read only mode.
During Auto mode (QSPIC_AUTO_MD = 1). To request the erasing of the block/sector (QSPIC_ERS_ADDR, 12'b0) write 1 to this bit. This bit is cleared automatically with the end of the erasing. Until the end of erasing the QSPIC_ERASE_EN remains in read only mode. During the same period of time the controller remains in Auto Mode (QSPIC_AUTO_MD goes in read only mode).</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_ADDR</name>
	<description>Defines the address of the block/sector that is requested to be erased.
If QSPIC_USE_32BA = 0 (24 bits addressing), bits QSPIC_ERASECTRL_REG[23-12] determine the block/ sector address bits [23-12].
QSPIC_ERASECTRL_REG[11-4] are ignored by the controller.
If QSPIC_USE_32BA = 1 (32 bits addressing) bits QSPIC_ERASECTRL_REG[23-4] determine the block / sectors address bits [31:12]</description>
	<bitRange>[23:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_GP_REG</name>
	<description>QSPI General Purpose control register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>QSPIC_PADS_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PADS_DRV</name>
	<description>QSPI pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_READDATA_REG</name>
	<description>Read data from SPI Bus for the Manual mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_READDATA</name>
	<description>A read access at this register generates a data transfer from the external memory device to the QSPIC controller. The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits / 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_RECVDATA_REG</name>
	<description>Received data for the Manual mode</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RECVDATA</name>
	<description>This register contains the received data when the QSPIC_READDATA_REG register is used in Manual mode, in order to be retrieved data from the external memory device and QSPIC_HRDY_MD=1 &amp;&amp; QSPIC_BUSY=0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_STATUSCMD_REG</name>
	<description>The way of reading the status of external device in Auto mode</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_STSDLY_SEL</name>
	<description>Defines the timer which is used to count the delay that it has to wait before to read the FLASH Status Register, after an erase or an erase resume command.
0: The delay is controlled by the QSPIC_RESSTS_DLY which counts on the qspi clock.
1: The delay is controlled by the QSPIC_RESSUS_DLY which counts on the 222 kHz clock.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RESSTS_DLY</name>
	<description>Defines a timer that counts the minimum required delay between the reading of the status register and of the previous erase or erase resume instruction.
0: Dont wait. The controller starts to reading the Flash memory status register immediately.
1..63: The controller waits for at least this number of QSPI_CLK cycles and afterwards it starts to reading the Flash memory status register. The timer starts to count after the end of the previous erase or erase resume command.

The actual timer that will be used by the controller before the reading of the Flash memory status register is defined by the QSPIC_STSDLY_SEL.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_VAL</name>
	<description>Defines the value of the Busy bit which means that the flash is busy.
0: The flash is busy when the Busy bit is equal to 0.
1: The flash is busy when the Busy bit is equal to 1.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_POS</name>
	<description>It describes who from the bits of status represents the Busy bit (7 - 0).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_RX_MD</name>
	<description>The mode of the QSPI Bus during the receive status phase of the read status instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_TX_MD</name>
	<description>The mode of the QSPI Bus during the instruction phase of the read status instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_INST</name>
	<description>The code value of the read status instruction.
It is transmitted during the instruction phase of the read status instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_STATUS_REG</name>
	<description>The status register of the QSPI controller</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_BUSY</name>
	<description>The status of the SPI Bus.

0: The SPI Bus is idle
1: The SPI Bus is active. Read data, write data or dummy data activity is in progress.

Has meaning only in Manual mode and only when QSPIC_HRDY_MD = 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_UCODE_START</name>
	<description>QSPIC uCode memory</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_UCODE_X</name>
	<description>The controller has a dedicated memory cell of 16 words x 32 bits that is used for the storing of the microcode that describes the initialization process of the external flash device. The first word (word 0) of this memory can be accessed by accessing the QSPIC_UCODE_START register. The next words can be accessed by accessing the QSPIC_UCODE_START + 4*X (X=1 .. 15).</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_WRITEDATA_REG</name>
	<description>Write data to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_WRITEDATA</name>
	<description>Writing to this register is generating a data transfer from the controller to the external memory device. The data written in this register, is then transferred to the memory using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits/ 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QSPIC2</name>
	<version>1.0</version>
	<description>QSPIC2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x34000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>72</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>QSPIC2_AWRITECMD_REG</name>
	<description>The way of writing in Auto mode when the external device is a serial SRAM</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_WR_CS_HIGH_MIN</name>
	<description>After the execution of the write command, the QSPI_CS remains high for at least this number of QSPI_SCK clock cycles.</description>
	<bitRange>[18:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_DAT_TX_MD</name>
	<description>The mode of the SPI Bus during the data phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_ADR_TX_MD</name>
	<description>The mode of the SPI Bus during the adress phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_INST_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_INST</name>
	<description>This is the value of the instruction that is used, in order to be programmed the external SRAM device.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_BURSTBRK_REG</name>
	<description>Read break sequence in Auto mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_SEC_HF_DS</name>
	<description>Disable output during the transmission of the second half (QSPIC_BRK_WRD[3:0]). Setting this bit is only useful if QSPIC_BRK_EN =1 and QSPIC_BRK_SZ= 1.
0: The controller drives the SPI bus during the transmission of the QSPIC_BRK_WRD[3:0].
1: The controller leaves the SPI bus in Hi-Z during the transmission of the QSPIC_BRK_WORD[3:0].</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the read break sequence.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_SZ</name>
	<description>The size of the read break sequence.
0: One byte (Send QSPIC_BRK_WRD[15:8])
1: Two bytes (Send QSPIC_BRK_WRD[15:0])</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_EN</name>
	<description>Controls the application of a special command (read break sequence) that is used in order to force the device to abandon the continuous read mode.
0: The special command is not applied
1: The special command is applied

This special command is applied by the controller to the external device under the following conditions:
- the controller is in Auto mode
- the QSPIC_INST_MD = 1
- the previous command that has been applied in the external device was read
- the controller want to apply to the external device a command different than the read.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_WRD</name>
	<description>This is the value of a special command (read break sequence) that is applied by the controller to the external memory device, in order to force the memory device to abandon the continuous read mode.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_BURSTCMDA_REG</name>
	<description>The way of reading in Auto mode (command register A)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Dummy bytes phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Extra Byte phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ADR_TX_MD</name>
	<description>It describes the mode of the SPI bus during the address phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_TX_MD</name>
	<description>It describes the mode of the SPI bus during the instruction phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE</name>
	<description>The value of an extra byte which will be transferred after address (only if QSPIC_EXT_BYTE_EN= 1). Usually this is the Mode Bits in Dual/Quad SPI I/O instructions.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_WB</name>
	<description>Instruction Value for Wrapping Burst. This value is the selected instruction when QSPIC_WRAP_MD is equal to 1 and the access is a wrapping burst of length and size described by the bit fields QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST</name>
	<description>Instruction Value for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported (QSPIC_WRAP_MD)</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_BURSTCMDB_REG</name>
	<description>The way of reading in Auto mode (command register B)</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_FORCE</name>
	<description>By setting this bit, the number of dummy bytes is forced to be equal to 3. In this case the QSPIC_DMY_NUM field is overruled and has no function.
0: The number of dummy bytes is controlled by the QSPIC_DMY_NUM field
1: Three dummy bytes are used. The QSPIC_DMY_NUM is overruled.
</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CS_HIGH_MIN</name>
	<description>Between the transmission of two different instructions to the flash memory, the qspi bus stays in idle state (QSPI_CS high) for at least this number of QSPI_SCK clock cycles. See the QSPIC_ERS_CS_HI and the QSPIC_WR_CS_HIGH_MIN registers for some exceptions.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_SIZE</name>
	<description>It describes the selected data size of a wrapping burst (QSPIC_WRAP_MD).
0x0: Byte access (8-bits)
0x1: Half word access (16 bits)
0x2: Word access (32-bits)
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_LEN</name>
	<description>It describes the selected length of a wrapping burst (QSPIC_WRAP_MD).
0x0: 4 beat wrapping burst
0x1: 8 beat wrapping burst
0x2: 16 beat wrapping burst
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_MD</name>
	<description>Wrap mode
0: The QSPIC_INST is the selected instruction at any access.
1: The QSPIC_INST_WB is the selected instruction at any wrapping burst access of length and size described by the registers QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively. In all other cases the QSPIC_INST is the selected instruction. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_MD</name>
	<description>Instruction mode
0: Transmit instruction at any burst access.
1: Transmit instruction only in the first access after the selection of Auto Mode.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DMY_NUM</name>
	<description>Number of Dummy Bytes

0x0: Zero Dummy Bytes (Don't Send Dummy Bytes)
0x1: Send 1 Dummy Byte
0x2: Send 2 Dummy Bytes
0x3: Send 4 Dummy Bytes

When QSPIC_DMY_FORCE is enabled, the QSPIC_DMY_NUM is overruled. In this case the number of dummy bytes is defined by the QSPIC_DMY_FORCE and is equal to 3, independent of the value of the QSPIC_DMY_NUM.
</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_HF_DS</name>
	<description>Extra Half Disable Output
0: if QSPIC_EXT_BYTE_EN=1 then transmit the complete QSPIC_EXT_BYTE
1: if QSPIC_EXT_BYTE_EN=1 then disable (hi-z) output during the transmission of bits [3:0] of QSPIC_EXT_BYTE</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE_EN</name>
	<description>Extra Byte Enable
0: Don't Send QSPIC_EXT_BYTE
1: Send QSPIC_EXT_BYTE</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DAT_RX_MD</name>
	<description>It describes the mode of the SPI bus during the data phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_CHCKERASE_REG</name>
	<description>Check erase progress in Auto mode</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CHCKERASE</name>
	<description>Writing any value to this register during erasing, forces the controller to read the flash memory status register. Depending on the value of the Busy bit, it updates the QSPIC_ERASE_EN.
This register has meaning only when the controller is in Auto mode and there is an erase in progress (QSPIC_ERASE_EN =1). It has no meaning when the external device is a serial SRAM.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_CTRLBUS_REG</name>
	<description>SPI Bus control register for the Manual mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DIS_CS</name>
	<description>Write 1 to disable the chip select (active low) when the controller is in Manual mode.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_EN_CS</name>
	<description>Write 1 to enable the chip select (active low) when the controller is in Manual mode. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_QUAD</name>
	<description>Write 1 to set the bus mode in Quad mode when the controller is in Manual mode.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_DUAL</name>
	<description>Write 1 to set the bus mode in Dual mode when the controller is in Manual mode.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_SINGLE</name>
	<description>Write 1 to set the bus mode in Single SPI mode when the controller is in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_CTRLMODE_REG</name>
	<description>Mode control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_CLK_FREE_EN</name>
	<description>Controls the behavior of the QSPI_SCK when the QSPI_CS is high and the QSPIC_CS_MD=1.
0: Is produced one QSPI_SCK clock pulse after each 0 to 1 transition in the QSPI_CS.
1: The QSPI_SCK clock remains always active, while the QSPI_CS is inactive.

This setting has meaning only when the QSPIC_CS_MD=1.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CS_MD</name>
	<description>Controls the clock edge with which is produced the QSPI_CS signal.
0: The QSPI_CS is produced with the rising edge of the QSPI_SCK. The QSPI_SCK is always inactive while the QSPI_CS is high.
1: The QSPI_CS is produced with the falling edge of the QSPI_SCK. The behavior of the QSPI_SCK while the QSPI_CS is high, is controlled by the QSPIC_CLK_FREE_EN.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SRAM_EN</name>
	<description>Defines the type of the external device that is connected on the QSPIC controller
0: The external memory device is a serial Flash
1: The external memory device is a serial SRAM

When the external device is a serial SRAM, the erase suspend/ resume functionality of the controller is disabled. In this case the writing of the QSPIC_ERASECTRL_REG[QSPIC_ERASE_EN] bit has no effect. Also, the memory space where the external device is mapped, is considered as writable.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_USE_32BA</name>
	<description>Controls the length of the address that the external memory device uses.
0: The external memory device uses 24 bits address.
1: The external memory device uses 32 bits address.
The controller uses this bit in order to decide the number of the address bytes that has to transfer to the external device during Auto mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_FORCENSEQ_EN</name>
	<description>Controls the way with which is addressed by the QSPI controller a burst request from the AMBA bus.

0: The controller translates a burst access on the AMBA bus as a burst access on the QSPI bus. That results to the minimum number of command/address phases.
1: The controller will split a burst access on the AMBA bus into a number of single accesses on the QSPI bus. That results to a separate command for each beat of the burst. E.g a 4-beat word incremental AMBA read access will be split into 4 different sequences on the QSPI bus: command/address/extra clock/read data. The QSPI_CS will be low only for the time that is needed for each of these single access.

This configuration bit is usefull when the clock frequency of the QSPI bus is much higher than the clock of the AMBA bus. In this case the interval for which the CS remains low is minimized, achieving lower power dissipation with respect of the case where the QSPIC_FORCENSEQ_EN=0, at cost of performance.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PCLK_MD</name>
	<description>Controls the read pipe clock delay relative to the falling edge of QSPI_SCK. Refer to QSPI Timing for timing parameters</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RPIPE_EN</name>
	<description>Controls the use of the data read pipe.
0: The read pipe is disabled, the sampling clock is defined according to the QSPIC_RXD_NEG setting.
1: The read pipe is enabled. The delay of the sampling clock is defined according to the QSPI_PCLK_MD setting. (Recommended)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RXD_NEG</name>
	<description>Defines the clock edge that is used for the capturing of the received data, when the read pipe is not active (QSPIC_RPIPE_EN = 0).

0: Sampling of the received data with the positive edge of the QSPI_SCK
1: Sampling of the received data with the negative edge of the QSPI_SCK

The internal QSPI_SCK clock that is used by the controller for the capturing of the received data has a skew in respect of the QSPI_SCK that is received by the external memory device. In order to be improved the timing requirements of the read path, the controller supports a read pipe register with programmable clock delay. See also the QSPIC_RPIPE_EN register.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_HRDY_MD</name>
	<description>This configuration bit is useful when the frequency of the QSPI clock is much lower than the clock of the AMBA bus, in order to not locks the AMBA bus for a long time.

0: Adds wait states via hready signal when an access is performed on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. It is not needed to checked the QSPIC_BUSY of the QSPIC_STATUS_REG.
1: The controller don't adds wait states via the hready signal, when is performed access on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. The QSPIC_BUSY bit of the QSPIC_STATUS_REG must be checked in order to be detected the completion of the requested access.

It is applicable only when the controller is in Manual mode. In the case of the Auto mode, the controller always adds wait states via the hready signal.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_DAT</name>
	<description>The value of QSPI_IO3 pad if QSPI_IO3_OEN is 1</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_DAT</name>
	<description>The value of QSPI_IO2 pad if QSPI_IO2_OEN is 1</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_OEN</name>
	<description>QSPI_IO3 output enable. Use this only in SPI or Dual SPI mode to control /HOLD signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO3 pad is input.
1: The QSPI_IO3 pad is output.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_OEN</name>
	<description>QSPI_IO2 output enable. Use this only in SPI or Dual SPI mode to control /WP signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO2 pad is input.
1: The QSPI_IO2 pad is output.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CLK_MD</name>
	<description>Mode of the generated QSPI_SCK clock

0: Use Mode 0 for the QSPI_CLK. The QSPI_SCK is low when QSPI_CS is high.
1: Use Mode 3 for the QSPI_CLK. The QSPI_SCK is high when QSPI_CS is high.

See also the register QSPIC_CS_MD and the QSPIC_CLK_FREE_EN</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_AUTO_MD</name>
	<description>Mode of operation
0: The Manual Mode is selected.
1: The Auto Mode is selected.
During an erasing the QSPIC_AUTO_MD goes in read only mode (see QSPIC_ERASE_EN)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_DUMMYDATA_REG</name>
	<description>Send dummy clocks to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_DUMMYDATA</name>
	<description>Writing to this register generates a number of clock pulses to the SPI bus. During the last clock of this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. The data size of the access to this register can be 32-bits / 16-bits/ 8-bits. The number of generated pulses is equal to: (size of AHB bus access) / (size of SPI bus). The size of SPI bus is equal to 1, 2 or 4 for Single, Dual or Quad SPI mode respectively.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_ERASECMDA_REG</name>
	<description>The way of erasing in Auto mode (command register A)</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RES_INST</name>
	<description>The code value of the erase resume instruction</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_INST</name>
	<description>The code value of the erase suspend instruction.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_INST</name>
	<description>The code value of the write enable instruction.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_INST</name>
	<description>The code value of the erase instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_ERASECMDB_REG</name>
	<description>The way of erasing in Auto mode (command register B)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RESSUS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the previous erase resume command (or the initial erase command).
0x00: Dont wait. The controller starts immediately to suspend the erase procedure.
0x01..0x3F: The controller waits for at least this number of 288 KHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume command (or the initial erase command)</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERSRES_HLD</name>
	<description>The controller must stay without flash memory reading requests for this number of AMBA hclk clock cycles, before to perform the command of erase or erase resume. Allowable range : 0xF - 0x0</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_CS_HI</name>
	<description>After the execution of instructions: write enable, erase, erase suspend and erase resume, the QSPI_CS remains high for at least this number of QSPI_SCK clock cycles.</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EAD_TX_MD</name>
	<description>The mode of the SPI Bus during the address phase of the erase instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RES_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the resume instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the suspend instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the write enable instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the erase instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_ERASECTRL_REG</name>
	<description>Erase control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_ERS_STATE</name>
	<description>It shows the progress of sector/block erasing (read only).
0x0: No Erase.
0x1: Pending erase request
0x2: Erase procedure is running
0x3: Suspended Erase procedure
0x4: Finishing the Erase procedure
0x5..0x7: Reserved</description>
	<bitRange>[27:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QSPIC_ERASE_EN</name>
	<description>This bit has meaning only when the external device is a serial FLASH (QSPIC_SRAM_EN=0). 

During Manual mode (QSPIC_AUTO_MD = 0) : This bit is in read only mode.
During Auto mode (QSPIC_AUTO_MD = 1). To request the erasing of the block/sector (QSPIC_ERS_ADDR, 12'b0) write 1 to this bit. This bit is cleared automatically with the end of the erasing. Until the end of erasing the QSPIC_ERASE_EN remains in read only mode. During the same period of time the controller remains in Auto Mode (QSPIC_AUTO_MD goes in read only mode).

In the case where the external device is a serial SRAM (QSPIC_SRAM_EN=1) this bit is in read only mode.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_ADDR</name>
	<description>Defines the address of the block/sector that is requested to be erased.
If QSPIC_USE_32BA = 0 (24 bits addressing), bits QSPIC_ERASECTRL_REG[23-12] determine the block/ sector address bits [23-12].
QSPIC_ERASECTRL_REG[11-4] are ignored by the controller.
If QSPIC_USE_32BA = 1 (32 bits addressing) bits QSPIC_ERASECTRL_REG[23-4] determine the block / sectors address bits [31:12]</description>
	<bitRange>[23:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_GP_REG</name>
	<description>General purpose QSPIC2 register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>QSPIC_PADS_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0x0 : Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
0x1 : Rise=2.0 V/ns, Fall=2.3 V/ns
0x2 : Rise=2.3 V/ns, Fall=2.6 V/ns
0x3 : Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6pF, Vcc=1.8V, T=25C and Idrive=16mA</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PADS_DRV</name>
	<description>QSPI pads drive current
0x0 : 4 mA
0x1 : 8 mA
0x2 : 12 mA
0x3 : 16 mA</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_MEMBLEN_REG</name>
	<description>External memory burst length configuration</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_T_CEM_CC</name>
	<description>Defines the maximum allowed time tCEM for which the QSPIC_CS can stay active (QSPI_CS=0). It has meaning only when QSPIC_T_CEM_EN is equal to 1. See also the description of the QSPIC_T_CEM_EN for more details.

The tCEM is expressed in number of qspi clock cycles and can be calculated as follows :

tCEM / (qspi_clock_period)

If the result of the above equation is higher than 0x3FF, use the value 0x3FF.</description>
	<bitRange>[13:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_T_CEM_EN</name>
	<description>This bit enables the controlling of the maximum time tCEM for which the QSPI_CS remains active. It has meaning only when the Auto mode is active (QSPIC_AUTO_MD=1) and the external device is a serial SRAM (QSPIC_SRAM_EN=1). In the case where the external device is a serial Flash (QSPIC_SRAM_EN=0) or the controller is in Manual mode (QSPIC_AUTO_MD=0), this field has no any effect.

This feature is usefull in the case where the external serial device is a dynamic RAM that requires refresh. If the refresh is applied only when the device is in the idle state (QSPI_CS = 1), the time for which the device remains in the active state (QSPI_CS = 0) should be limited by a maximum threshold.

0:There is no any constraint regarding the maximum allowed time for which the QSPI_CS can stay active. This is the case also when QSPIC_SRAM_EN=0 or QSPIC_AUTO_MD=0.
1:There is a maximum allowed time interval tCEM for which the QSPI_CS can stay active during a burst access (for reading or writting of data). For the controller this is considered as equal to QSPIC_T_CEM_CC x qspi_clock_period. In the case where the data transfer requires the QSPI_CS to stays active for more than QSPIC_T_CEM_CC qspi clock cycles, the QSPI controller splits the access on the SPI bus in more than one bursts, by inserting inactive periods (QSPI_CS = 0) between them. This will cost extra clock cycles for the realization of the original acceess, due to the additional commands that are required in the SPI bus.

The value in the QSPIC_T_CEM_CC should be updated every time where the frequency of the qspi clock is modified. The qspi clock frequency should not be decreased more than a lowest frequency. This is the lowest frequency that enables the be performed a 32-bit word read and write access, without violating the tCEM timing requirement (the QSPI controller allows to be performed at least the transferring of one beat of the requested burst, independent of the QSPIC_T_CEM_CC limit).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_MEMBLEN</name>
	<description>In this register is defined the expected behavior of the external memory device regarding the length of a burst operation :

0x0: The external memory device is capable to implement incremental burst of unspecified length.
0x1: The external memory device implements a wrapping burst of length 4 bytes.
0x2: The external memory device implements a wrapping burst of length 8 bytes.
0x3: The external memory device implements a wrapping burst of length 16 bytes.
0x4: The external memory device implements a wrapping burst of length 32 bytes.
0x5: The external memory device implements a wrapping burst of length 64 bytes.
0x6 - 0x7 : Reserved

This setting is used by the QSPI controller when the Auto mode is enabled (QSPIC_AUTO_MD=1), in order to handle the various burst requests of the AHB bus, in respect of the requirements of the external memory device.
The external memory device may need to be configured by applying special instruction, in order to be defined the kind of the burst operation. This can be implemented by applying this special instruction with the QSPI controller in Manual mode (QSPIC_AUTO_MD=1). Refer to the datasheet of the external device for more information.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_READDATA_REG</name>
	<description>Read data from SPI Bus for the Manual mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_READDATA</name>
	<description>A read access at this register generates a data transfer from the external memory device to the QSPIC controller. The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits / 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_RECVDATA_REG</name>
	<description>Received data for the Manual mode</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_RECVDATA</name>
	<description>This register contains the received data when the QSPIC_READDATA_REG register is used in Manual mode, in order to be retrieved data from the external memory device and QSPIC_HRDY_MD=1 &amp;&amp; QSPIC_BUSY=0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_STATUSCMD_REG</name>
	<description>The way of reading the status of external device in Auto mode</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_STSDLY_SEL</name>
	<description>Defines the timer which is used to count the delay that it has to wait before to read the FLASH Status Register, after an erase or an erase resume command.
0: The delay is controlled by the QSPIC_RESSTS_DLY which counts on the qspi clock.
1: The delay is controlled by the QSPIC_RESSUS_DLY which counts on the 288 kHz clock.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RESSTS_DLY</name>
	<description>Defines a timer that counts the minimum required delay between the reading of the status register and of the previous erase or erase resume instruction.
0x00: Dont wait. The controller starts to reading the Flash memory status register immediately.
0x01..0x3F: The controller waits for at least this number of QSPI_CLK cycles and afterwards it starts to reading the Flash memory status register. The timer starts to count after the end of the previous erase or erase resume command.

The actual timer that will be used by the controller before the reading of the Flash memory status register is defined by the QSPIC_STSDLY_SEL.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_VAL</name>
	<description>Defines the value of the Busy bit which means that the flash is busy.
0: The flash is busy when the Busy bit is equal to 0.
1: The flash is busy when the Busy bit is equal to 1.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_POS</name>
	<description>Defines the bit of the Flash status register which represents the Busy bit (0x7 - 0x0).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_RX_MD</name>
	<description>The mode of the SPI Bus during the reception phase of the read status instruction, where the value of status register is retrieved.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the read status instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_INST</name>
	<description>The code value of the read status instruction.
It is transmitted during the instruction phase of the read status instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC2_STATUS_REG</name>
	<description>The status register of the QSPI controller</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_BUSY</name>
	<description>The status of the SPI Bus.

0: The SPI Bus is idle
1: The SPI Bus is active. Read data, write data or dummy data activity is in progress.

Has meaning only in Manual mode and only when QSPIC_HRDY_MD = 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC2_WRITEDATA_REG</name>
	<description>Write data to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QSPIC_WRITEDATA</name>
	<description>Writing to this register is generating a data transfer from the controller to the external memory device. The data written in this register, is then transferred to the memory using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits/ 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFMON</name>
	<version>1.0</version>
	<description>RFMON registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RFMON_ADDR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_ADDR</name>
	<description>It is the bits [31:2] of base address that is used by the AHB master interface of the controller. Defines the AHB address where the controller will start storing data at. Bits [1:0] of the address are always considered to be 0.</description>
	<bitRange>[31:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_ADDR_REG</name>
	<description>AHB master current address</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_ADDR</name>
	<description>Bits [31:2] of AHB address that will be used by the controller in the next memory access. The bits [1:0] are always 0.</description>
	<bitRange>[31:2]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_LEN_REG</name>
	<description>The remaining data to be transferred</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_LEN</name>
	<description>Indicates the number of words (minus 1) that remain to be transfered.</description>
	<bitRange>[16:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CTRL_REG</name>
	<description>Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_BREQ_FORCE</name>
	<description>Write this bit with 1, when the required throughput for the transferring of the captured data is close to the capacity of the system bus/memory. The controller will be aggressive in the usage of the bus. The availability of the bus will be affected for the remaining masters. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_CIRC_EN</name>
	<description>Write with 1 to enable the circular mode. In circular mode the controller continuously writes data in to the memory until being disabled by software. Data are transferred in the circular buffer in the memory, as defined by RFMON_ADDR_REG and RFMON_LEN_REG registers. Disabling of the controller is realized by writing RFMON_PACK_EN with 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_PACK_EN</name>
	<description>Starts capturing data from the test bus
0 : No data captured.
1 : Data captured.
Should be written with 1 to start data acquisition.
When the controller is not in circular mode (RFMON_CIRC_EN = 0) and after capturing a predefined number of words (RFMON_LEN), this bit will be auto cleared.
In circular mode (RFMON_CIRC_EN = 1) the RFMON_PACK_EN remains 1 to be cleared by software.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_LEN_REG</name>
	<description>Data length register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_LEN</name>
	<description>The number of words (minus one) that should be captured.</description>
	<bitRange>[16:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RFMON_OFLOW_STK</name>
	<description>Indicates that during transfer of data, at least one overflow has been detected.
0 : The transfer completed without overflows.
1 : At least one overflow occured in the fifo.
Write 1 to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_ACTIVE</name>
	<description>Indicates the state of the controller.
0 : The controller is idle.
1 : The controller is active. The capturing process and/or the dma activity is in progress.
The controller will be activated (RFMON_ACTIVE == 1), when RFMON_PACK_EN will be written with 1. Will return to inactive state, after the end of the capturing process (RFMON_PACK_EN==0) and the completion of the transfer of all data to memory. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RTC</name>
	<version>1.0</version>
	<description>RTC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>152</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RTC_ALARM_ENABLE_REG</name>
	<description>RTC Alarm Enable Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RTC_ALARM_MNTH_EN</name>
	<description>Alarm on month enable. Enable to trigger alarm when data specified in Calendar Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_DATE_EN</name>
	<description>Alarm on date enable. Enable to trigger alarm when data specified in Calendar Alarm Register (D_T and D_U) has been reached.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOUR_EN</name>
	<description>Alarm on hour enable. Enable to trigger alarm when data specified in Time Alarm Register (PM, HR_T and HR_U) has been reached.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_MIN_EN</name>
	<description>Alarm on minute enable. Enable to trigger alarm when data specified in Time Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_SEC_EN</name>
	<description>Alarm on second enable. Enable to trigger alarm when data specified in Time Alarm Register (S_T and S_U) has been reached.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOS_EN</name>
	<description>Alarm on hundredths of a second enable. Enable to trigger alarm when data specified in Time Alarm Register (H_T and H_U) has been reached.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_ALARM_REG</name>
	<description>RTC Calendar Alram Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_REG</name>
	<description>RTC Calendar Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2000010f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_CH</name>
	<description>The value in this register has altered since last read. Read and clear</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_T</name>
	<description>Century tens. Represented in BCD digit (1-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_U</name>
	<description>Century units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_T</name>
	<description>Year tens. Represented in BCD digit (0-9).</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_U</name>
	<description>Year units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DAY</name>
	<description>Day of the week (arbitrary) units. Represented in BCD digit (0-7).</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CONTROL_REG</name>
	<description>RTC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_CAL_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the calendar value.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the time value.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_CTRL_REG</name>
	<description>RTC Event Control Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_EN</name>
	<description>0 = Event to PDC is disabled. No clear any pending event
1 = Even to PDC is enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_MOTOR_EVENT_EN</name>
	<description>0 = Event to Motor is disabled
1 = Event to Motor is enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_FLAGS_REG</name>
	<description>RTC Event Flags Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_EVENT_ALRM</name>
	<description>Alarm event flag. Indicate that alarm event occurred since the last reset.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MNTH</name>
	<description>Month rolls over event flag. Indicate that month rolls over event occurred since the last reset.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_DATE</name>
	<description>Date rolls over event flag. Indicate that date rolls over event occurred since the last reset.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOUR</name>
	<description>Hour rolls over event flag. Indicate that hour rolls over event occurred since the last reset.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MIN</name>
	<description>Minute rolls over event flag. Indicate that minute rolls over event occurred since the last reset.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_SEC</name>
	<description>Second rolls over event flag. Indicate that second rolls over event occurred since the last reset.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOS</name>
	<description>Hundredths of a second event flag. Indicate that hundredths of a second rolls over event occurred since the last reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_HOUR_MODE_REG</name>
	<description>RTC Hour Mode Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_HMS</name>
	<description>When this field is set high the RTC operates in 12 hour clock mode; otherwise, times are in 24 hour clock format.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_DISABLE_REG</name>
	<description>RTC Interrupt Disable Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_DIS</name>
	<description>Interrupt on alarm disable. Disable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_DIS</name>
	<description>Interrupt on month disable. Disable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_DIS</name>
	<description>Interrupt on date disable. Disable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_DIS</name>
	<description>IInterrupt on hour disable. Disable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_DIS</name>
	<description>Interrupt on minute disable. Disable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_DIS</name>
	<description>Interrupt on second disable. Disable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_DIS</name>
	<description>Interrupt on hundredths of a second disable. Disable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_ENABLE_REG</name>
	<description>RTC Interrupt Enable Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_EN</name>
	<description>Interrupt on alarm enable. Enable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_EN</name>
	<description>Interrupt on month enable. Enable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_EN</name>
	<description>Interrupt on date enable. Enable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_EN</name>
	<description>Interrupt on hour enable. Enable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_EN</name>
	<description>Interrupt on minute enable. Enable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_EN</name>
	<description>Interrupt on second enable. Enable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_EN</name>
	<description>Interrupt on hundredths of a second enable. Enable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_MASK_REG</name>
	<description>RTC Interrupt Mask Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_MSK</name>
	<description>Mask alarm interrupt. It can be cleared (set) by setting corresponding bit (ALRM) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MNTH_INT_MSK</name>
	<description>IMask month interrupt. It can be cleared (set) by setting corresponding bit (MNTH) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_DATE_INT_MSK</name>
	<description>Mask date interrupt. It can be cleared (set) by setting corresponding bit (DATE) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOUR_INT_MSK</name>
	<description>IMask hour interrupt. It can be cleared (set) by setting corresponding bit (HOUR) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MIN_INT_MSK</name>
	<description>IMask minute interrupt. It can be cleared (set) by setting corresponding bit (MIN) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_SEC_INT_MSK</name>
	<description>IMask second interrupt. It can be cleared (set) by setting corresponding bit (SEC) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOS_INT_MSK</name>
	<description>Mask hundredths of a second interrupt. It can be cleared (set) by setting corresponding bit (HOS) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_KEEP_RTC_REG</name>
	<description>RTC Keep RTC Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_KEEP</name>
	<description>Keep RTC. When high, the time and calendar registers and any other registers which directly affect or are affected by the time and calendar registers are NOT reset when software reset is applied. When low, the software reset will reset every register except the keep RTC and control registers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_MOTOR_EVENT_CNT_REG</name>
	<description>RTC Motor Event Counter Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RTC_MOTOR_EVENT_CNT</name>
	<description>It gives the current value of the Motor event counter (0 to RTC_MOTOR_EVENT_PERIOD)</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_MOTOR_EVENT_PERIOD_REG</name>
	<description>RTC Motor Event Period Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RTC_MOTOR_EVENT_PERIOD</name>
	<description>RTC wil send an event to motor (if RTC_MOTOR_EVENT_EN=1) every (RTC_MOTOR_EVENT_PERIOD+1)*10ms</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_CLEAR_REG</name>
	<description>RTC PDC Event Clear Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>PDC_EVENT_CLEAR</name>
	<description>On read, PDC event is cleared</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_CNT_REG</name>
	<description>RTC PDC Event Counter Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_CNT</name>
	<description>It gives the current value of the PDC event counter (0 to RTC_PDC_EVENT_PERIOD)</description>
	<bitRange>[12:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_PERIOD_REG</name>
	<description>RTC PDC Event Period Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_PERIOD</name>
	<description>RTC wil send an event to PDC (if RTC_PDC_EVENT_EN=1) every (RTC_PDC_EVENT_PERIOD+1)*10ms</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_STATUS_REG</name>
	<description>RTC Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RTC_VALID_CAL_ALM</name>
	<description>Valid Calendar Alarm. If cleared then indicates that invalid entry occurred when writing to Calendar Alarm Register.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME_ALM</name>
	<description>Valid Time Alarm. If cleared then indicates that invalid entry occurred when writing to Time Alarm Register.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_CAL</name>
	<description>Valid Calendar. If cleared then indicates that invalid entry occurred when writing to Calendar Register.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME</name>
	<description>Valid Time. If cleared then indicates that invalid entry occurred when writing to Time Register.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_ALARM_REG</name>
	<description>RTC Time Alarm Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_REG</name>
	<description>RTC Time Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_CH</name>
	<description>The value in this register has altered since last read. Read and clear.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SDADC</name>
	<version>1.0</version>
	<description>SDADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020800</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SDADC_CLEAR_INT_REG</name>
	<description>Sigma Delta ADC Clear Interrupt Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SDADC_CTRL_REG</name>
	<description>Sigma Delta ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>SDADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_MINT</name>
	<description>0: Disable (mask) SDADC_ADC_INT.
1: Enable SDADC_ADC_INT to ICU.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to SDADC_CLEAR_INT_REG.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDADC_LDO_OK</name>
	<description>1: Internal LDO is ready for use</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDADC_VREF_SEL</name>
	<description>0: Internal bandgap reference.
1: External reference.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the SDADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in SDADC_RESULT_REG. Still SDADC_START has to be set to start the execution. Wait for SDADC_START to become zero after clearing the SDADC_CONT bit to stop the continuous mode.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_OSR</name>
	<description>Oversample Rate
0: 128x
1: 256x
2: 512x
3: 1024x</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_SE</name>
	<description>0: Differential mode
1: Single ended mode (Input selection negative side is ignored)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INN_SEL</name>
	<description>Input selection of negative side.
0: ADC0 / P1[09]
1: ADC1 / P0[25]
2: ADC2 / P0[08]
3: ADC3 / P0[09]
4: ADC4 / P1[14]
5: ADC5 / P1[20]
6: ADC6 / P1[21]
7: ADC7 / P1[22]</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INP_SEL</name>
	<description>Input selection of positive side.
0: ADC0 / P1[09]
1: ADC1 / P0[25]
2: ADC2 / P0[08]
3: ADC3 / P0[09]
4: ADC4 / P1[14]
5: ADC5 / P1[20]
6: ADC6 / P1[21]
7: ADC7 / P1[22]
8: VBAT (via 4x attenuator, INN connected to ground)</description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the SDADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_EN</name>
	<description>0: LDO is off and ADC is disabled.
1: LDO, bias currents and modulator are enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_GAIN_CORR_REG</name>
	<description>Sigma Delta ADC Gain Correction Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SDADC_GAIN_CORR</name>
	<description>Gain adjust</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_OFFS_CORR_REG</name>
	<description>Sigma Delta ADC Offset Correction Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SDADC_OFFS_CORR</name>
	<description>Offset adjust</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_RESULT_REG</name>
	<description>Sigma Delta ADC Result Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDADC_VAL</name>
	<description>Returns up to 16 bits linear value of the last AD conversion. The effective resolution depends on the OSR used.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SDADC_TEST_REG</name>
	<description>Sigma Delta ADC Test Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00007980</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDADC_CLK_FREQ</name>
	<description>0: 250 kHz
1: 500 kHz
2: 1 MHz (default)
3: 2 MHz</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SMOTOR</name>
	<version>1.0</version>
	<description>SMOTOR registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030e00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>132</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CMD_TABLE_BASE</name>
	<description>Base address of the command table</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>PG0_CTRL_REG</name>
	<description>Pattern generator 0 control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fe4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GENEND_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it is done generating a pattern. It is only valid if SMOTOR_GENEND_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GENSTART_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it starts generating a pattern. It is only valid if SMOTOR_GENSTART_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_START_MODE</name>
	<description>0 = Auto start mode: pattern generator will start whenever all enabled signals have received a command
1 = Manual start mode: pattern generator will only start if it has been given a PG_START, and all enabled signals have received a command</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_MODE</name>
	<description>0 = Flex mode
1 = Pair mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG3_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG2_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG1_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG0_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT3_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT2_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT1_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT0_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PG1_CTRL_REG</name>
	<description>Pattern generator 1 control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fe4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GENEND_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it is done generating a pattern. It is only valid if SMOTOR_GENEND_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GENSTART_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it starts generating a pattern. It is only valid if SMOTOR_GENSTART_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_START_MODE</name>
	<description>0 = Auto start mode: pattern generator will start whenever all enabled signals have received a command
1 = Manual start mode: pattern generator will only start if it has been given a PG_START, and all enabled signals have received a command</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_MODE</name>
	<description>0 = Flex mode
1 = Pair mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG3_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG2_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG1_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG0_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT3_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT2_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT1_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT0_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PG2_CTRL_REG</name>
	<description>Pattern generator 2 control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fe4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GENEND_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it is done generating a pattern. It is only valid if SMOTOR_GENEND_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GENSTART_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it starts generating a pattern. It is only valid if SMOTOR_GENSTART_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_START_MODE</name>
	<description>0 = Auto start mode: pattern generator will start whenever all enabled signals have received a command
1 = Manual start mode: pattern generator will only start if it has been given a PG_START, and all enabled signals have received a command</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_MODE</name>
	<description>0 = Flex mode
1 = Pair mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG3_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG2_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG1_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG0_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT3_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT2_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT1_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT0_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PG3_CTRL_REG</name>
	<description>Pattern generator 3 control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fe4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GENEND_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it is done generating a pattern. It is only valid if SMOTOR_GENEND_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GENSTART_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it starts generating a pattern. It is only valid if SMOTOR_GENSTART_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_START_MODE</name>
	<description>0 = Auto start mode: pattern generator will start whenever all enabled signals have received a command
1 = Manual start mode: pattern generator will only start if it has been given a PG_START, and all enabled signals have received a command</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_MODE</name>
	<description>0 = Flex mode
1 = Pair mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG3_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG2_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG1_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG0_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT3_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT2_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT1_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT0_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PG4_CTRL_REG</name>
	<description>Pattern generator 4 control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fe4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GENEND_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it is done generating a pattern. It is only valid if SMOTOR_GENEND_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GENSTART_IRQ_EN</name>
	<description>Determines if the corresponding pattern generator will contribute to the generation of the IRQ when it starts generating a pattern. It is only valid if SMOTOR_GENSTART_IRQ_EN is enabled:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_START_MODE</name>
	<description>0 = Auto start mode: pattern generator will start whenever all enabled signals have received a command
1 = Manual start mode: pattern generator will only start if it has been given a PG_START, and all enabled signals have received a command</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PG_MODE</name>
	<description>0 = Flex mode
1 = Pair mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG3_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG2_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG1_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIG0_EN</name>
	<description>0 = Signal disabled
1 = Signal enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT3_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT2_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT1_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT0_SIG</name>
	<description>Selects which signal is routed to the output.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SMOTOR_CMD_FIFO_REG</name>
	<description>Motor control command FIFO register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SMOTOR_CMD_FIFO</name>
	<description>Writing to this address will push a command into the command FIFO.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SMOTOR_CMD_READ_PTR_REG</name>
	<description>Command read pointer register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>SMOTOR_CMD_READ_PTR</name>
	<description>Pointer to the next command to be popped from the FIFO. The command at SMOTOR_CMD_READ_PTR-1 is the last command that has been popped from the FIFO into its corresponding PG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SMOTOR_CMD_WRITE_PTR_REG</name>
	<description>Command write pointer register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>SMOTOR_CMD_WRITE_PTR</name>
	<description>Pointer to the location in the FIFO where the next command will be pushed at. The last command pushed to the FIFO is at SMOTOR_CMD_WRITE_PTR - 1. Can only be changed in cyclic mode</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SMOTOR_CTRL_REG</name>
	<description>Motor control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>TRIG_RTC_EVENT_EN</name>
	<description>0 = RTC event does not trigger command pop
1 = RTC event triggers command pop</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MC_LP_CLK_TRIG_EN</name>
	<description>0 = Divided sleep clock does not trigger command pop
1 = Divided sleep clock triggers command pop</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_THRESHOLD_IRQ_EN</name>
	<description>IRQ in the event of the FIFO level (write pointer - read pointer) reaching, or is below the threshold determined by SMOTOR_THRESHOLD.
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_THRESHOLD</name>
	<description>Determines the FIFO level (write pointer - read pointer) at or below which and IRQ can be triggered using SMOTOR_THRESHOLD_IRQ_EN.</description>
	<bitRange>[25:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_FIFO_UNR_IRQ_EN</name>
	<description>IRQ in the event of FIFO underrun:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_FIFO_OVF_IRQ_EN</name>
	<description>IRQ in the event of FIFO overflow:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_GENEND_IRQ_EN</name>
	<description>IRQ in the event a pattern generator (configured to do so through its corresponding GENEND_IRQ_EN bit) has ended generating a pattern:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_GENSTART_IRQ_EN</name>
	<description>IRQ in the event a pattern generator (configured to do so through its corresponding GENSTART_IRQ_EN bit) has just started generating a pattern:
0 = Interrupt requests disabled
1 = Interrupt requests enabled</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SMOTOR_MOI</name>
	<description>Idle time of a PG after generating a waveform. A PG will remain busy for the last signal's MOI to finish.</description>
	<bitRange>[16:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CYCLIC_SIZE</name>
	<description>Depth of the cyclic buffer, only valid if CYCLIC_MODE is 1.</description>
	<bitRange>[6:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CYCLIC_MODE</name>
	<description>Determines operation mode of command FIFO:
0 = Normal FIFO mode
1 = Cyclic buffer mode, CYCLIC_SIZE determines buffer depth</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SMOTOR_IRQ_CLEAR_REG</name>
	<description>Motor control IRQ clear register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>THRESHOLD_IRQ_CLEAR</name>
	<description>Clears the THRESHOLD_IRQ_STATUS bit.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FIFO_UNR_IRQ_CLEAR</name>
	<description>Clears the FIFO_UNR_IRQ_STATUS bit.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FIFO_OVF_IRQ_CLEAR</name>
	<description>Clears the FIFO_OVF_IRQ_STATUS bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>GENEND_IRQ_CLEAR</name>
	<description>Clears the GENEND_IRQ_STATUS bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>GENSTART_IRQ_CLEAR</name>
	<description>Clears the GENSTART_IRQ_STATUS bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SMOTOR_STATUS_REG</name>
	<description>Motor controller status register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PG4_BUSY</name>
	<description>Tells whether the PG is busy/generating a waveform.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PG3_BUSY</name>
	<description>Tells whether the PG is busy/generating a waveform.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PG2_BUSY</name>
	<description>Tells whether the PG is busy/generating a waveform.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PG1_BUSY</name>
	<description>Tells whether the PG is busy/generating a waveform.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PG0_BUSY</name>
	<description>Tells whether the PG is busy/generating a waveform.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>THRESHOLD_IRQ_STATUS</name>
	<description>Tells whether the THRESHOLD_IRQ fired. Can be cleared with corresponding _CLEAR bit.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FIFO_UNR_IRQ_STATUS</name>
	<description>Tells whether the FIFO_UNR_IRQ fired. Can be cleared with corresponding _CLEAR bit.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FIFO_OVF_IRQ_STATUS</name>
	<description>Tells whether the FIFO_OVF_IRQ fired. Can be cleared with corresponding _CLEAR bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GENEND_IRQ_STATUS</name>
	<description>Tells whether the GENEND_IRQ fired. Can be cleared with corresponding _CLEAR bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GENSTART_IRQ_STATUS</name>
	<description>Tells whether the GENSTART_IRQ fired. Can be cleared with corresponding _CLEAR bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SMOTOR_TRIGGER_REG</name>
	<description>Motor controller trigger register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>PG4_START</name>
	<description>Writing 1 to this bit will start PG4, only effective in manual mode.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PG3_START</name>
	<description>Writing 1 to this bit will start PG3, only effective in manual mode.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PG2_START</name>
	<description>Writing 1 to this bit will start PG2, only effective in manual mode.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PG1_START</name>
	<description>Writing 1 to this bit will start PG1, only effective in manual mode.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PG0_START</name>
	<description>Writing 1 to this bit will start PG0, only effective in manual mode.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>POP_CMD</name>
	<description>Writing 1 will pop one (or more, depending on the N_CMDs field of the first) command(s) from the command buffer into its corresponding pattern generator.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WAVETABLE_BASE</name>
	<description>Base address of the wavetable</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1f1f1f1f</resetMask>
	
</register></registers>
</peripheral><peripheral>
	<name>SNC</name>
	<version>1.0</version>
	<description>SNC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020c00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SNC_CTRL_REG</name>
	<description>Sensor Node Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SNC_IRQ_ACK</name>
	<description>When set, the specific bit-field auto-clears the SNC_IRQ_EN field, if the latter is already set. By this way, the IRQ line towards either the CM33 and/or the PDC is cleared. Hence, the CM33 should set this bit-field as soon as it captures the interrupt from the Sensor Node.
Note: Any SW writes to this bit-field will be discarded if the SNC_IRQ_EN bit-field is not set. It is finally noted that the SNC_IRQ_ACK bit-field is also auto-clear and it is de-asserted together with SNC_IRQ_EN.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_IRQ_CONFIG</name>
	<description>The specific bit-field determines if the IRQ line of the Sensor Node will be routed towards either the host processor (CM33) or the Power Domains Controller (PDC), or to both of them, according to the following configuration:
0x0 = Neither the CM33 nor the PDC are triggered, both IRQ lines are low regardless of the value of SNC_IRQ_EN bit-field.
0x1 = CM33 should be triggered, provided that SNC_IRQ_EN is set
0x2 = PDC should be triggered, provided that SNC_IRQ_EN is set
0x3 = Both CM33 and PDC should be triggered, provided that SNC_IRQ_EN is set
Note: It must be noted that the specific bit-field is locked after set the SNC_IRQ_EN field of the same register. Hence, the SNC IRQ configuration cannot be changed after the IRQ bit-field is set and before the IRQ is acknowledged (by CM33). It is also noted that after having set SNC_IRQ_EN via SW, the specific bit-field can be de-asserted only by setting the SNC_IRQ_ACK bit-field (see also the description of this bit-field, also residing in SNC_CTRL_REG).</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_IRQ_EN</name>
	<description>When set, the specific bit-field may generate a (level-sensitive) IRQ to trigger either the host processor (CM33) or the Power Domains Controller (PDC) or both, depending on the configuration set in the SNC_IRQ_CONFIG bit-field of SNC_CTRL_REG. As soon as the SNC_IRQ_EN is set, it can be cleared only by setting the SNC_IRQ_ACK bit-field.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_BRANCH_LOOP_INIT</name>
	<description>When set, it clears the value of the counter used in the Sensor Node's branch command (COBR), when performing an iterative branch of up to 128 times. This bit-field is auto-cleared with the next SNC clock.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_RESET</name>
	<description>This is the Sensor Node Controller's synchronous clear bit-field. When set, it resets the state of the Sensor Node Controller and sets back its program counter (SNC_PC_REG) to the programmed base address, as determined by SNC_BASE_REG register (located in memory controller). This bit-field is auto-cleared with the next SNC clock.
Note: Setting this bit-field may interrupt the Sensor Node's regular execution and any command currently being exeucuted may be abnormally terminated.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT_EN</name>
	<description>When set, it enables the detection of system bus errors that may occur in case a non-mapped address is used by the Sensor Node controller, when performing a register access.
Note: In case of a bus error detection, the Sensor Node will set to '1' the BUS_ERROR_STATUS bit-field of SNC_STATUS_REG and will continue normally to the next command.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_SW_CTRL</name>
	<description>When set, this bit-field bypasses the enable of Sensor Node that comes from the PDC. In this mode, the Sensor Node can be started and stopped via the SNC_EN bit-field of SNC_CTRL_REG.
Note: This mode is suggested to be used for debugging purposes. &#196;lso, the base address of the Sensor Node should have been programmed to the target value, before this bit-field is set.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_EN</name>
	<description>Sensor Node Controller's enable bit-field. When set, it may activate the Sensor Node, provided that the SNC_SW_CTRL bit-field is also set. If not, then the specific bit-field is not effective and Sensor Node's actual enable is controller by the Power Domains Controller (PDC).
Note: When SNC_SW_CTRL bit-field is set, the Sensor Node is controlled by the user. Thus, in that mode, it can be started and stopped by setting and resetting the SNC_EN field. When SNC_EN is reset, the Sensor Node will first complete the last on-going command before being halted.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SNC_LP_TIMER_REG</name>
	<description>Sensor Node Low-Power Timer Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LP_TIMER</name>
	<description>This bit-field returns the current value of the Sensor Node's 8-bit timer, running with the low-power clock and may be used for debugging purposes. The specific timer is used to implement a delay of up to 256 ticks of the low-power clock.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SNC_PC_REG</name>
	<description>Sensor Node Program Counter</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x20000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PC_REG</name>
	<description>This bit-field returns the Sensor Node's program counter bits [18:2], which at the same time is the program counter's offset from the starting address of SYSRAM (0x20.000.000), and it is can be set by the user, as soon as Sensor Node has been stopped.
The 13 MSBs of the program counter are tied to '0x400', since the Sensor Node always executes from SYSRAM, while its 2 LSBs are always tied to '0', since memory accesses are always of 32-bit.
NOTE: The Sensor Node can be stopped by clearing the SNC_EN bit-field of SNC_CTRL_REG and provided that the Power Domains Controller (PDC) is bypassed. The latter can be done by setting to '1' the SNC_SW_CTRL bit-field of SNC_CTRL_REG.</description>
	<bitRange>[18:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SNC_R1_REG</name>
	<description>Sensor Node core - Operand 1 Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R1_REG</name>
	<description>Returns the current value of the first 32-bit of the last SNC command executed.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SNC_R2_REG</name>
	<description>Sensor Node core - Operand 2 Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R2_REG</name>
	<description>Returns the current value of the second 32-bit word of the last SNC command executed. This is useful for the SNC commands composed by two 32-bit words.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SNC_STATUS_REG</name>
	<description>Sensor Node Status Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SNC_PC_LOADED</name>
	<description>0 : Sensor node's program counter is controlled by the Sensor Node's FSM, incemented by 4 after the fetching of each 32-bit command word.
1 : Sensor node's program counter is loaded with a new value. The assertion of this signal requires the Sensor Node to have been first stopped, so the user must first check that the SNC_IS_STOPPED bit-field of this register is asserted, before writing the program counter. The SNC_PC_LOADED bit-field is auto-clear and it is reset to '0' as soon as the user has re-started the Sensor Node.
Note: To start and stop the Sensor Node manually, the SNC_SW_CTRL and SNC_EN bit-fields of SNC_CTRL_REG must have been set by the user. This mode of operation is bypassing the Power Domains Controller and it is to be used for debugging purposes.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SNC_IS_STOPPED</name>
	<description>0 : Sensor Node is operational and its FSM is running.
1 : Sensor Node is stopped and its FSM is halted.To leave this state, the SNC_EN bit-field of SNC_CTRL_REG must be set, provided that the SNC_SW_CTRL bit-field of the same register is also set. This mode is used for debugging purposes, bypassing the enable of SNC coming from the Power Domains Controller.
Note: The SNC_PC_REG register can be modified by SW if and only if the SNC_IS_STOPPED bit is set. Otherwise, the writes to SNC_PC_REG are discarded.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HARD_FAULT_STATUS</name>
	<description>0 : No opcode error has occurred, Sensor Node continues normally.
1 : An opcode error has occurred. Sensor Node will continue its execution, but will set also the specific bit-field to '1', for debugging purposes.
Note: After being set, this bit-field will be cleared only when the Sensor Node is re-initialized, by starting again from its base address. The latter can happen either by activating the SNC_RESET bit-field of SNC_CTRL_REG or by stopping and starting again the Sensor Node. This is possible only when the PDC is bypassed, so when the Sensor Node is controlled by SNC_EN and SNC_SW_CTRL bit-fields of SNC_CTRL_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUS_ERROR_STATUS</name>
	<description>0 : No system bus error detected, Sensor Node continues normally
1 : Bus error occurred. Sensor Node will continue, but it will also set the specific flag, which can be used for debugging purposes.
Note: This bit-field will be reset to '0' only when the Sensor Node is re-initialized, by starting again from its base address.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SNC_DONE_STATUS</name>
	<description>0 : Sensor Node has not yet completed the target program's execution.
1 : Sensor Node has completed the targer program's execution. Together with the update of the status bit, a pulse is also generated to notify the PDC that the Sensor Node is done.
Note: This bit-field is set only when the &quot;SLP&quot; (sleep) command is executed, which should be issued after the completion of all pending tasks of the Sensor Node. It will be reset to '0' only when the Sensor Node re-starts, by executing from the base address.
This can be done by either toggling (de-asserting and re-asserting again) the SNC_EN bit-field of SNC_CTRL_REG, if the SNC is controlled by SW, or by just re-setting the SNC state via the SNC_RESET bit-field of the same register.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GR_FLAG</name>
	<description>Sensor Node's 'GR' (greater) flag. It can be modified either by the Sensor Node's core (by executing an &quot;RDCGR&quot; command) or by the Sensor Node's microcode, when the latter directly modifies the specific bit-field of SNC_STATUS_REG.
When the Sensor Node's FSM is in its initial state (which may happen either by switching-on the PD_COM power domain or by resetting the Sensor Node via SNC_CTRL_REG.SNC_RESET), the specific bit-field is kept to '0', for initialization purposes.
When the Sensor Node is stopped and then reset, the Sensor Node's FSM is not in its initial state and in that case, the GR_FLAG bit-field should be reset by the user (if the application needs this to be initialized to '0'). Otherwise, it can be left as it is, until being updated by the Sensor Node itself (upon executing an &quot;RDCGR&quot; command).
In general, however, this bit-field should not be modified by either the host processor (CM33) or the CMAC processor (CM0+), and especially when the Sensor Node is enabled and operational.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EQ_FLAG</name>
	<description>Sensor Node's 'EQ' (equalhigh) flag. It can be modified either by the Sensor Node's core (by executing an &quot;RDCBI&quot; command) or by the Sensor Node's microcode, when the latter directly modifies the specific bit-field of SNC_STATUS_REG.
When the Sensor Node's FSM is in its initial state (which may happen either by switching-on the PD_COM power domain or by resetting the Sensor Node via SNC_CTRL_REG.SNC_RESET), the specific bit-field is kept to '0', for initialization purposes.
When the Sensor Node is stopped and then reset, the Sensor Node's FSM is not in its initial state and in that case, the EQ_FLAG bit-field should be reset by the user (if the application needs this to be initialized to '0'). Otherwise, it can be left as it is, until being updated by the Sensor Node itself (upon executing an &quot;RDCBI&quot; command).
In general, however, this bit-field should not be modified by either the host processor (CM33) or the CMAC processor (CM0+), and especially when the Sensor Node is enabled and operational.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SNC_TMP1_REG</name>
	<description>Sensor Node core - Temporary Register 1</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TMP1_REG</name>
	<description>Returns the current value of the Sensor Node's first temporary register. To be used for debugging purposes.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SNC_TMP2_REG</name>
	<description>Sensor Node core - Temporary Register 2</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TMP2_REG</name>
	<description>Returns the current value of the Sensor Node's second temporary register. To be used for debugging purposes.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI</name>
	<version>1.0</version>
	<description>SPI registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SPI_CLEAR_INT_REG</name>
	<description>SPI clear interrupt register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_CLEAR_INT</name>
	<description>Writing any value to this register will clear the SPI_CTRL_REG[SPI_INT_BIT]
Reading returns 0. </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>SPI control register 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00a30000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_TX_FIFO_NOTFULL_MASK</name>
	<description>When 1, SPI Interrupt is generated when TX fifo is not full</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_TXREQ_MODE</name>
	<description>In case SPI_FIFO_MODE=3
0 = DMA TX request is generated when transaction is finished
1 = DMA TX request is generated when tx buffer is free</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_FIFO_EMPTY</name>
	<description>0 = Trasmit fifo is not empty
1 = Trasmit fifo is empty</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_FULL</name>
	<description>0 = Receive fifo is not full
1 = Receive fifo is full</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_EMPTY</name>
	<description>0 = Receive fifo is not empty
1 = Receive fifo is empty</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_9BIT_VAL</name>
	<description>Determines the value of the first bit in 9 bits SPI mode. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_BUSY</name>
	<description>0 = The SPI is not busy with a transfer. This means that either no TX-data is available or that the transfers have been suspended due to a full RX-FIFO. The SPI_CTRL_REG[SPI_INT_BIT] can be used to distinguish between these situations.
1 = The SPI is busy with a transfer. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_PRIORITY</name>
	<description>0 = The SPI has low priority, the DMA request signals are reset after the corresponding acknowledge.
1 = The SPI has high priority, DMA request signals remain
active until the FIFOS are filled/emptied, so the DMA holds the AHB bus. </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_MODE</name>
	<description>0 = TX-FIFO and RX-FIFO used (Bidirectional mode).
1 = RX-FIFO used (Read Only Mode) TX-FIFO single depth, no flow control
2 = TX-FIFO used (Write Only Mode), RX-FIFO single depth, no flow control
3 = No FIFOs used (backwards compatible mode) </description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_EN_CTRL</name>
	<description>0 = SPI_EN pin disabled in slave mode. Pin SPI_EN is don't care.
1 = SPI_EN pin enabled in slave mode. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MINT</name>
	<description>0 = Disable SPI_INT_BIT to ICU
1 = Enable SPI_INT_BIT to ICU.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_INT_BIT</name>
	<description>0 = RX Register or FIFO is empty.
1 = SPI interrupt. Data has been transmitted and receivedMust be reset by SW by writing to SPI_CLEAR_INT_REG. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_DI</name>
	<description>Returns the actual value of pin SPI_DIN (delayed with two internal SPI clock cycles) </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TXH</name>
	<description>0 = TX-FIFO is not full, data can be written.
1 = TX-FIFO is full, data can not be written. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_FORCE_DO</name>
	<description>0 = normal operation
1 = Force SPIDO output level to value of SPI_DO. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD</name>
	<description>00 = 8 bits mode
01 = 16 bit mode
10 = 32 bits mode
11 = 9 bits mode. Only valid in master mode. </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RST</name>
	<description>0 = normal operation
1 = Reset SPI. Same function as SPI_ON except that internal clock remain active. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_SMN</name>
	<description>Master/slave mode
0 = Master
1 = Slave</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DO</name>
	<description>Pin SPI_DO output level when SPI is idle or when SPI_FORCE_DO=1 </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK</name>
	<description>Select SPI_CLK clock output frequency in master mode:
00 = SPI_CLK / 8
01 = SPI_CLK / 4
10 = SPI_CLK / 2
11 = SPI_CLK / 14 </description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_POL</name>
	<description>Select SPI_CLK polarity.
0 = SPI_CLK is initially low.
1 = SPI_CLK is initially high. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_PHA</name>
	<description>Select SPI_CLK phase. See functional timing diagrams in SPI chapter</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ON</name>
	<description>0 = SPI Module switched off (power saving). Everything is reset except SPI_CTRL_REG. When this bit is cleared the SPI will remain active in master mode until the shift register and holding register are both empty.
1 = SPI Module switched on. Should only be set after all control bits have their desired values. So two writes are needed! </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_RX_TX_REG</name>
	<description>SPI RX/TX register0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_DATA</name>
	<description>Write: SPI_TX_REG output register 0 (TX-FIFO)
Read: SPI_RX_REG input register 0 (RX-FIFO)
In 8 or 9 bits mode bits 31 to 8 are not used, they contain old data.
In 16 bits mode bits 31 to 16 are not used, they contain old data. </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI2</name>
	<version>1.0</version>
	<description>SPI2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SPI2_CLEAR_INT_REG</name>
	<description>SPI clear interrupt register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_CLEAR_INT</name>
	<description>Writing any value to this register will clear the SPI_CTRL_REG[SPI_INT_BIT]
Reading returns 0. </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI2_CTRL_REG</name>
	<description>SPI control register 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00a30000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_TX_FIFO_NOTFULL_MASK</name>
	<description>When 1, SPI Interrupt is generated when TX fifo is not full</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_TXREQ_MODE</name>
	<description>In case SPI_FIFO_MODE=3
0 = DMA TX request is generated when transaction is finished
1 = DMA TX request is generated when tx buffer is free</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_FIFO_EMPTY</name>
	<description>0 = Trasmit fifo is not empty
1 = Trasmit fifo is empty</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_FULL</name>
	<description>0 = Receive fifo is not full
1 = Receive fifo is full</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_EMPTY</name>
	<description>0 = Receive fifo is not empty
1 = Receive fifo is empty</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_9BIT_VAL</name>
	<description>Determines the value of the first bit in 9 bits SPI mode. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_BUSY</name>
	<description>0 = The SPI is not busy with a transfer. This means that either no TX-data is available or that the transfers have been suspended due to a full RX-FIFO. The SPI_CTRL_REG[SPI_INT_BIT] can be used to distinguish between these situations.
1 = The SPI is busy with a transfer. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_PRIORITY</name>
	<description>0 = The SPI has low priority, the DMA request signals are reset after the corresponding acknowledge.
1 = The SPI has high priority, DMA request signals remain
active until the FIFOS are filled/emptied, so the DMA holds the AHB bus. </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_MODE</name>
	<description>0 = TX-FIFO and RX-FIFO used (Bidirectional mode).
1 = RX-FIFO used (Read Only Mode) TX-FIFO single depth, no flow control
2 = TX-FIFO used (Write Only Mode), RX-FIFO single depth, no flow control
3 = No FIFOs used (backwards compatible mode) </description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_EN_CTRL</name>
	<description>0 = SPI_EN pin disabled in slave mode. Pin SPI_EN is don't care.
1 = SPI_EN pin enabled in slave mode. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MINT</name>
	<description>0 = Disable SPI_INT_BIT to ICU
1 = Enable SPI_INT_BIT to ICU.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_INT_BIT</name>
	<description>0 = RX Register or FIFO is empty.
1 = SPI interrupt. Data has been transmitted and receivedMust be reset by SW by writing to SPI_CLEAR_INT_REG. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_DI</name>
	<description>Returns the actual value of pin SPI_DIN (delayed with two internal SPI clock cycles) </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TXH</name>
	<description>0 = TX-FIFO is not full, data can be written.
1 = TX-FIFO is full, data can not be written. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_FORCE_DO</name>
	<description>0 = normal operation
1 = Force SPIDO output level to value of SPI_DO. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD</name>
	<description>00 = 8 bits mode
01 = 16 bit mode
10 = 32 bits mode
11 = 9 bits mode. Only valid in master mode. </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RST</name>
	<description>0 = normal operation
1 = Reset SPI. Same function as SPI_ON except that internal clock remain active. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_SMN</name>
	<description>Master/slave mode
0 = Master
1 = Slave</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DO</name>
	<description>Pin SPI_DO output level when SPI is idle or when SPI_FORCE_DO=1 </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK</name>
	<description>Select SPI_CLK clock output frequency in master mode:
00 = SPI_CLK / 8
01 = SPI_CLK / 4
10 = SPI_CLK / 2
11 = SPI_CLK / 14 </description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_POL</name>
	<description>Select SPI_CLK polarity.
0 = SPI_CLK is initially low.
1 = SPI_CLK is initially high. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_PHA</name>
	<description>Select SPI_CLK phase. See functional timing diagrams in SPI chapter</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ON</name>
	<description>0 = SPI Module switched off (power saving). Everything is reset except SPI_CTRL_REG. When this bit is cleared the SPI will remain active in master mode until the shift register and holding register are both empty.
1 = SPI Module switched on. Should only be set after all control bits have their desired values. So two writes are needed! </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI2_RX_TX_REG</name>
	<description>SPI RX/TX register0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPI_DATA</name>
	<description>Write: SPI_TX_REG output register 0 (TX-FIFO)
Read: SPI_RX_REG input register 0 (RX-FIFO)
In 8 or 9 bits mode bits 31 to 8 are not used, they contain old data.
In 16 bits mode bits 31 to 16 are not used, they contain old data. </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SYS_WDOG</name>
	<version>1.0</version>
	<description>SYS_WDOG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WRITE_BUSY</name>
	<description>0 = A new WATCHDOG_REG[WDOG_VAL] can be written.
1 = No new WATCHDOG_REG[WDOG_VAL] can be written.
Note: It takes some time before the programmed WDOG_VAL is updated in the (independent) Watchdog timer. During this time it is not possible to write a new value to WATCHDOG_REG[WDOG_VAL].</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WDOG_FREEZE_EN</name>
	<description>0 = Watchdog timer can not be frozen when NMI_RST=0.
1 = Watchdog timer can be frozen/resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG] when NMI_RST=0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;= -16. Timer can be frozen/resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by Software.
Note that this bit can only be set to 1 by SW and only be reset with a WDOG (SYS) reset or SW reset.
The watchdog is always frozen when the Cortex-M33 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001fff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WDOG_WEN</name>
	<description>Bit [31:14] = 0 = Write enable for Watchdog timer
else Write disable. This filter prevents unintentional presetting the watchdog with a SW run-away. </description>
	<bitRange>[31:14]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits [31-14] must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every ~10 msec (RC32K) or ~29 msec(RCX).
Bit 13 indicates a negative counter value. 2, 1, 0, 3FFF16, 3FFE16 etc. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
  If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
  if WDOG_VAL =3FF016 -&gt; WDOG reset -&gt; reload 1FFF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
  if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload 1FFF16
Note 1: The programmed value WDOG_VAL is updated in the (independent) Watchdog timer at the 2nd next RC32K or RCX clock tick.
Note 2: Select RC32K or RCX with CLK_RCX_REG[RCX_ENABLE]. The RC32K is selected by default.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER</name>
	<version>1.0</version>
	<description>TIMER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>76</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO3_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO3</name>
	<description>Gives the Capture time for event on GPIO3</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO4_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO4</name>
	<description>Gives the Capture time for event on GPIO4</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CLEAR_GPIO_EVENT_REG</name>
	<description>Timer clear gpio event register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>TIM_CLEAR_GPIO4_EVENT</name>
	<description>1 = Clear GPIO4 event. Return always 0</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO3_EVENT</name>
	<description>1 = Clear GPIO3 event. Return always 0</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO2_EVENT</name>
	<description>1 = Clear GPIO2 event. Return always 0</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO1_EVENT</name>
	<description>1 = Clear GPIO1 event. Return always 0</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAP_GPIO4_IRQ_EN</name>
	<description>0 = Event on GPIO4 does not create a CAPTIM interrrupt
1 = Event on GPIO4 creates a CAPTIM interrrupt</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO3_IRQ_EN</name>
	<description>0 = Event on GPIO3 does not create a CAPTIM interrrupt
1 = Event on GPIO3 creates a CAPTIM interrrupt</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO2_IRQ_EN</name>
	<description>0 = Event on GPIO2 does not create a CAPTIM interrrupt
1 = Event on GPIO2 creates a CAPTIM interrrupt</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO1_IRQ_EN</name>
	<description>0 = Event on GPIO1 does not create a CAPTIM interrrupt
1 = Event on GPIO1 creates a CAPTIM interrrupt</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN4_EVENT_FALL_EN</name>
	<description>Event input 4 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN3_EVENT_FALL_EN</name>
	<description>Event input 3 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = clock enabled
0 = clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = timer IRQ is unmasked
0 = timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = down
0 = up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_ONESHOT_MODE_EN</name>
	<description>Timer mode
1 = One shot enabled
0 = Counter enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO3_CONF_REG</name>
	<description>Timer gpio3 selection</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO3_CONF</name>
	<description>Select one of the 32 GPIOs as IN3, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO4_CONF_REG</name>
	<description>Timer gpio4 selection</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO4_CONF</name>
	<description>Select one of the 32 GPIOs as IN4, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_PRESCALER_REG</name>
	<description>Timer prescaler value</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency / (TIM_PRESCALER+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter valuew</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_PWM_DC_REG</name>
	<description>Timer pwm dc register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC / ( TIM_PWM_FREQ+1)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_PWM_FREQ_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency / (TIM_PWM_FREQ+1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_RELOAD_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_SHOTWIDTH_REG</name>
	<description>Timer Shot duration in shot mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_SHOTWIDTH</name>
	<description>Shot phase duration in oneshot mode</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO4_EVENT_PENDING</name>
	<description>When 1, GPIO4 event is pending.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO3_EVENT_PENDING</name>
	<description>When 1, GPIO3 event is pending.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO2_EVENT_PENDING</name>
	<description>When 1, GPIO2 event is pending.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO1_EVENT_PENDING</name>
	<description>When 1, GPIO1 event is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER2</name>
	<version>1.0</version>
	<description>TIMER2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER2_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = clock enabled
0 = clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = timer IRQ is unmasked
0 = timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = down
0 = up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_ONESHOT_MODE_EN</name>
	<description>Timer mode
1 = One shot enabled
0 = Counter enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_PRESCALER_REG</name>
	<description>Timer prescaler value</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency / (TIM_PRESCALER+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter valuew</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_PWM_DC_REG</name>
	<description>Timer pwm dc register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC / ( TIM_PWM_FREQ+1)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_PWM_FREQ_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency / (TIM_PWM_FREQ+1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_RELOAD_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_SHOTWIDTH_REG</name>
	<description>Timer Shot duration in shot mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_SHOTWIDTH</name>
	<description>Shot phase duration in oneshot mode</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER3</name>
	<version>1.0</version>
	<description>TIMER3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040a00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER3_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = clock enabled
0 = clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = timer IRQ is unmasked
0 = timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = down
0 = up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_PRESCALER_REG</name>
	<description>Timer prescaler value</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency / (TIM_PRESCALER+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter valuew</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_PWM_DC_REG</name>
	<description>Timer pwm dc register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC / ( TIM_PWM_FREQ+1)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_PWM_FREQ_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency / (TIM_PWM_FREQ+1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_RELOAD_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER4</name>
	<version>1.0</version>
	<description>TIMER4 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040b00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER4_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = clock enabled
0 = clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = timer IRQ is unmasked
0 = timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = down
0 = up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_PRESCALER_REG</name>
	<description>Timer prescaler value</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency / (TIM_PRESCALER+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter valuew</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_PWM_DC_REG</name>
	<description>Timer pwm dc register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC / ( TIM_PWM_FREQ+1)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_PWM_FREQ_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency / (TIM_PWM_FREQ+1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_RELOAD_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TRNG</name>
	<version>1.0</version>
	<description>TRNG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040c00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TRNG_CTRL_REG</name>
	<description>TRNG control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRNG_ENABLE</name>
	<description>0: Disable the TRNG
1: Enable the TRNG this signal is ignored when the FIFO is full</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRNG_FIFOLVL_REG</name>
	<description>TRNG FIFO level register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRNG_FIFOFULL</name>
	<description>1:FIFO full indication. This bit is cleared if the FIFO is read.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TRNG_FIFOLVL</name>
	<description>Number of 32 bit words of random data in the FIFO (max 31) until the FIFO is full. When it is 0 and TRNG_FIFOFULL is 1, it means the FIFO is full.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TRNG_VER_REG</name>
	<description>TRNG Version register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000103</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRNG_MAJ</name>
	<description>Major version number </description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TRNG_MIN</name>
	<description>Minor version number </description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TRNG_SVN</name>
	<description>SVN revision number </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART</name>
	<version>1.0</version>
	<description>UART registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_CTR</name>
	<description>Component Type Register </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PTIME_DLH7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLH6_5</name>
	<description>Divisor Latch (High): Bit[6:5] of the 8 bit DLH register</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELCOLR_DLH4</name>
	<description>Interrupt Enable Register: (read only) ELCOLR, this bit controls the method for clearing the status in the LSR register. This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.
Always 0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.
Divisor Latch (High): Bit[4] of the 8 bit DLH register</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_DLH3</name>
	<description>Interrupt Enable Register: reserved
Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_DLH2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_DLH1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_DLH0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>On Read Interrupt Identification Register :
Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled.
00 = disabled.
11 = enabled.
Bits[5:4],Reserved
Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write FIFO Control Register
Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full
Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full
Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1
Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
It is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.
Divisor Latch (High): (DLH) (Note: This register is placed in UART_IER_DLH_REG with offset 0x4)
Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3430312a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_UCV</name>
	<description>Component Version </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the uart is idle or inactive.
0 = uart is idle or inactive
1 =uart is busy (actively transferring data)
Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_CTR</name>
	<description>Component Type Register </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PTIME_DLH7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLH6_5</name>
	<description>Divisor Latch (High): Bit[6:5] of the 8 bit DLH register </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELCOLR_DLH4</name>
	<description>Interrupt Enable Register: ELCOLR (read only), this bit controls the method for clearing the status in the LSR register. This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.
0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.
Divisor Latch (High): Bit[4] of the 8 bit DLH register </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_DLH3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_DLH2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_DLH1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_DLH0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>On Read Interrupt Identification Register :
Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
Bits[5:4],Reserved
Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout.
On Write FIFO Control Register
Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full
Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full
Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1
Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_EXT</name>
	<description>Line Extended Control Register</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_MODE</name>
	<description>Transmit mode control bit. This bit is used to control the type of transmit mode during 9-bit data transfers.
1 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding Register (STHR) are 9-bit wide. The user needs to ensure that the THR/STHR register is written correctly for address/data.
Address: 9th bit is set to 1,
Data : 9th bit is set to 0.
Note: Transmit address register (TAR) is not applicable in this mode of operation.
0 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding register (STHR) are 8-bit wide. The user needs to program the address into Transmit Address Register (TAR) and data into the THR/STHR register. SEND_ADDR bit is used as a control knob to indicate the uart on when to send the address.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SEND_ADDR</name>
	<description>Send address control bit. This bit is used as a control knob for the user to determine when to send the address during transmit mode.
1 = 9-bit character will be transmitted with 9-th bit set to 1 and the remaining 8-bits will match to what is being programmed in 'Transmit Address Register'.
0 = 9-bit character will be transmitted with 9-th bit set to 0 and the remaining 8-bits will be taken from the TXFIFO which is programmed through 8-bit wide THR/STHR register.
Note:
1. This bit is auto-cleared by the hardware, after sending out the address character. User is not expected to program this bit to 0.
2. This field is applicable only when DLS_E bit is set to 1 and TRANSMIT_MODE is set to 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ADDR_MATCH</name>
	<description>Address Match Mode.This bit is used to enable the address match feature during receive.
1 = Address match mode; uart will wait until the incoming character with 9-th bit set to 1. And further checks to see if the address matches with what is programmed in 'Receive Address Match Register'. If match is found, then sub-sequent characters will be treated as valid data and DW_apb_uart starts receiving data.
0 = Normal mode; DW_apb_uart will start to receive the data and 9-bit character will be formed and written into the receive RXFIFO. User is responsible to read the data and differentiate b/n address and data.
Note: This field is applicable only when DLS_E is set to 1.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS_E</name>
	<description>Extension for DLS. This bit is used to enable 9-bit data for transmit and receive transfers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SP</name>
	<description>Stick Parity. (writeable only when UART is not busy USR[0] is 0); otherwise always writable and always readable. This bit is used to force parity value. When PEN, EPS and Stick Parity are set to 1, the parity bit is transmitted and checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a logic 0, then parity bit is transmitted and checked as a logic 1. If this bit is set to 0, Stick Parity is disabled. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>UART_ADDR_RCVD</name>
	<description>Address Received Bit.
If 9Bit data mode (LCR_EXT[0]=1) is enabled, this bit is used to indicate the 9th bit of the receive data is set to 1. This bit can also be used to indicate whether the incoming character is address or data.
1 = Indicates the character is address.
0 = Indicates the character is data.
In the FIFO mode, since the 9th bit is associated with a character received, it is revealed when the character with the 9th bit set to 1 is at the top of the FIFO.
Reading the LSR clears the 9BIT.
Note: User needs to ensure that interrupt gets cleared (reading LSR register) before the next address byte arrives. If there is a delay in clearing the interrupt, then Software will not be able to distinguish between multiple address related interrupt. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled as described in &quot;Auto Flow Control&quot;.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
Data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n) are looped back to the inputs, internally.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_RAR_REG</name>
	<description>Receive Address Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_RAR</name>
	<description>This is an address matching register during receive mode. If the 9-th bit is set in the incoming character then the remaining 8-bits will be checked against this register value. If the match happens then sub-sequent characters with 9-th bit set to 0 will be treated as data byte until the next address byte is received.
Note:
- This register is applicable only when 'ADDR_MATCH'(LCR_EXT[1] and 'DLS_E' (LCR_EXT[0]) bits are set to 1.
RAR should be programmed only when UART is not busy.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>RBR_THR_9BIT</name>
	<description>When 9BIT_DATA_EN, On read :Receive Buffer bit 8 - On write Transmit Buffer bit 8 when LCR_EXT[3]=1</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.
Divisor Latch (High): (DLH) (Note: This register is placed in UART_IER_DLH_REG with offset 0x4)
Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, (active MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TAR_REG</name>
	<description>Transmit Address Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_TAR</name>
	<description>This is an address matching register during transmit mode. If DLS_E (LCR_EXT[0]) bit is enabled, then uart will send the 9-bit character with 9-th bit set to 1 and remaining 8-bit address will be sent from this register provided 'SEND_ADDR' (LCR_EXT[2]) bit is set to 1.
Note:
- This register is used only to send the address. The normal data should be sent by programming THR register.
- Once the address is started to send on the DW_apb_uart serial lane, then 'SEND_ADDR' bit will be auto-cleared by the hardware.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3430312a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_UCV</name>
	<description>Component Version </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART3</name>
	<version>1.0</version>
	<description>UART3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART3_CONFIG_REG</name>
	<description>ISO7816 Config Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ISO7816_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ENABLE</name>
	<description>0 : Normal Uart
1 : ISO7816 Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_SIG_EN</name>
	<description>0 : Error Signal feature disabled
1 : Error Signal feature enabled
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CONVENTION</name>
	<description>0 : Direct convention
1 : Inverse convention
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_CTRL_REG</name>
	<description>ISO7816 Control Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ISO7816_AUTO_GT</name>
	<description>0 : uart sends when tx data is available
1 : uart sends new character after guard time
</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_VALUE_IRQMASK</name>
	<description>0 : ERR_TX_VALUE IRQ is masked
1 : ERR_TX_VALUE IRQ is enabled
</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_TIME_IRQMASK</name>
	<description>0 : ERR_TX_TIME IRQ is masked
1 : ERR_TX_TIME IRQ is enabled
</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EXPIRED_IRQMASK</name>
	<description>0 : timer expired IRQ is masked
1 : timer expired IRQ is enabled
</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_STATUS</name>
	<description>0 : iso7816 clock is stopped
1 : iso7816 clock is running
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ISO7816_CLK_LEVEL</name>
	<description>0 : iso7816 clock level low when stopped
1 : iso7816 clock level high when stopped
</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_EN</name>
	<description>0 : iso7816 clock disabled
1 : iso7816 clock enabled
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_DIV</name>
	<description>ISO7816 clk freq = sclk/(2*(ISO7816_CLK_DIV+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_CTR</name>
	<description>Component Type Register </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART3_ERR_CTRL_REG</name>
	<description>ISO7816 Error Signal Control Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000010e</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ISO7816_ERR_PULSE_WIDTH</name>
	<description>When Error Signal feature is enable and receive mode, it gives the width of the error signal in 1/16etu</description>
	<bitRange>[8:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_PULSE_OFFSET</name>
	<description>When Error Signal feature is enable and receive mode, it gives the offset of the error signal in 1/16etu from the 9.6etu</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PTIME_DLH7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLH6_5</name>
	<description>Divisor Latch (High): Bit[6:5] of the 8 bit DLH register </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELCOLR_DLH4</name>
	<description>Interrupt Enable Register: ELCOLR (read only), this bit controls the method for clearing the status in the LSR register. This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.
0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.
Divisor Latch (High): Bit[4] of the 8 bit DLH register </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_DLH3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_DLH2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_DLH1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_DLH0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>On Read Interrupt Identification Register :
Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
Bits[5:4],Reserved
Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout.
On Write FIFO Control Register
Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full
Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full
Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1
Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_IRQ_STATUS_REG</name>
	<description>ISO7816 Interrupt Status Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ISO7816_ERR_TX_VALUE_IRQ</name>
	<description>On read
1 : : If error signal is enabled and in transmit mode, module generates IRQ when receiver does not receive correctly the character
On Write
1 : Clear IRQ
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_TIME_IRQ</name>
	<description>On read
1 : If error signal is enabled and in transmit mode, module generates IRQ when it checks the error signal
On Write
1 : Clear IRQ
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EXPIRED_IRQ</name>
	<description>On read
1 : when Timer is expired. Timer has to be disabled to clear the IRQ. When sclk is lower than pclk then this bit has to be checked if it's cleared before return form the IRQ Handler
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_LCR_EXT</name>
	<description>Line Extended Control Register</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_MODE</name>
	<description>Transmit mode control bit. This bit is used to control the type of transmit mode during 9-bit data transfers.
1 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding Register (STHR) are 9-bit wide. The user needs to ensure that the THR/STHR register is written correctly for address/data.
Address: 9th bit is set to 1,
Data : 9th bit is set to 0.
Note: Transmit address register (TAR) is not applicable in this mode of operation.
0 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding register (STHR) are 8-bit wide. The user needs to program the address into Transmit Address Register (TAR) and data into the THR/STHR register. SEND_ADDR bit is used as a control knob to indicate the uart on when to send the address.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SEND_ADDR</name>
	<description>Send address control bit. This bit is used as a control knob for the user to determine when to send the address during transmit mode.
1 = 9-bit character will be transmitted with 9-th bit set to 1 and the remaining 8-bits will match to what is being programmed in 'Transmit Address Register'.
0 = 9-bit character will be transmitted with 9-th bit set to 0 and the remaining 8-bits will be taken from the TXFIFO which is programmed through 8-bit wide THR/STHR register.
Note:
1. This bit is auto-cleared by the hardware, after sending out the address character. User is not expected to program this bit to 0.
2. This field is applicable only when DLS_E bit is set to 1 and TRANSMIT_MODE is set to 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ADDR_MATCH</name>
	<description>Address Match Mode.This bit is used to enable the address match feature during receive.
1 = Address match mode; uart will wait until the incoming character with 9-th bit set to 1. And further checks to see if the address matches with what is programmed in 'Receive Address Match Register'. If match is found, then sub-sequent characters will be treated as valid data and DW_apb_uart starts receiving data.
0 = Normal mode; DW_apb_uart will start to receive the data and 9-bit character will be formed and written into the receive RXFIFO. User is responsible to read the data and differentiate b/n address and data.
Note: This field is applicable only when DLS_E is set to 1.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS_E</name>
	<description>Extension for DLS. This bit is used to enable 9-bit data for transmit and receive transfers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SP</name>
	<description>Stick Parity. (writeable only when UART is not busy USR[0] is 0); otherwise always writable and always readable. This bit is used to force parity value. When PEN, EPS and Stick Parity are set to 1, the parity bit is transmitted and checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a logic 0, then parity bit is transmitted and checked as a logic 1. If this bit is set to 0, Stick Parity is disabled. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>UART_ADDR_RCVD</name>
	<description>Address Received Bit.
If 9Bit data mode (LCR_EXT[0]=1) is enabled, this bit is used to indicate the 9th bit of the receive data is set to 1. This bit can also be used to indicate whether the incoming character is address or data.
1 = Indicates the character is address.
0 = Indicates the character is data.
In the FIFO mode, since the 9th bit is associated with a character received, it is revealed when the character with the 9th bit set to 1 is at the top of the FIFO.
Reading the LSR clears the 9BIT.
Note: User needs to ensure that interrupt gets cleared (reading LSR register) before the next address byte arrives. If there is a delay in clearing the interrupt, then Software will not be able to distinguish between multiple address related interrupt. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled as described in &quot;Auto Flow Control&quot;.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
Data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n) are looped back to the inputs, internally.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_RAR_REG</name>
	<description>Receive Address Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_RAR</name>
	<description>This is an address matching register during receive mode. If the 9-th bit is set in the incoming character then the remaining 8-bits will be checked against this register value. If the match happens then sub-sequent characters with 9-th bit set to 0 will be treated as data byte until the next address byte is received.
Note:
- This register is applicable only when 'ADDR_MATCH'(LCR_EXT[1] and 'DLS_E' (LCR_EXT[0]) bits are set to 1.
RAR should be programmed only when UART is not busy.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>RBR_THR_9BIT</name>
	<description>When 9BIT_DATA_EN, On read :Receive Buffer bit 8 - On write Transmit Buffer bit 8 when LCR_EXT[3]=1</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.
Divisor Latch (High): (DLH) (Note: This register is placed in UART_IER_DLH_REG with offset 0x4)
Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART3_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, (active MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_TAR_REG</name>
	<description>Transmit Address Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_TAR</name>
	<description>This is an address matching register during transmit mode. If DLS_E (LCR_EXT[0]) bit is enabled, then uart will send the 9-bit character with 9-th bit set to 1 and remaining 8-bit address will be sent from this register provided 'SEND_ADDR' (LCR_EXT[2]) bit is set to 1.
Note:
- This register is used only to send the address. The normal data should be sent by programming THR register.
- Once the address is started to send on the DW_apb_uart serial lane, then 'SEND_ADDR' bit will be auto-cleared by the hardware.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_TIMER_REG</name>
	<description>ISO7816 Timer Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ISO7816_TIM_MODE</name>
	<description>0 : Timer will count up to max value then stops. Timer has to be disabled and enabled again to restart. Timer is clocked with the ISO7816 clock
1 : Timer will count guard time. ISO7816_TIM_MAX has to be 16*GuardTime-1
</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EN</name>
	<description>0 : Timer is disabled
1 : Timer is enabled
</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_MAX</name>
	<description>On write : timer will count from 0 to ISO7816_TIM_MAX
On read : gives the current timer value
</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART3_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3430312a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_UCV</name>
	<description>Component Version </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART3_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>USB</name>
	<version>1.0</version>
	<description>USB registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>432</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>USB_ALTEV_REG</name>
	<description>Alternate Event Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RESUME</name>
	<description>Resume
Resume signalling is detected on the USB when the device is in Suspend state (NFS in the NFSR register is set to SUSPEND), and a non IDLE signal is present on the USB, indicating that this device should begin it's wake-up sequence and enter Operational state. This bit is cleared when the register is read. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RESET</name>
	<description>Reset
This bit is set to 1, when 2.5 us of SEO have been detected on the upstream port. In response, the functional state should be reset (NFS in the NFSR register is set to RESET), where it must remain for at least 100 us. The functional state can then return to Operational state. This bit is cleared when the register is read </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_SD5</name>
	<description>Suspend Detect 5 ms
This bit is set to 1 after 5 ms of IDLE have been detected on the upstream port, indicating that this device is permitted to perform a remote wake-up operation. The resume may be initiated under firmware control by writing the resume value to the NFSR register. This bit is cleared when the register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_SD3</name>
	<description>Suspend Detect 3 ms
This bit is set to 1 after 3 ms of IDLE have been detected on the upstream port, indicating that the device should be suspended. The suspend occurs under firmware control by writing the suspend value to the Node Functional State (NFSR) register. This bit is cleared when the register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EOP</name>
	<description>End of Packet
A valid EOP sequence was been detected on the USB. It is used when this device has initiated a Remote wake-up sequence to indicate that the Resume sequence has been acknowledged and completed by the host. This bit is cleared when the register is read. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_ALTMSK_REG</name>
	<description>Alternate Mask Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_RESUME</name>
	<description>A bit set to 1 in this register enables automatic setting of the ALT bit in the MAEV register when the respective event in the ALTEV register occurs. Otherwise, setting MAEV.ALT bit is disabled.
Same Bit Definition as ALTEV Register </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_RESET</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_SD5</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_SD3</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_EOP</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_CHARGER_CTRL_REG</name>
	<description>USB Charger Control Register</description>
	<addressOffset>0x000001a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IDM_SINK_ON</name>
	<description>0 = Disable
1 = Enable the Idm_sink to USBm</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IDP_SINK_ON</name>
	<description>0 = Disable
1 = Enable the Idp_sink to USBp</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDM_SRC_ON</name>
	<description>0 = Disable
1 = Enable Vdm_src to USBm and USB_DCP_DET status bit.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDP_SRC_ON</name>
	<description>0 = Disable
1 = Enable the Vdp_src to USB_CHG_DET status bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IDP_SRC_ON</name>
	<description>0 = Disable
1 = Enable the Idp_src and Rdm_dwn.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_CHARGE_ON</name>
	<description>0 = Disable USB charger detect circuit.
1 = Enable USB charger detect circuit.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_CHARGER_STAT_REG</name>
	<description>USB Charger Status Register</description>
	<addressOffset>0x000001ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_DM_VAL2</name>
	<description>0 = USBm &lt;2.3V
1 = USBm &gt;2.5V</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DP_VAL2</name>
	<description>0: USBp &lt; 2.3V
1: USBp &gt; 2.5V</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DM_VAL</name>
	<description>0 = USBm &lt; 0.8V
1 = USBm &gt; 1.5V (PS2 or Proprietary Charger)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DP_VAL</name>
	<description>0 = USBp &lt; 0.8V
1 = USBp &gt; 1.5V</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_CHG_DET</name>
	<description>0 = Standard downstream or nothing connected.
1 = Charging Downstream Port (CDP) or Dedicated Charging.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DCP_DET</name>
	<description>0 = Charging downstream port is detected.
1 = Dedicated charger is detected.
Control bit VDM_SRC_ON must be set to validate this status bit.
Note: This register shows the actual status.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_DMA_CTRL_REG</name>
	<description>USB DMA control register</description>
	<addressOffset>0x000001a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_DMA_EN</name>
	<description>0 = USB DMA control off. (Normal operation)
1 = USB_DMA on. DMA channels 0 and 1 are connected by
USB Endpoint according bits USB_DMA_TX and USB_DMA_RX</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DMA_TX</name>
	<description>000 = DMA channels 1 is connected Tx USB Endpoint 1
001 = DMA channels 1 is connected Tx USB Endpoint 3
010 = DMA channels 1 is connected Tx USB Endpoint 5
100, 1xx = Reserved</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DMA_RX</name>
	<description>000 = DMA channels 0 is connected Rx USB Endpoint 2
001 = DMA channels 0 is connected Rx USB Endpoint 4
010 = DMA channels 0 is connected Rx USB Endpoint 6
100, 1xx = Reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EP0_NAK_REG</name>
	<description>EP0 INNAK and OUTNAK Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_EP0_OUTNAK</name>
	<description>End point 0 OUT NAK
This bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1) in response to an OUT token. This bit is not set if NAK is generated as result of an overrun condition. It is cleared when the register is read. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_EP0_INNAK</name>
	<description>End point 0 IN NAK
This bit is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1) in response to an IN token. This bit is cleared when the register is read. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_EPC0_REG</name>
	<description>Endpoint Control 0 Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
- The transmit FIFO is enabled and an IN token is received.
- The receive FIFO is enabled and an OUT token is received.
Note: A SETUP token does not cause a STALL handshake to be generated when this bit is set.
Upon transmitting the STALL handshake, the RX_LAST and the TX_DONE bits in the respective Receive/Transmit Status registers are set to 1. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DEF</name>
	<description>Default Address
When set to 1, the device responds to the default address regardless of the contents of FAR6-0/EP03-0 fields. When an IN packet is transmitted for the endpoint, the DEF bit is automatically cleared to 0.
This bit aids in the transition from default address to assigned address. The transition from the default address 00000000000b to an address assigned during bus enumeration may not occur in the middle of the SET_ADDRESS control sequence. This is necessary to complete the control sequence. However, the address must change immediately after this sequence finishes in order to avoid errors when another control sequence immediately follows the SET_ADDRESS command.
On USB reset, the firmware has 10 ms for set-up, and should write 8016 to the FAR register and 0016 to the EPC0 register. On receipt of a SET_ADDRESS command, the firmware must write 4016 to the EPC0 register and (8016 or &lt;assigned_function_address&gt;) to the FAR register. It must then queue a zero length IN packet to complete the status phase of the SET_ADDRESS control sequence. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This field holds the 4-bit Endpoint address. For Endpoint 0, these bits are hardwired to 0000b. Writing a 1 to any of the EP bits is ignored. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_EPC1_REG</name>
	<description>Endpoint Control Register 1</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EPC2_REG</name>
	<description>Endpoint Control Register 2</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EPC3_REG</name>
	<description>Endpoint Control Register 3</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EPC4_REG</name>
	<description>Endpoint Control Register 4</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EPC5_REG</name>
	<description>Endpoint Control Register 5</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_EPC6_REG</name>
	<description>Endpoint Control Register 6</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_FAR_REG</name>
	<description>Function Address Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_AD_EN</name>
	<description>Address Enable
When set to 1, USB address field bits 6-0 are used in address comparison
When cleared to 0, the device does not respond to any token on the USB bus.
Note: If the DEF bit in the Endpoint Control 0 register is set, Endpoint 0 responds to the default address. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_AD</name>
	<description>Address
This field holds the 7-bit function address used to transmit and receive all tokens addressed to this device. </description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_FNH_REG</name>
	<description>Frame Number High Byte Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c0</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_MF</name>
	<description>Missed SOF Flag
This flag is set to 1, when the frame number in a valid received SOF does not match the expected next value, or when an SOF is not received within 12060 bit times. This bit is set by the hardware and is cleared by reading the FNH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_UL</name>
	<description>Unlock Flag
This bit indicates that at least two frames were received without an expected frame number, or that no valid SOF was received within 12060 bit times. If this bit is set, the frame number from the next valid SOF packet is loaded in FN. This bit is set by the hardware and is cleared by reading the FNH register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RFC</name>
	<description>Reset Frame Count
Writing a 1 to this bit resets the frame number to 00016, after which this bit clears itself to 0 again. This bit always reads 0. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_FN_10_8</name>
	<description>Frame Number
This 3-bit field contains the three most significant bits (MSB) of the current frame number, received in the last SOF packet. If a valid frame number is not received within 12060 bit times (Frame Length Maximum, FLMAX, with tolerance) of the previous change, the frame number is incremented artificially. If two successive frames are missed or are incorrect, the current FN is frozen and loaded with the next frame number from a valid SOF packet.
If the frame number low byte was read by firmware before reading the FNH register, the user actually reads the contents of a buffer register which holds the value of the three frame number bits of this register when the low byte was read. Therefore, the correct sequence to read the frame number is: FNL, FNH. Read operations to the FNH register, without first reading the Frame Number Low Byte (FNL) register directly, read the actual value of the three MSBs of the frame number. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_FNL_REG</name>
	<description>Frame Number Low Byte Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_FN</name>
	<description>The Frame Number Low Byte Register holds the low byte of the frame number. To ensure consistency, reading this low byte causes the three frame number bits in the FNH register to be locked until this register is read. The correct sequence to read the frame number is: FNL, FNH. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_FWEV_REG</name>
	<description>FIFO Warning Event Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXWARN31</name>
	<description>Receive Warning n: 3:1
The bit n is set to 1 when the respective receive endpoint FIFO reaches the warning limit, as specified by the RFWL bits of the respective EPCx register. This bit is cleared when the warning condition is cleared by either reading data from the FIFO or when the FIFO is flushed. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TXWARN31</name>
	<description>Transmit Warning n: 3:1
The bit n is set to 1 when the respective transmit endpoint FIFO reaches the warning limit, as specified by the TFWL bits of the respective TXCn register, and transmission from the respective endpoint is enabled. This bit is cleared when the warning condition is cleared by either writing new data to the FIFO when the FIFO is flushed, or when transmission is done, as indicated by the TX_DONE bit in the TXSn register. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_FWMSK_REG</name>
	<description>FIFO Warning Mask Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_RXWARN31</name>
	<description>The FIFO Warning Mask Register selects, which FWEV bits are reported in the MAEV register. A bit set to 1 and the corresponding bit in the FWEV register is set 1, causes the WARN bit in the MAEV register to be set to 1. When cleared to 0, the corresponding bit in the FWEV register does not cause WARN to be set to 1. Same Bit Definition as FWEV Register </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_TXWARN31</name>
	<description>The FIFO Warning Mask Register selects, which FWEV bits are reported in the MAEV register. A bit set to 1 and the corresponding bit in the FWEV register is set 1, causes the WARN bit in the MAEV register to be set to 1. When cleared to 0, the corresponding bit in the FWEV register does not cause WARN to be set to 1. Same Bit Definition as FWEV Register </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_MAEV_REG</name>
	<description>Main Event Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_CH_EV</name>
	<description>USB Charger event
This bit is set if one of the bits in USB_CHARGER_STAT_REG[2-0] change. This bit is cleared to 0 when if USB_CHARGER_STAT_REG is read. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP0_NAK</name>
	<description>Endpoint 0 NAK Event
This bit is an OR of EP0_NAK_REG[EP0_OUTNAK] and EP0_NAK_REG[EP0_INNAK] bits. USB_EP0_NAK is cleared to 0 when EP0_NAK_REG is read. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP0_RX</name>
	<description>Endpoint 0 Receive Event
This bit is a copy of the RXS0[RX_LAST] and is cleared to 0 when this RXS0 register is read.
Note: Since Endpoint 0 implements a store and forward principle, an overrun condition for FIFO0 cannot occur </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_EP0_TX</name>
	<description>Endpoint 0 Transmit Event
This bit is a copy of the TXS0[TX_DONE] bit and is cleared to 0 when the TXS0 register is read.
Note: Since Endpoint 0 implements a store and forward principle, an underrun condition for FIFO0 cannot occur. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_INTR</name>
	<description>Master Interrupt Enable
This bit is hardwired to 0 in the Main Event (MAEV) register; bit 7 in the Main Mask (MAMSK) register is the Master Interrupt Enable. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RX_EV</name>
	<description>Receive Event
This bit is set to 1 if any of the unmasked bits in the Receive Event (RXEV) register is set to 1. It indicates that a SETUP or OUT transaction has been completed. This bit is cleared to 0 when all of the RX_LAST bits in each Receive Status (RXSn) register and all RXOVRRN bits in the RXEV register are cleared to 0. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ULD</name>
	<description>Unlocked/Locked Detected
This bit is set to 1, when the frame timer has either entered unlocked condition from a locked condition, or has re-entered a locked condition from an unlocked condition as determined by the UL bit in the Frame Number (FNH or FNL) register. This bit is cleared to 0 when the register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_NAK</name>
	<description>Negative Acknowledge Event
This bit indicates that one of the unmasked NAK Event (NAKEV) register bits has been set to 1. This bit is cleared to 0 when the NAKEV register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FRAME</name>
	<description>Frame Event
This bit is set to 1, if the frame counter is updated with a new value. This can be due to the receipt of a valid SOF packet on the USB or to an artificial update if the frame counter was unlocked or a frame was missed. This bit is cleared to 0 when the register is read. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TX_EV</name>
	<description>Transmit Event
This bit is set to 1, if any of the unmasked bits in the Transmit Event (TXEV) register (TXFIFOn or TXUNDRNn) is set to 1. Therefore, it indicates that an IN transaction has been completed. This bit is cleared to 0 when all the TX_DONE bits and the TXUNDRN bits in each Transmit Status (TXSn) register are cleared to 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_ALT</name>
	<description>Alternate Event
This bit indicates that one of the unmasked ALTEV register bits has been set to 1. This bit is cleared to 0 by reading the ALTEV register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_WARN</name>
	<description>Warning Event
This bit indicates that one of the unmasked bits in the FIFO Warning Event (FWEV) register has been set to 1. This bit is cleared to 0 by reading the FWEV register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_MAMSK_REG</name>
	<description>Main Mask Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_CH_EV</name>
	<description>The Main Mask Register masks out events reported in the MAEV registers. A bit set to 1, enables the interrupts for the respective event in the MAEV register. If the corresponding bit is cleared to 0, interrupt generation for this event is disabled. Same Bit Definition as MAEV Register </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_EP0_NAK</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_EP0_RX</name>
	<description>Same Bit Definition as MAEV Register</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_EP0_TX</name>
	<description>Same Bit Definition as MAEV Register</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_INTR</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_RX_EV</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_ULD</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_NAK</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_FRAME</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_TX_EV</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_ALT</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_WARN</name>
	<description>Same Bit Definition as MAEV Register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_MCTRL_REG</name>
	<description>Main Control Register)</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSMODE</name>
	<description>Low Speed Mode
This bit enables USB 1.5 Mbit/s low speed and swaps D+ and D- pull-up resistors. Changing speed may only be done if USBEN is set to 0.
Also D+ and D- rise and fall times are adjusted according to the USB specification. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_NAT</name>
	<description>Node Attached
This bit indicates that this node is ready to be detected as attached to USB. When cleared to 0 the transceiver forces SE0 on the USB port to prevent the hub (to which this node is connected to) from detecting an attach event. After reset or when the USB node is disabled, this bit is cleared to 0 to give the device time before it must respond to commands. After this bit has been set to 1, the device no longer drives the USB and should be ready to receive Reset signalling from the hub.
Note: This bit can only be set is USBEN is '1' </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DBG</name>
	<description>Debug Mode.
When this bit is set, the following registers are writable: Main Event (MAEV), Alternate Event (ALTEV), NAK Event (NAKEV), Transmit Status and Receive Status. Setting the DBG bit forces the node into a locked state. The node states can be read out of the transceiver diagnostic register (XCVDIAG) at location 0xFF6802 by setting the DIAG bit in the Test Control register (UTR).
Note: The operation of CoR bits is not effected by entering Debug mode) Note: This bit can only be set is USBEN is '1' </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USBEN</name>
	<description>USB EnableSetting this bit to 1 enables the Full/Low Speed USB node. If the USBEN bit is cleared to 0, the USB is disabled and the 48 MHz clock within the USB node is stopped. In addition, all USB registers are set to their reset state.
Note that the transceiver forces SE0 on the bus to prevent the hub to detected the USB node, when it is disabled (not attached).
The USBEN bit is cleared to 0 after reset </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_NAKEV_REG</name>
	<description>NAK Event Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_OUT31</name>
	<description>OUT n: 3:1
The bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1 and EP_EN in the EPCx register is set to 1) in response to an OUT token. This bit is not set if NAK is generated as result of an overrun condition. It is cleared when the register is read. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_IN31</name>
	<description>IN n: 3:1
The bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the Function Address, FAR, register is set to 1 and EP_EN in the Endpoint Control, EPCx, register is set to 1) in response to an IN token. This bit is cleared when the register is read. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_NAKMSK_REG</name>
	<description>NAK Mask Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_OUT31</name>
	<description>When set and the corresponding bit in the NAKEV register is set, the NAK bit in the MAEV register is set. When cleared, the corresponding bit in the NAKEV register does not cause NAK to be set. Same Bit Definition as NAKEV Register </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_IN31</name>
	<description>Same Bit Definition as NAKEV Register </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_NFSR_REG</name>
	<description>Node Functional State Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_NFS</name>
	<description>The Node Functional State Register reports and controls the current functional state of the USB node.
00: NodeReset.
This is the USB Reset state. This is entered upon a module reset or by software upon detection of a USB Reset. Upon entry, all endpoint pipes are disabled. DEF in the Endpoint Control 0 (EPC0) register and AD_EN in the Function Address (FAR) register should be cleared by software on entry to this state. On exit, DEF should be reset so the device responds to the default address.
01: NodeResume
In this state, resume signalling is generated. This state should be entered by firmware to initiate a remote wake-up sequence by the device. The node must remain in this state for at least 1 ms and no more than 15 ms.
10: NodeOperational
This is the normal operational state. In this state the node is configured for operation on the USB bus.
11: NodeSuspend
Suspend state should be entered by firmware on detection of a Suspend event while in Operational state. While in Suspend state, the transceivers operate in their low-power suspend mode. All endpoint controllers and the bits TX_EN, LAST and RX_EN are reset, while all other internal states are frozen. On detection of bus activity, the RESUME bit in the ALTEV register is set. In response, software can cause entry to NodeOperational state. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXC0_REG</name>
	<description>Receive Command 0 Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_FLUSH</name>
	<description>Flush
Writing a 1 to this bit flushes all data from the control endpoint FIFOs, resets the endpoint to Idle state, clears the FIFO read and write pointer, and then clears itself. If the endpoint is currently using FIFO0 to transfer data on USB, flushing is delayed until after the transfer is done. This bit is cleared to 0 on reset. This bit is equivalent to FLUSH in the TXC0 register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_IGN_OUT</name>
	<description>Ignore OUT Tokens
When this bit is set to 1, the endpoint ignores any OUT tokens directed to its configured address. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet reception is disabled after every data packet is received, or when a STALL handshake is returned in response to an OUT token. A 1 must be written to this bit to re-enable data reception. Reception of SETUP packets is always enabled. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet is received with no other intervening non-SETUP tokens, the Endpoint Controller discards the new SETUP packet and returns an ACK handshake. If any other reasons prevent the Endpoint Controller from accepting the SETUP packet, it must not generate a handshake. This allows recovery from a condition where the ACK of the first SETUP token was lost by the host. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXC1_REG</name>
	<description>Receive Command Register 1</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXC2_REG</name>
	<description>Receive Command Register 2</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXC3_REG</name>
	<description>Receive Command Register 3</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXD0_REG</name>
	<description>Receive Data 0 Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are removed from the incoming data stream automatically.
In TEST mode this register allow read/write access. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXD1_REG</name>
	<description>Receive Data Register,1</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXD2_REG</name>
	<description>Receive Data Register 2</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXD3_REG</name>
	<description>Receive Data Register 3</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXEV_REG</name>
	<description>Receive Event Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_RXOVRRN31</name>
	<description>Receive Overrun n: 3:1
The bit n is set to 1 in the event of an overrun condition in the corresponding receive FIFO n. They are cleared to 0 when the register is read. The firmware must check the respective RX_ERR bits that packets received for the other receive endpoints (EP2, EP4 and EP6, ) are not corrupted by errors, as these endpoints support data streaming (packets which are longer than the actual FIFO depth). </description>
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RXFIFO31</name>
	<description>Receive FIFO n: 3:1
The bit n is set to 1 whenever either RX_ERR or RX_LAST in the respective Receive Status register (RXSn) is set to 1. Reading the corresponding RXSn register automatically clears these bits.The CoR function is disabled, when the Freeze signal is asserted.The USB node discards all packets for Endpoint 0 received with errors. This is necessary in case of retransmission due to media errors, ensuring that a good copy of a SETUP packet is captured. Otherwise, the FIFO may potentially be tied up, holding corrupted data and unable to receive a retransmission of the same packet.
If data streaming is used for the receive endpoints (EP2, EP4 and EP6, EP8) the firmware must check the respective RX_ERR bits to ensure the packets received are not corrupted by errors. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXMSK_REG</name>
	<description>Receive Mask Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_RXOVRRN31</name>
	<description>The Receive Mask Register is used to select the bits of the RXEV registers, which causes the RX_EV bit in the MAEV register to be set to 1. When set to 1 and the corresponding bit in the RXEV register is set to 1, RX_EV bit in the MAEV register is set to1. When cleared to 0, the corresponding bit in the RXEV register does not cause RX_EV to be set to1. Same Bit Definition as RXEV Register </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_RXFIFO31</name>
	<description>Same Bit Definition as RXEV Register</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_RXS0_REG</name>
	<description>Receive Status 0 Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TOGGLE_RX0</name>
	<description>Toggle
This bit specified the PID used when receiving the packet. A value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last Bytes
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Count
This 4-bit field contains the number of bytes presently in the RX FIFO. This number is never larger than 8 for Endpoint 0. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXS1_REG</name>
	<description>Receive Status Register 1</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>USB_RXCOUNT</name>
	<description>it contains the number of bytes presently in the endpoint receive FIFO (range 0..64)</description>
	<bitRange>[14:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXS2_REG</name>
	<description>Receive Status Register 2</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>USB_RXCOUNT</name>
	<description>it contains the number of bytes presently in the endpoint receive FIFO (range 0..64)</description>
	<bitRange>[14:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_RXS3_REG</name>
	<description>Receive Status Register 3</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>USB_RXCOUNT</name>
	<description>it contains the number of bytes presently in the endpoint receive FIFO (range 0..64)</description>
	<bitRange>[14:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_TCR_REG</name>
	<description>Transceiver configuration Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_VADJ</name>
	<description>Reference Voltage/ Threshold voltage AdjustControls the single-ended receiver threshold.
Shall not be modified unless instructed by Dialog Semiconductor
Only enabled if USB_UTR_REG[7] = 1 </description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_CADJ</name>
	<description>Transmitter Current Adjust
Controls the driver edge rate control current.
Shall not be modified unless instructed by Dialog Semiconductor
Only enabled if USB_UTR_REG[7] = 1 </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXC0_REG</name>
	<description>Transmit command 0 Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_IGN_IN</name>
	<description>Ignore IN Tokens
When this bit is set to 1, the endpoint will ignore any IN tokens directed to its configured address. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the control endpoint FIFOs, resets the endpoint to Idle state, clears the FIFO read and write pointer, and then clears itself. If the endpoint is currently using the FIFO0 to transfer data on USB, flushing is delayed until after the transfer is done. It is equivalent to the FLUSH bit in the RXC0 register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TOGGLE_TX0</name>
	<description>Toggle
This bit specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated. This bit is not altered by the hardware. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet, or a STALL handshake, in response to an IN token. It must be set to 1 by firmware to start packet transmission. The RX_EN bit in the Receive Command 0 (RXC0) register takes precedence over this bit; i.e. if RX_EN is set, TX_EN bit is ignored until RX_EN is reset.
Zero length packets are indicated by setting this bit without writing any data to the FIFO. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXC1_REG</name>
	<description>Transmit Command Register 1</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXC2_REG</name>
	<description>Transmit Command Register 2</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXC3_REG</name>
	<description>Transmit Command Register 3</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXD0_REG</name>
	<description>Transmit Data 0 Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. The PID and CRC16 are created automatically. </description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>USB_TXD1_REG</name>
	<description>Transmit Data Register 1</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>USB_TXD2_REG</name>
	<description>Transmit Data Register 2</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>USB_TXD3_REG</name>
	<description>Transmit Data Register 3</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>USB_TXEV_REG</name>
	<description>Transmit Event Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TXUDRRN31</name>
	<description>Transmit Underrun n: 3:1
The bit n is a copy of the respective TX_URUN bit from the corresponding Transmit Status register (TXSn). Whenever any of the Transmit FIFOs underflows, the respective TXUDRRN bit is set to 1. These bits are cleared to 0 when the corresponding Transmit Status register is read </description>
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TXFIFO31</name>
	<description>Transmit FIFO n: 3:1
The bit n is a copy of the TX_DONE bit from the corresponding Transmit Status register (TXSn). A bit is set to 1 when the IN transaction for the corresponding transmit endpoint n has been completed. These bits are cleared to 0 when the corresponding TXSn register is read. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_TXMSK_REG</name>
	<description>Transmit Mask Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_M_TXUDRRN31</name>
	<description>The Transmit Mask Register is used to select the bits of the TXEV registers, which causes the TX_EV bit in the MAEV register to be set to 1. When a bit is set to 1 and the corresponding bit in the TXEV register is set to 1, the TX_EV bit in the MAEV register is set to1. When cleared to 0, the corresponding bit in the TXEV register does not cause TX_EV to be set to 1. Same Bit Definition as TXEV Register </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_M_TXFIFO31</name>
	<description>Same Bit Definition as TXEV Register</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_TXS0_REG</name>
	<description>Transmit Status 0 Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit indicates the status, as received from the host, of the ACK for the packet previously sent. This bit is to be interpreted when TX_DONE is set to 1. It is set to 1, when an ACK is received; otherwise, it remains cleared. This bit is also cleared to 0, when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that a packet has completed transmission. It is cleared to 0, when this register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field indicates the number of empty bytes available in the FIFO. This field is never larger than 8 for Endpoint 0. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_TXS1_REG</name>
	<description>Transmit Status Register 1</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_TXS2_REG</name>
	<description>Transmit Status Register 2</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_TXS3_REG</name>
	<description>Transmit Status Register 3</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>USB_UTR_REG</name>
	<description>USB test Register (for test purpose only)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_DIAG</name>
	<description>Diagnostic enable
'0': Normal operational.
'1': Access to the USB_XCVDIAG_REG and USB_TCR_REG enabled. For diagnostic purposes only </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_NCRC</name>
	<description>No CRC16
When this bit is set to 1, all packets transmitted by the Full/Low Speed USB node are sent without a trailing CRC16. Receive operations are unaffected. This mode is used to check that CRC errors can be detected by other nodes. For diagnostic purposes only </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_SF</name>
	<description>Short Frame
Enables the Frame timer to lock and track, short, non-compliant USB frame sizes. The Short Frame bit should not be set during normal operation. For test purposes only </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_UTR_RES</name>
	<description>Reserved. Must be kept to '0' </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_UX20CDR_REG</name>
	<description>Transceiver 2.0 Configuration and Diagnostics Register(for test purpose only)</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RPU_TEST7</name>
	<description>Test bit </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RPU_TEST_SW2</name>
	<description>0: Closes SW2 switch to reduced pull-up resistor connected to the USB_Dp and USB_Dm.
1: Opens SW2 switch resistor connected to the USB_Dp and USB_Dm (independent of the VBus state).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPU_TEST_SW1</name>
	<description>0: Enable the pull-up resistor on USB_Dp (SW1 closed)
1: Disable the pull-up resistor on USB_Dp (SW1 open) (Independent of the VBus state).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPU_TEST_EN</name>
	<description>Pull-Up Resistor Test Enable
0: Normal operation
1: Enables the test features controlled by RPU_TEST_SW1, RPU_TEST_SW1DM and RPU_TEST_SW2</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPU_TEST_SW1DM</name>
	<description>0: Enable the pull-up resistor on USB_Dm (SW1DM closed)
1: Disable the pull-up resistor on USB_Dm (SW1DM open) (Independent of the VBus state).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPU_RCDELAY</name>
	<description>Test bit, must be kept 0 </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPU_SSPROTEN</name>
	<description>Test bit, must be kept 0 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USB_XCVDIAG_REG</name>
	<description>Transceiver diagnostic Register (for test purpose only)</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>USB_VPIN</name>
	<description>With Bit0 = 1 this bit shows the level of the USB_Dp receive data from transceiver; i.e. D+ &lt;= VSE. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_VMIN</name>
	<description>With Bit0 = 1 this bit shows the level USB_Dm receive data from transceiver; i.e. D- &lt;= VSE. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_RCV</name>
	<description>With Bit0 = 1 this bit shows the differential level of the receive comparator. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_XCV_TXEN</name>
	<description>With Bit0 = 1, this bit enables test Bits 2,1. Must be kept to '0' for normal operation </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_XCV_TXn</name>
	<description>With Bit3,0 = 1, this bit sets USB_Dm to a high level, independent of LSMODE selection </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_XCV_TXp</name>
	<description>With Bit3,0 = 1, this bit sets USB_Dp to a high level, independent of LSMODE selection </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_XCV_TEST</name>
	<description>Enable USB_XCVDIAG_REG
0: Normal operation, test bits disabled
1: Enable test bits 7,6,5,3,2,1</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WAKEUP</name>
	<version>1.0</version>
	<description>WAKEUP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>92</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WKUP_CLEAR_P0_REG</name>
	<description>Clear event register for P0</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WKUP_CLEAR_P0</name>
	<description>Clear latched value of the GPIOs P0 when corresponding bit is 1</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CLEAR_P1_REG</name>
	<description>Clear event register for P1</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>WKUP_CLEAR_P1</name>
	<description>Clear latched value of the GPIOs P1 when corresponding bit is 1</description>
	<bitRange>[22:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wakeup counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0: no interrupt will be enabled
1: if you have an event an IRQ will be generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0 = no effect
1 = emulate key hit. First make this bit 0 before any new key hit can be sensed. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_DEB_VALUE</name>
	<description>Wakeup debounce time. If set to 0, no debouncing will be done.
Debounce time: N*1 ms. N =1..63</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P0_REG</name>
	<description>select the sesitivity polarity for each P0 input</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WKUP_POL_P0</name>
	<description>0: enabled input P0_xx will give an event if that input goes high
1: enabled input P0_xx will give an event if that input goes low</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P1_REG</name>
	<description>select the sesitivity polarity for each P1 input</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>WKUP_POL_P1</name>
	<description>0: enabled input P1_xx will give an event if that input goes high
1: enabled input P1_xx will give an event if that input goes low</description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_RESET_IRQ_REG</name>
	<description>Reset wakeup interrupt</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_IRQ_RST</name>
	<description>writing any value to this register will reset the interrupt. reading always returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P0_REG</name>
	<description>select which inputs from P0 port can trigger wkup counter</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P0</name>
	<description>0: input P0_xx is not enabled for wakeup event
1: input P0_xx is enabled for wakeup event</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P1_REG</name>
	<description>select which inputs from P1 port can trigger wkup counter</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P1</name>
	<description>0: input P1_xx is not enabled for wakeup event
1: input P1_xx is enabled for wakeup event </description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P0_REG</name>
	<description>select which inputs from P0 port can trigger interrupt</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WKUP_SEL_GPIO_P0</name>
	<description>0: input P0_xx is not enabled for GPIO interrupt
1: input P0_xx is enabled for GPIO interrupt</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P1_REG</name>
	<description>select which inputs from P1 port can trigger interrupt</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>WKUP_SEL_GPIO_P1</name>
	<description>0: input P1_xx is not enabled for GPIO interrupt
1: input P1_xx is enabled for GPIO interrupt</description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_STATUS_P0_REG</name>
	<description>Event status register for P0</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WKUP_STAT_P0</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P0. WKUP_STAT_P0[0] -&gt; P0_00.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>WKUP_STATUS_P1_REG</name>
	<description>Event status register for P1</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>WKUP_STAT_P1</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P1 WKUP_STATUS_1[0] -&gt; P1_00.</description>
	<bitRange>[22:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
